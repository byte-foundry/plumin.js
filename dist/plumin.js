!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.plumin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js":[function(require,module,exports){
// Run-time checking of preconditions.

'use strict';

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function (predicate, message) {
    if (!predicate) {
        throw new Error(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js":[function(require,module,exports){
// Drawing utility functions.

'use strict';

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js":[function(require,module,exports){
// Glyph encoding

'use strict';

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

// This is the encoding used for fonts created from scratch.
// It loops through all glyphs and finds the appropriate unicode value.
// Since it's linear time, other encodings will be faster.
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function (c) {
    var code, glyphs, i, glyph, j;
    code = c.charCodeAt(0);
    glyphs = this.font.glyphs;
    if (glyphs) {
        for (i = 0; i < glyphs.length; i += 1) {
            glyph = glyphs[i];
            for (j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

function CmapEncoding(cmap) {
    this.cmap = cmap;
}

CmapEncoding.prototype.charToGlyphIndex = function (c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

CffEncoding.prototype.charToGlyphIndex = function (s) {
    var code, charName;
    code = s.charCodeAt(0);
    charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

function GlyphNames(post) {
    var i;
    switch (post.version) {
    case 1:
        this.names = exports.standardNames.slice();
        break;
    case 2:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] < exports.standardNames.length) {
                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
            } else {
                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
            }
        }
        break;
    case 2.5:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
        }
        break;
    case 3:
        this.names = [];
        break;
    }
}

GlyphNames.prototype.nameToGlyphIndex = function (name) {
    return this.names.indexOf(name);
};

GlyphNames.prototype.glyphIndexToName = function (gid) {
    return this.names[gid];
};

function addGlyphNames(font) {
    var glyphIndexMap, charCodes, i, c, glyphIndex, glyph;
    glyphIndexMap = font.tables.cmap.glyphIndexMap;
    charCodes = Object.keys(glyphIndexMap);
    for (i = 0; i < charCodes.length; i += 1) {
        c = charCodes[i];
        glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs[glyphIndex];
        glyph.addUnicode(parseInt(c));
    }
    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs[i];
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js":[function(require,module,exports){
// The Font object

'use strict';

var path = require('./path');
var sfnt = require('./tables/sfnt');
var encoding = require('./encoding');

// A Font represents a loaded OpenType font file.
// It contains a set of glyphs and methods to draw text on a drawing context,
// or to get a path representing the text.
function Font(options) {
    options = options || {};
    // OS X will complain if the names are empty, so we put a single space everywhere by default.
    this.familyName = options.familyName || ' ';
    this.styleName = options.styleName || ' ';
    this.designer = options.designer || ' ';
    this.designerURL = options.designerURL || ' ';
    this.manufacturer = options.manufacturer || ' ';
    this.manufacturerURL = options.manufacturerURL || ' ';
    this.license = options.license || ' ';
    this.licenseURL = options.licenseURL || ' ';
    this.version = options.version || 'Version 0.1';
    this.description = options.description || ' ';
    this.copyright = options.copyright || ' ';
    this.trademark = options.trademark || ' ';
    this.unitsPerEm = options.unitsPerEm || 1000;
    this.supported = true;
    this.glyphs = options.glyphs || [];
    this.encoding = new encoding.DefaultEncoding(this);
    this.tables = {};
}

// Check if the font has a glyph for the given character.
Font.prototype.hasChar = function (c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

// Convert the given character to a single glyph index.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyphIndex = function (s) {
    return this.encoding.charToGlyphIndex(s);
};

// Convert the given character to a single Glyph object.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyph = function (c) {
    var glyphIndex, glyph;
    glyphIndex = this.charToGlyphIndex(c);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

// Convert the given text to a list of Glyph objects.
// Note that there is no strict one-to-one mapping between characters and
// glyphs, so the list of returned glyphs can be larger or smaller than the
// length of the given string.
Font.prototype.stringToGlyphs = function (s) {
    var i, c, glyphs;
    glyphs = [];
    for (i = 0; i < s.length; i += 1) {
        c = s[i];
        glyphs.push(this.charToGlyph(c));
    }
    return glyphs;
};

Font.prototype.nameToGlyphIndex = function (name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

Font.prototype.nameToGlyph = function (name) {
    var glyphIndex, glyph;
    glyphIndex = this.nametoGlyphIndex(name);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

Font.prototype.glyphIndexToName = function (gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }
    return this.glyphNames.glyphIndexToName(gid);
};

// Retrieve the value of the kerning pair between the left glyph (or its index)
// and the right glyph (or its index). If no kerning pair is found, return 0.
// The kerning value gets added to the advance width when calculating the spacing
// between glyphs.
Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

// Helper function that invokes the given callback for each glyph in the given text.
// The callback gets `(glyph, x, y, fontSize, options)`.
Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    var kerning, fontScale, glyphs, i, glyph, kerningValue;
    if (!this.supported) {
        return;
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || {};
    kerning = options.kerning === undefined ? true : options.kerning;
    fontScale = 1 / this.unitsPerEm * fontSize;
    glyphs = this.stringToGlyphs(text);
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }
        if (kerning && i < glyphs.length - 1) {
            kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
    }
};

// Create a Path object that represents the given text.
//
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
//
// Returns a Path object.
Font.prototype.getPath = function (text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        var path = glyph.getPath(x, y, fontSize);
        fullPath.extend(path);
    });
    return fullPath;
};

// Draw the text on the given drawing context.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

// Draw the points of all glyphs in the text.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawPoints(ctx, x, y, fontSize);
    });
};

// Draw lines indicating important font measurements for all glyphs in the text.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawMetrics(ctx, x, y, fontSize);
    });
};

// Validate
Font.prototype.validate = function () {
    var warnings = [];
    var font = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertStringAttribute(attrName) {
        assert(font[attrName] && font[attrName].trim().length > 0, 'No ' + attrName + ' specified.');
    }

    // Identification information
    assertStringAttribute('familyName');
    assertStringAttribute('weightName');
    assertStringAttribute('manufacturer');
    assertStringAttribute('copyright');
    assertStringAttribute('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
Font.prototype.toTables = function () {
    return sfnt.fontToTable(this);
};

Font.prototype.toBuffer = function () {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }
    return buffer;
};

// Initiate a download of the OpenType font.
Font.prototype.download = function () {
    var fileName = this.familyName.replace(/\s/g, '') + '-' + this.styleName + '.otf';
    var buffer = this.toBuffer();

    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function (fs) {
        fs.root.getFile(fileName, {create: true}, function (fileEntry) {
            fileEntry.createWriter(function (writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], {type: 'font/opentype'});
                writer.write(blob);

                 writer.addEventListener('writeend', function () {
                    // Navigating to the file will download it.
                    location.href = fileEntry.toURL();
                 }, false);
            });
        });
    }, function (err) {
        throw err;
    });
};

exports.Font = Font;

},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/sfnt":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js":[function(require,module,exports){
// The Glyph object

'use strict';

var check = require('./check');
var draw = require('./draw');
var path = require('./path');

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
function Glyph(options) {
    this.font = options.font || null;
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    this.xMin = options.xMin || 0;
    this.yMin = options.yMin || 0;
    this.xMax = options.xMax || 0;
    this.yMax = options.yMax || 0;
    this.advanceWidth = options.advanceWidth || 0;
    this.path = options.path || null;
}

Glyph.prototype.addUnicode = function (unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }
    this.unicodes.push(unicode);
};

// Convert the glyph to a Path we can draw on a drawing context.
//
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.getPath = function (x, y, fontSize) {
    var scale, p, commands, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    scale = 1 / this.font.unitsPerEm * fontSize;
    p = new path.Path();
    commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                               x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                      x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }
    return p;
};

// Split the glyph into contours.
// This function is here for backwards compatibility, and to
// provide raw access to the TrueType glyph outlines.
Glyph.prototype.getContours = function () {
    var contours, currentContour, i, pt;
    if (this.points === undefined) {
        return [];
    }
    contours = [];
    currentContour = [];
    for (i = 0; i < this.points.length; i += 1) {
        pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
Glyph.prototype.getMetrics = function () {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: 0
    };
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

// Draw the glyph on the given context.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.draw = function (ctx, x, y, fontSize) {
    this.getPath(x, y, fontSize).draw(ctx);
};

// Draw the points of the glyph.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var j, PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
    }

    var scale, i, blueCircles, redCircles, path, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;

    blueCircles = [];
    redCircles = [];
    path = this.path;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }
        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }
        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

// Draw lines indicating important font measurements.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);
    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (this.xMin * scale), -10000, x + (this.xMin * scale), 10000);
    draw.line(ctx, x + (this.xMax * scale), -10000, x + (this.xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-this.yMin * scale), 10000, y + (-this.yMin * scale));
    draw.line(ctx, -10000, y + (-this.yMax * scale), 10000, y + (-this.yMax * scale));
    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (this.advanceWidth * scale), -10000, x + (this.advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./draw":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js":[function(require,module,exports){
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2014 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */

'use strict';

var encoding = require('./encoding');
var _font = require('./font');
var glyph = require('./glyph');
var parse = require('./parse');
var path = require('./path');

var cmap = require('./tables/cmap');
var cff = require('./tables/cff');
var glyf = require('./tables/glyf');
var gpos = require('./tables/gpos');
var head = require('./tables/head');
var hhea = require('./tables/hhea');
var hmtx = require('./tables/hmtx');
var kern = require('./tables/kern');
var loca = require('./tables/loca');
var maxp = require('./tables/maxp');
var _name = require('./tables/name');
var os2 = require('./tables/os2');
var post = require('./tables/post');

// File loaders /////////////////////////////////////////////////////////

// Convert a Node.js Buffer to an ArrayBuffer
function toArrayBuffer(buffer) {
    var i,
        arrayBuffer = new ArrayBuffer(buffer.length),
        data = new Uint8Array(arrayBuffer);

    for (i = 0; i < buffer.length; i += 1) {
        data[i] = buffer[i];
    }

    return arrayBuffer;
}

function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function (err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, toArrayBuffer(buffer));
    });
}

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }
        return callback(null, request.response);
    };
    request.send();
}

// Public API ///////////////////////////////////////////////////////////

// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
// If the file could not be parsed (most likely because it contains Postscript outlines)
// we return an empty Font object with the `supported` flag set to `false`.
function parseBuffer(buffer) {
    var font, data, version, numTables, i, p, tag, offset, hmtxOffset, glyfOffset, locaOffset,
        cffOffset, kernOffset, gposOffset, indexToLocFormat, numGlyphs, locaTable,
        shortVersion;
    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.

    font = new _font.Font();
    data = new DataView(buffer, 0);

    version = parse.getFixed(data, 0);
    if (version === 1.0) {
        font.outlinesFormat = 'truetype';
    } else {
        version = parse.getTag(data, 0);
        if (version === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType version ' + version);
        }
    }

    numTables = parse.getUShort(data, 4);

    // Offset into the table records.
    p = 12;
    for (i = 0; i < numTables; i += 1) {
        tag = parse.getTag(data, p);
        offset = parse.getULong(data, p + 8);
        switch (tag) {
        case 'cmap':
            font.tables.cmap = cmap.parse(data, offset);
            font.encoding = new encoding.CmapEncoding(font.tables.cmap);
            if (!font.encoding) {
                font.supported = false;
            }
            break;
        case 'head':
            font.tables.head = head.parse(data, offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
        case 'hhea':
            font.tables.hhea = hhea.parse(data, offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
        case 'hmtx':
            hmtxOffset = offset;
            break;
        case 'maxp':
            font.tables.maxp = maxp.parse(data, offset);
            font.numGlyphs = numGlyphs = font.tables.maxp.numGlyphs;
            break;
        case 'name':
            font.tables.name = _name.parse(data, offset);
            font.familyName = font.tables.name.fontFamily;
            font.styleName = font.tables.name.fontSubfamily;
            break;
        case 'OS/2':
            font.tables.os2 = os2.parse(data, offset);
            break;
        case 'post':
            font.tables.post = post.parse(data, offset);
            font.glyphNames = new encoding.GlyphNames(font.tables.post);
            break;
        case 'glyf':
            glyfOffset = offset;
            break;
        case 'loca':
            locaOffset = offset;
            break;
        case 'CFF ':
            cffOffset = offset;
            break;
        case 'kern':
            kernOffset = offset;
            break;
        case 'GPOS':
            gposOffset = offset;
            break;
        }
        p += 16;
    }

    if (glyfOffset && locaOffset) {
        shortVersion = indexToLocFormat === 0;
        locaTable = loca.parse(data, locaOffset, numGlyphs, shortVersion);
        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
        encoding.addGlyphNames(font);
    } else if (cffOffset) {
        cff.parse(data, cffOffset, font);
        encoding.addGlyphNames(font);
    } else {
        font.supported = false;
    }

    if (font.supported) {
        if (kernOffset) {
            font.kerningPairs = kern.parse(data, kernOffset);
        } else {
            font.kerningPairs = {};
        }
        if (gposOffset) {
            gpos.parse(data, gposOffset, font);
        }
    }

    return font;
}

// Asynchronously load the font from a URL or a filesystem. When done, call the callback
// with two arguments `(err, font)`. The `err` will be null on success,
// the `font` is a Font object.
//
// We use the node.js callback convention so that
// opentype.js can integrate with frameworks like async.js.
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function (err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font = parseBuffer(arrayBuffer);
        if (!font.supported) {
            return callback('Font is not supported (is this a Postscript font?)');
        }
        return callback(null, font);
    });
}

exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.parse = parseBuffer;
exports.load = load;

},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./font":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js","./glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","./parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./tables/cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./tables/glyf":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js","./tables/gpos":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js","./tables/head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./tables/hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./tables/hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./tables/kern":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js","./tables/loca":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js","./tables/maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./tables/name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./tables/os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./tables/post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js","fs":false}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js":[function(require,module,exports){
// Parsing utility functions

'use strict';

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
exports.getUShort = function (dataView, offset) {
    return dataView.getUint16(offset, false);
};

exports.getCard16 = exports.getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function (dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function (dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function (dataView, offset) {
    var decimal, fraction;
    decimal = dataView.getInt16(offset, false);
    fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function (dataView, offset) {
    var tag = '', i;
    for (i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }
    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function (dataView, offset, offSize) {
    var i, v;
    v = 0;
    for (i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function (dataView, startOffset, endOffset) {
    var bytes, i;
    bytes = [];
    for (i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }
    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function (bytes) {
    var s, i;
    s = '';
    for (i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }
    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function () {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function () {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function () {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function () {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function () {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function (count) {
    var offsets = new Array(count),
        dataView = this.data,
        offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = exports.getUShort(dataView, offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};

Parser.prototype.parseString = function (length) {
    var dataView = this.data,
        offset = this.offset + this.relativeOffset,
        string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }
    return string;
};

Parser.prototype.parseTag = function () {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v / 65536;
};

Parser.prototype.parseVersion = function() {
    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);
    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function (type, amount) {
    if (amount === undefined) {
        amount = 1;
    }
    this.relativeOffset += typeOffsets[type] * amount;
};

exports.Parser = Parser;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js":[function(require,module,exports){
// Geometric objects

'use strict';

// A bzier path containing a set of path commands similar to a SVG path.
// Paths can be drawn on a context using `draw`.
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

Path.prototype.moveTo = function (x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

Path.prototype.lineTo = function (x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

Path.prototype.close = Path.prototype.closePath = function () {
    this.commands.push({
        type: 'Z'
    });
};

// Add the given path or list of commands to the commands of this path.
Path.prototype.extend = function (pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};

// Draw the path to a 2D context.
Path.prototype.draw = function (ctx) {
    var i, cmd;
    ctx.beginPath();
    for (i = 0; i < this.commands.length; i += 1) {
        cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

// Convert the Path to a string of path data instructions
// See http://www.w3.org/TR/SVG/paths.html#PathData
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toPathData = function (decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }
            s += floatToString(v);
        }
        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }
    return d;
};

// Convert the path to a SVG <path> element, as a string.
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toSVG = function (decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill & this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }
    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }
    svg += '/>';
    return svg;
};

exports.Path = Path;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js":[function(require,module,exports){
// Table metadata

'use strict';

var check = require('./check');
var encode = require('./types').encode;
var sizeOf = require('./types').sizeOf;

function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

Table.prototype.sizeOf = function () {
    var v = 0;
    for (var i = 0; i < this.fields.length; i += 1) {
        var field = this.fields[i];
        var value = this[field.name];
        if (value === undefined) {
            value = field.value;
        }
        if (typeof value.sizeOf === 'function') {
            v += value.sizeOf();
        } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);
            v += sizeOfFunction(value);
        }
    }
    return v;
};

Table.prototype.encode = function () {
    return encode.TABLE(this);
};

exports.Table = Table;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js":[function(require,module,exports){
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

'use strict';

var encoding = require('../encoding');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');
var table = require('../table');

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets, objects, count, endOffset, offsetSize, objectOffset, pos, i, value;
    offsets = [];
    objects = [];
    count = parse.getCard16(data, start);
    if (count !== 0) {
        offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    for (i = 0; i < offsets.length - 1; i += 1) {
        value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }
        objects.push(value);
    }
    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s, eof, lookup, b, n1, n2;
    s = '';
    eof = 15;
    lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        b = parser.parseByte();
        n1 = b >> 4;
        n2 = b & 15;

        if (n1 === eof) {
            break;
        }
        s += lookup[n1];

        if (n2 === eof) {
            break;
        }
        s += lookup[n2];
    }
    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1, b2, b3, b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) {
        return parseFloatOperand(parser);
    }
    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o, key, values, i, value;
    o = {};
    for (i = 0; i < entries.length; i += 1) {
        key = entries[i][0];
        values = entries[i][1];
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }
        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }
        o[key] = value;
    }
    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    var parser, entries, operands, op;
    start = start !== undefined ? start : 0;
    parser = new parse.Parser(data, start);
    entries = [];
    operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        op = parser.parseByte();
        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }
    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }
    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var i, m, value, newDict;
    newDict = {};
    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (i = 0; i < meta.length; i += 1) {
        m = meta[i];
        value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }
        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }
        newDict[m.name] = value;
    }
    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict;
    dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict;
    dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var parser, format, charset, i, sid, count;
    parser = new parse.Parser(data, start);
    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    charset = ['.notdef'];

    format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var enc, parser, format, nCodes, i, code, nRanges, first, nLeft, j;
    enc = {};
    parser = new parse.Parser(data, start);
    format = parser.parseCard8();
    if (format === 0) {
        nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            first = parser.parseCard8();
            nLeft = parser.parseCard8();
            for (j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }
    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(code, font, index) {
    var p, glyph, stack, nStems, haveWidth, width, x, y, c1x, c1y, c2x, c2y, v;
    p = new path.Path();
    stack = [];
    nStems = 0;
    haveWidth = false;
    width = font.defaultWidthX;
    x = y = 0;

    function parseStems() {
        var hasWidthArg;
        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var i, b1, b2, b3, b4, codeIndex, subrCode;
        i = 0;
        while (i < code.length) {
            v = code[i];
            i += 1;
            switch (v) {
            case 1: // hstem
                parseStems();
                break;
            case 3: // vstem
                parseStems();
                break;
            case 4: // vmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                p.moveTo(x, y);
                break;
            case 5: // rlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 6: // hlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 7: // vlineto
                while (stack.length > 0) {
                    y += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    x += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 8: // rrcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 10: // callsubr
                codeIndex = stack.pop() + font.subrsBias;
                subrCode = font.subrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 11: // return
                return;
            case 12: // escape
                v = code[i];
                i += 1;
                break;
            case 14: // endchar
                if (stack.length > 0 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                p.closePath();
                break;
            case 18: // hstemhm
                parseStems();
                break;
            case 19: // hintmask
            case 20: // cntrmask
                parseStems();
                i += (nStems + 7) >> 3;
                break;
            case 21: // rmoveto
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 22: // hmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 23: // vstemhm
                parseStems();
                break;
            case 24: // rcurveline
                while (stack.length > 2) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
            case 25: // rlinecurve
                while (stack.length > 6) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
            case 26: // vvcurveto
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 27: // hhcurveto
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 28: // shortint
                b1 = code[i];
                b2 = code[i + 1];
                stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                i += 2;
                break;
            case 29: // callgsubr
                codeIndex = stack.pop() + font.gsubrsBias;
                subrCode = font.gsubrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 30: // vhcurveto
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 31: // hvcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            default:
                if (v < 32) {
                    console.log('Glyph ' + index + ': unknown operator ' + v);
                } else if (v < 247) {
                    stack.push(v - 139);
                } else if (v < 251) {
                    b1 = code[i];
                    i += 1;
                    stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                    b1 = code[i];
                    i += 1;
                    stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                    b1 = code[i];
                    b2 = code[i + 1];
                    b3 = code[i + 2];
                    b4 = code[i + 3];
                    i += 4;
                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                }
            }
        }
    }

    parse(code);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.path = p;
    glyph.advanceWidth = width;
    return glyph;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }
    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    var header, nameIndex, topDictIndex, stringIndex, globalSubrIndex, topDict, privateDictOffset, privateDict,
        subrOffset, subrIndex, charString, charStringsIndex, charset, i;
    font.tables.cff = {};
    header = parseCFFHeader(data, start);
    nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    privateDictOffset = start + topDict['private'][1];
    privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        subrOffset = privateDictOffset + privateDict.subrs;
        subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }
    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = [];
    for (i = 0; i < font.nGlyphs; i += 1) {
        charString = charStringsIndex.objects[i];
        font.glyphs.push(parseCFFCharstring(charString, font, i));
    }
}


// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var i, sid;
    // Is the string in the CFF standard strings?
    i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }
    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }
    return sid;
}

function makeHeader() {
    return new table.Table('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Table('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }
    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {}, i, entry, value;
    for (i = 0; i < meta.length; i += 1) {
        entry = meta[i];
        value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }
            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }
    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Table('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Table('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Table('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }
    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Table('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Table('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }
    return t;
}

function glyphToOps(glyph) {
    var ops = [], path = glyph.path, x, y, i, cmd, dx, dy, dx1, dy1, dx2, dy2;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    x = 0;
    y = 0;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.type === 'M') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'L') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Q') {
            // FIXME: Add support for quad curves
            throw new Error('Writing quad curves is currently not supported.');
        } else if (cmd.type === 'C') {
            dx1 = cmd.x1 - x;
            dy1 = cmd.y1 - y;
            dx2 = cmd.x2 - cmd.x1;
            dy2 = cmd.y2 - cmd.y1;
            dx = cmd.x - cmd.x2;
            dy = cmd.y - cmd.y2;
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Z') {
            // Contours are closed automatically.
        }
    }
    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Table('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }
    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Table('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makePrivateDictIndex(privateDict) {
    var t = new table.Table('Private DICT INDEX', [
        {name: 'privateDicts', type: 'INDEX', value: []}
    ]);
    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'TABLE'},
        {name: 'nameIndex', type: 'TABLE'},
        {name: 'topDictIndex', type: 'TABLE'},
        {name: 'stringIndex', type: 'TABLE'},
        {name: 'globalSubrIndex', type: 'TABLE'},
        {name: 'charsets', type: 'TABLE'},
        {name: 'charStringsIndex', type: 'TABLE'},
        {name: 'privateDictIndex', type: 'TABLE'}
    ]);

    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyphNames.push(glyphs[i].name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    var privateDict = makePrivateDict(privateAttrs, strings);
    t.privateDictIndex = makePrivateDictIndex(privateDict);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    attrs.encoding = 0; // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js":[function(require,module,exports){
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var version, numTables, offset, platformId, encodingId, format, segCount,
        endCountParser, startCountParser, idDeltaParser, idRangeOffsetParser, glyphIndexOffset,
        endCount, startCount, i, c, idDelta, idRangeOffset, p, glyphIndex;
    var cmap = {};
    cmap.version = version = parse.getUShort(data, start);
    check.argument(version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numtables = numTables = parse.getUShort(data, start + 2);
    offset = -1;
    for (i = 0; i < numTables; i += 1) {
        platformId = parse.getUShort(data, start + 4 + (i * 8));
        encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }
    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    p = new parse.Parser(data, start + offset);
    cmap.format = format = p.parseUShort();
    check.argument(format === 4, 'Only format 4 cmap tables are supported.');
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    // segCount is stored x 2.
    cmap.segCount = segCount = p.parseUShort() >> 1;
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};

    endCountParser = new parse.Parser(data, start + offset + 14);
    startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        endCount = endCountParser.parseUShort();
        startCount = startCountParser.parseUShort();
        idDelta = idDeltaParser.parseShort();
        idRangeOffset = idRangeOffsetParser.parseUShort();
        for (c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;
                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i, j, glyph;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        for (j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }
    }
    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

     // Set up parallel segment arrays.
    var endCounts = [],
        startCounts = [],
        idDeltas = [],
        idRangeOffsets = [],
        glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }
    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;
    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js":[function(require,module,exports){
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

'use strict';

var check = require('../check');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }
        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }
    return v;
}

// Parse a TrueType glyph.
function parseGlyph(data, start, index, font) {
    var p, glyph, flag, i, j, flags,
        endPointIndices, numberOfCoordinates, repeatCount, points, point, px, py,
        component, moreComponents;
    p = new parse.Parser(data, start);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.numberOfContours = p.parseShort();
    glyph.xMin = p.parseShort();
    glyph.yMin = p.parseShort();
    glyph.xMax = p.parseShort();
    glyph.yMax = p.parseShort();
    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                repeatCount = p.parseByte();
                for (j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }
        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            points = [];
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }
                px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            component = {
                glyphIndex: p.parseUShort(),
                 xScale: 1,
                 scale01: 0,
                 scale10: 0,
                 yScale: 1,
                 dx: 0,
                 dy: 0
             };
            if ((flags & 1) > 0) {
                // The arguments are words
                component.dx = p.parseShort();
                component.dy = p.parseShort();
            } else {
                // The arguments are bytes
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            }
            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }
    return glyph;
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints, i, pt, newPt;
    newPoints = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}


function getContours(points) {
    var contours, currentContour, i, pt;
    contours = [];
    currentContour = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p, contours, i, realFirstPoint, j, contour, pt, firstPt,
        prevPt, midPt, curvePt, lastPt;
    p = new path.Path();
    if (!points) {
        return p;
    }
    contours = getContours(points);
    for (i = 0; i < contours.length; i += 1) {
        contour = contours[i];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }
            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }
        p.moveTo(firstPt.x, firstPt.y);

        for (j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            pt = contour[j];
            prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }
        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }
    p.closePath();
    return p;
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs, i, j, offset, nextOffset, glyph,
        component, componentGlyph, transformedPoints;
    glyphs = [];
    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        offset = loca[i];
        nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(parseGlyph(data, start + offset, i, font));
        } else {
            glyphs.push(new _glyph.Glyph({font: font, index: i}));
        }
    }
    // Go over the glyphs again, resolving the composite glyphs.
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        if (glyph.isComposite) {
            for (j = 0; j < glyph.components.length; j += 1) {
                component = glyph.components[j];
                componentGlyph = glyphs[component.glyphIndex];
                if (componentGlyph.points) {
                    transformedPoints = transformPoints(componentGlyph.points, component);
                    glyph.points = glyph.points.concat(transformedPoints);
                }
            }
        }
        glyph.path = getPath(glyph.points);
    }
    return glyphs;
}

exports.parse = parseGlyfTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js":[function(require,module,exports){
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start),
        n = p.parseUShort(),
        list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }
    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort(),
        count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    }
    else if (format === 2) {
        var i, begin, end, index, coverage = [];
        for (; count--;) {
            begin = p.parseUShort();
            end = p.parseUShort();
            index = p.parseUShort();
            for (i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }
        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort(),
            glyphCount = p.parseUShort(),
            classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    }
    else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort(),
            startGlyphs = [],
            endGlyphs = [],
            classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }
        return function(glyphID) {
            var l, c, r;
            l = 0;
            r = startGlyphs.length - 1;
            while (l < r) {
                c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }
            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }
            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    var format, coverageOffset, coverage, valueFormat1, valueFormat2,
        sharedPairSets, firstGlyph, secondGlyph, value1, value2;
    // This part is common to format 1 and format 2 subtables
    format = p.parseUShort();
    coverageOffset = p.parseUShort();
    coverage = parseCoverageTable(data, start+coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    valueFormat1 = p.parseUShort();
    valueFormat2 = p.parseUShort();
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount, pairSetOffsets, pairSetOffset, sharedPairSet, pairValueCount, pairSet;
        pairSetCount = p.parseUShort();
        pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            pairSetOffset = pairSetOffsets[firstGlyph];
            sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }
            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }
        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    }
    else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset, classDef2Offset, class1Count, class2Count, i, j,
            getClass1, getClass2, kerningMatrix, kerningRow, covered;
        classDef1Offset = p.parseUShort();
        classDef2Offset = p.parseUShort();
        class1Count = p.parseUShort();
        class2Count = p.parseUShort();
        getClass1 = parseClassDefTable(data, start+classDef1Offset);
        getClass2 = parseClassDefTable(data, start+classDef2Offset);

        // Parse kerning values by class pair.
        kerningMatrix = [];
        for (i = 0; i < class1Count; i++) {
            kerningRow = kerningMatrix[i] = [];
            for (j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        covered = {};
        for(i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return null;
            var class1 = getClass1(leftGlyph),
                class2 = getClass2(rightGlyph),
                kerningRow = kerningMatrix[class1];
            return kerningRow ? kerningRow[class2] : null;
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var table, lookupType, lookupFlag, useMarkFilteringSet, subTableCount, subTableOffsets, subtables, i;
    lookupType = p.parseUShort();
    lookupFlag = p.parseUShort();
    useMarkFilteringSet = lookupFlag & 0x10;
    subTableCount = p.parseUShort();
    subTableOffsets = p.parseOffset16List(subTableCount);
    table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        subtables = [];
        for (i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }
            return 0;
        };
    }
    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p, tableVersion, lookupListOffset, scriptList, i, featureList, lookupCount,
        lookupTableOffsets, lookupListAbsoluteOffset, table;

    p = new parse.Parser(data, start);
    tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    scriptList = parseTaggedListTable(data, start+p.parseUShort());
    // 'kern' is the feature we are looking for.
    featureList = parseTaggedListTable(data, start+p.parseUShort());

    // LookupList
    lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    lookupCount = p.parseUShort();
    lookupTableOffsets = p.parseOffset16List(lookupCount);
    lookupListAbsoluteOffset = start + lookupListOffset;
    for (i = 0; i < lookupCount; i++) {
        table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js":[function(require,module,exports){
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {},
        p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();     // 50
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: 0},
        {name: 'modified', type: 'LONGDATETIME', value: 0},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js":[function(require,module,exports){
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {},
        p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js":[function(require,module,exports){
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var p, i, glyph, advanceWidth, leftSideBearing;
    p = new parse.Parser(data, start);
    for (i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        glyph = glyphs[i];
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }
    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;




},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js":[function(require,module,exports){
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var pairs, p, tableVersion, subTableVersion, nPairs,
        i, leftIndex, rightIndex, value;
    pairs = {};
    p = new parse.Parser(data, start);
    tableVersion = p.parseUShort();
    check.argument(tableVersion === 0, 'Unsupported kern table version.');
    // Skip nTables.
    p.skip('uShort', 1);
    subTableVersion = p.parseUShort();
    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subTableLength, subTableCoverage
    p.skip('uShort', 2);
    nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (i = 0; i < nPairs; i += 1) {
        leftIndex = p.parseUShort();
        rightIndex = p.parseUShort();
        value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

exports.parse = parseKernTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js":[function(require,module,exports){
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

'use strict';

var parse = require('../parse');

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p, parseFn, glyphOffsets, glyphOffset, i;
    p = new parse.Parser(data, start);
    parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    glyphOffsets = [];
    for (i = 0; i < numGlyphs + 1; i += 1) {
        glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}

exports.parse = parseLocaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js":[function(require,module,exports){
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {},
        p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js":[function(require,module,exports){
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

'use strict';

var encode = require('../types').encode;
var parse = require('../parse');
var table = require('../table');

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'licence',                // 13
    'licenceURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

// Parse the naming `name` table
// Only Windows Unicode English names are supported.
// Format 1 additional fields are not supported
function parseNameTable(data, start) {
    var name = {},
        p = new parse.Parser(data, start);
    name.format = p.parseUShort();
    var count = p.parseUShort(),
        stringOffset = p.offset + p.parseUShort();
    var platformID, encodingID, languageID, nameID, property, byteLength,
        offset, str, i, j, codePoints;
    var unknownCount = 0;
    for(i = 0; i < count; i++) {
        platformID = p.parseUShort();
        encodingID = p.parseUShort();
        languageID = p.parseUShort();
        nameID = p.parseUShort();
        property = nameTableNames[nameID];
        byteLength = p.parseUShort();
        offset = p.parseUShort();
        // platformID - encodingID - languageID standard combinations :
        // 1 - 0 - 0 : Macintosh, Roman, English
        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {
            codePoints = [];
            var length = byteLength/2;
            for(j = 0; j < length; j++, offset += 2) {
                codePoints[j] = parse.getShort(data, stringOffset+offset);
            }
            str = String.fromCharCode.apply(null, codePoints);
            if (property) {
                name[property] = str;
            }
            else {
                unknownCount++;
                name['unknown'+unknownCount] = str;
            }
        }

    }
    if (name.format === 1) {
        name.langTagCount = p.parseUShort();
    }
    return name;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Table('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

function addMacintoshNameRecord(t, recordID, s, offset) {
    // Macintosh, Roman, English
    var stringBytes = encode.STRING(s);
    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
    t.strings.push(stringBytes);
    offset += stringBytes.length;
    return offset;
}

function addWindowsNameRecord(t, recordID, s, offset) {
    // Windows, Unicode BMP (UCS-2), US English
    var utf16Bytes = encode.UTF16(s);
    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
    t.strings.push(utf16Bytes);
    offset += utf16Bytes.length;
    return offset;
}

function makeNameTable(options) {
    var i, s;
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: 0},
        {name: 'stringOffset', type: 'USHORT', value: 0}
    ]);
    t.records = [];
    t.strings = [];
    var offset = 0;
    // Add Macintosh records first
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addMacintoshNameRecord(t, i, s, offset);
        }
    }
    // Then add Windows records
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addWindowsNameRecord(t, i, s, offset);
        }
    }

    t.count = t.records.length;
    t.stringOffset = 6 + t.count * 12;
    for (i = 0; i < t.records.length; i += 1) {
        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});
    }
    for (i = 0; i < t.strings.length; i += 1) {
        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});
    }
    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","../types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js":[function(require,module,exports){
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {},
        p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 0},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 0},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 0},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseOS2Table;
exports.make = makeOS2Table;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js":[function(require,module,exports){
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

'use strict';

var encoding = require('../encoding');
var parse = require('../parse');
var table = require('../table');

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {},
        p = new parse.Parser(data, start),
        i, nameLength;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
    case 1:
        post.names = encoding.standardNames.slice();
        break;
    case 2:
        post.numberOfGlyphs = p.parseUShort();
        post.glyphNameIndex = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.glyphNameIndex[i] = p.parseUShort();
        }
        post.names = [];
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
        }
        break;
    case 2.5:
        post.numberOfGlyphs = p.parseUShort();
        post.offset = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.offset[i] = p.parseChar();
        }
        break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js":[function(require,module,exports){
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

'use strict';

var check = require('../check');
var table = require('../table');

var cmap = require('./cmap');
var cff = require('./cff');
var head = require('./head');
var hhea = require('./hhea');
var hmtx = require('./hmtx');
var maxp = require('./maxp');
var _name = require('./name');
var os2 = require('./os2');
var post = require('./post');

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }
    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }
    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Table('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function (r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs[glyphIndex];
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}

// Return the smallest and largest unicode values of the characters in this font.
// For most fonts the smallest value would be 20 (space).
function charCodeBounds(glyphs) {
    var minCode, maxCode;
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        if (glyph.unicode >= 20) {
            if (minCode === undefined) {
                minCode = glyph.unicode;
            } else if (glyph.unicode < minCode) {
                minCode = glyph.unicode;
            }
            if (maxCode === undefined) {
                maxCode = glyph.unicode;
            } else if (glyph.unicode > maxCode) {
                maxCode = glyph.unicode;
            }
        }
    }
    return [minCode, maxCode];
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }
    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs[i];
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = globals.yMax;
    globals.descender = globals.yMin;

    var headTable = head.make({
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax
    });

    var hheaTable = hhea.make({
        // Adding a little here makes OS X Quick Look happy
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var codeBounds = charCodeBounds(font.glyphs);
    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: 500, // Medium FIXME Make this configurable
        usWidthClass: 5, // Medium (normal) FIXME Make this configurable
        usFirstCharIndex: codeBounds[0],
        usLastCharIndex: codeBounds[1],
        ulUnicodeRange1: 0x00000001, // Basic Latin
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.ascender,
        usWinDescent: -globals.descender,
        ulCodePageRange1: 0x00000001, // Basic Latin
        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });


    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var fullName = font.familyName + ' ' + font.styleName;
    var postScriptName = font.familyName.replace(/\s/g, '') + '-' + font.styleName;
    var nameTable = _name.make({
        copyright: font.copyright,
        fontFamily: font.familyName,
        fontSubfamily: font.styleName,
        uniqueID: font.manufacturer + ':' + fullName,
        fullName: fullName,
        version: font.version,
        postScriptName: postScriptName,
        trademark: font.trademark,
        manufacturer: font.manufacturer,
        designer: font.designer,
        description: font.description,
        manufacturerURL: font.manufacturerURL,
        designerURL: font.designerURL,
        license: font.license,
        licenseURL: font.licenseURL,
        preferredFamily: font.familyName,
        preferredSubfamily: font.styleName
    });
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.version,
        fullName: fullName,
        familyName: font.familyName,
        weightName: font.styleName,
        postScriptName: postScriptName
    });
    // Order the tables according to the the OpenType specification 1.4.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];

    var sfntTable = makeSfntTable(tables);

    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    headTable.checkSumAdjustment = 0xB1B0AFBA - checkSum;

    // Build the font again, now with the proper checkSum.
    sfntTable = makeSfntTable(tables);

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","./cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js":[function(require,module,exports){
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

/* global WeakMap */

'use strict';

var check = require('./check');

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

var decode = {};
var encode = {};
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function () {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

// Convert an 8-bit unsigned integer to a list of 1 byte.
encode.BYTE = function (v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};

sizeOf.BYTE = constant(1);

// Convert a 8-bit signed integer to a list of 1 byte.
encode.CHAR = function (v) {
    return [v.charCodeAt(0)];
};

sizeOf.BYTE = constant(1);

// Convert an ASCII string to a list of bytes.
encode.CHARARRAY = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.CHARARRAY = function (v) {
    return v.length;
};

// Convert a 16-bit unsigned integer to a list of 2 bytes.
encode.USHORT = function (v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.USHORT = constant(2);

// Convert a 16-bit signed integer to a list of 2 bytes.
encode.SHORT = function (v) {
    // Two's complement
    if (v >= LIMIT16){
        v = - ( 2 * LIMIT16 - v);
    }
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.SHORT = constant(2);

// Convert a 24-bit unsigned integer to a list of 3 bytes.
encode.UINT24 = function (v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.UINT24 = constant(3);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.ULONG = function (v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.ULONG = constant(4);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.LONG = function (v) {
     // Two's complement
    if (v >= LIMIT32){
        v = - ( 2 * LIMIT32 - v);
    }
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;


// FIXME Implement LONGDATETIME
encode.LONGDATETIME = function () {
    return [0, 0, 0, 0, 0, 0, 0, 0];
};

sizeOf.LONGDATETIME = constant(8);

// Convert a 4-char tag to a list of 4 bytes.
encode.TAG = function (v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
encode.NUMBER = function (v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131 ) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

sizeOf.NUMBER = function (v) {
    return encode.NUMBER(v).length;
};

// Convert a signed number between -32768 and +32767 to a three-byte value.
// This ensures we always use three bytes, but is not the most compact format.
encode.NUMBER16 = function (v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER16 = constant(2);

// Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
// This is useful if you want to be sure you always use four bytes,
// at the expense of wasting a few bytes for smaller numbers.
encode.NUMBER32 = function (v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER32 = constant(4);

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

// Convert a ASCII string to a list of UTF16 bytes.
encode.UTF16 = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(0);
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.UTF16 = function (v) {
    return v.length * 2;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
encode.INDEX = function (l) {
    var offSize, offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
        dataSize, i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    offset = 1; // First offset is always 1.
    offsets = [offset];
    data = [];
    dataSize = 0;
    for (i = 0; i < l.length; i += 1) {
        v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        dataSize += v.length;
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    encodedOffsets = [];
    offSize = (1 + Math.floor(Math.log(dataSize)/Math.log(2)) / 8) | 0;
    offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

sizeOf.INDEX = function (v) {
    return encode.INDEX(v).length;
};

// Convert an object to a CFF DICT structure.
// The keys should be numeric.
// The values should be objects containing name / type / value.
encode.DICT = function (m) {
    var d = [],
        keys = Object.keys(m),
        length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

sizeOf.DICT = function (m) {
    return encode.DICT(m).length;
};

encode.OPERATOR = function (v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

encode.OPERAND = function (v, type) {
    var d, i;
    d = [];
    if (Array.isArray(type)) {
        for (i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else {
            // FIXME Add support for booleans
            d = d.concat(encode.NUMBER(v));
        }
    }
    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();
// Convert a list of CharString operations to bytes.
encode.CHARSTRING = function (ops) {
    if ( wmm && wmm.has( ops ) ) {
        return wmm.get( ops );
    }

    var d = [],
        length = ops.length,
        op,
        i;

    for (i = 0; i < length; i += 1) {
        op = ops[i];
        d = d.concat( encode[op.type](op.value) );
    }

    if ( wmm ) {
        wmm.set( ops, d );
    }

    return d;
};

sizeOf.CHARSTRING = function (ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

// Convert an object containing name / type / value to bytes.
encode.OBJECT = function (v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

// Convert a table object to bytes.
// A table contains a list of fields containing the metadata (name, type and default value).
// The table itself has the field values set as attributes.
encode.TABLE = function (table) {
    var d = [],
        length = table.fields.length,
        i;

    for (i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        var bytes = encodingFunction(value);
        d = d.concat(bytes);
    }
    return d;
};

// Merge in a list of bytes.
encode.LITERAL = function (v) {
    return v;
};

sizeOf.LITERAL = function (v) {
    return v.length;
};


exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js":[function(require,module,exports){
(function (process){
/*!
 * Paper.js v0.9.21 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Tue Dec 2 14:41:40 2014 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

          var noCanvas =
              typeof process === 'object' ||
              ( typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope );

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && (!exclude || !exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

if (!Array.isArray) {
    Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };
}

if (!noCanvas && !document.head) {
    document.head = document.getElementsByTagName('head')[0];
}

Base.inject({
    toString: function() {
        return this._id != null
            ?  (this._class || 'Object') + (this._name
                ? " '" + this._name + "'"
                : ' @' + this._id)
            : '{ ' + Base.each(this, function(value, key) {
                if (!/^_/.test(key)) {
                    var type = typeof value;
                    this.push(key + ': ' + (type === 'number'
                            ? Formatter.instance.number(value)
                            : type === 'string' ? "'" + value + "'" : value));
                }
            }, []).join(', ') + ' }';
    },

    getClassName: function() {
        return this._class || '';
    },

    exportJSON: function(options) {
        return Base.exportJSON(this, options);
    },

    toJSON: function() {
        return Base.serialize(this);
    },

    _set: function(props, exclude, dontCheck) {
        if (props && (dontCheck || Base.isPlainObject(props))) {
            var orig = props._filtering || props;
            for (var key in orig) {
                if (orig.hasOwnProperty(key) && !(exclude && exclude[key])) {
                    var value = props[key];
                    if (value !== undefined)
                        this[key] = value;
                }
            }
            return true;
        }
    },

    statics: {

        exports: {
            enumerable: true 
        },

        extend: function extend() {
            var res = extend.base.apply(this, arguments),
                name = res.prototype._class;
            if (name && !Base.exports[name])
                Base.exports[name] = res;
            return res;
        },

        equals: function(obj1, obj2) {
            function checkKeys(o1, o2) {
                for (var i in o1)
                    if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
                        return false;
                return true;
            }
            if (obj1 === obj2)
                return true;
            if (obj1 && obj1.equals)
                return obj1.equals(obj2);
            if (obj2 && obj2.equals)
                return obj2.equals(obj1);
            if (Array.isArray(obj1) && Array.isArray(obj2)) {
                if (obj1.length !== obj2.length)
                    return false;
                for (var i = 0, l = obj1.length; i < l; i++) {
                    if (!Base.equals(obj1[i], obj2[i]))
                        return false;
                }
                return true;
            }
            if (obj1 && typeof obj1 === 'object'
                    && obj2 && typeof obj2 === 'object') {
                if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
                    return false;
                for (var i in obj1) {
                    if (obj1.hasOwnProperty(i)
                            && !Base.equals(obj1[i], obj2[i]))
                        return false;
                }
                return true;
            }
            return false;
        },

        read: function(list, start, options, length) {
            if (this === Base) {
                var value = this.peek(list, start);
                list.__index++;
                return value;
            }
            var proto = this.prototype,
                readIndex = proto._readIndex,
                index = start || readIndex && list.__index || 0;
            if (!length)
                length = list.length - index;
            var obj = list[index];
            if (obj instanceof this
                || options && options.readNull && obj == null && length <= 1) {
                if (readIndex)
                    list.__index = index + 1;
                return obj && options && options.clone ? obj.clone() : obj;
            }
            obj = Base.create(this.prototype);
            if (readIndex)
                obj.__read = true;
            obj = obj.initialize.apply(obj, index > 0 || length < list.length
                ? Array.prototype.slice.call(list, index, index + length)
                : list) || obj;
            if (readIndex) {
                list.__index = index + obj.__read;
                obj.__read = undefined;
            }
            return obj;
        },

        peek: function(list, start) {
            return list[list.__index = start || list.__index || 0];
        },

        remain: function(list) {
            return list.length - (list.__index || 0);
        },

        readAll: function(list, start, options) {
            var res = [],
                entry;
            for (var i = start || 0, l = list.length; i < l; i++) {
                res.push(Array.isArray(entry = list[i])
                        ? this.read(entry, 0, options)
                        : this.read(list, i, options, 1));
            }
            return res;
        },

        readNamed: function(list, name, start, options, length) {
            var value = this.getNamed(list, name),
                hasObject = value !== undefined;
            if (hasObject) {
                var filtered = list._filtered;
                if (!filtered) {
                    filtered = list._filtered = Base.create(list[0]);
                    filtered._filtering = list[0];
                }
                filtered[name] = undefined;
            }
            return this.read(hasObject ? [value] : list, start, options, length);
        },

        getNamed: function(list, name) {
            var arg = list[0];
            if (list._hasObject === undefined)
                list._hasObject = list.length === 1 && Base.isPlainObject(arg);
            if (list._hasObject)
                return name ? arg[name] : list._filtered || arg;
        },

        hasNamed: function(list, name) {
            return !!this.getNamed(list, name);
        },

        isPlainValue: function(obj, asString) {
            return this.isPlainObject(obj) || Array.isArray(obj)
                    || asString && typeof obj === 'string';
        },

        serialize: function(obj, options, compact, dictionary) {
            options = options || {};

            var root = !dictionary,
                res;
            if (root) {
                options.formatter = new Formatter(options.precision);
                dictionary = {
                    length: 0,
                    definitions: {},
                    references: {},
                    add: function(item, create) {
                        var id = '#' + item._id,
                            ref = this.references[id];
                        if (!ref) {
                            this.length++;
                            var res = create.call(item),
                                name = item._class;
                            if (name && res[0] !== name)
                                res.unshift(name);
                            this.definitions[id] = res;
                            ref = this.references[id] = [id];
                        }
                        return ref;
                    }
                };
            }
            if (obj && obj._serialize) {
                res = obj._serialize(options, dictionary);
                var name = obj._class;
                if (name && !compact && !res._compact && res[0] !== name)
                    res.unshift(name);
            } else if (Array.isArray(obj)) {
                res = [];
                for (var i = 0, l = obj.length; i < l; i++)
                    res[i] = Base.serialize(obj[i], options, compact,
                            dictionary);
                if (compact)
                    res._compact = true;
            } else if (Base.isPlainObject(obj)) {
                res = {};
                for (var i in obj)
                    if (obj.hasOwnProperty(i))
                        res[i] = Base.serialize(obj[i], options, compact,
                                dictionary);
            } else if (typeof obj === 'number') {
                res = options.formatter.number(obj, options.precision);
            } else {
                res = obj;
            }
            return root && dictionary.length > 0
                    ? [['dictionary', dictionary.definitions], res]
                    : res;
        },

        deserialize: function(json, create, _data) {
            var res = json;
            _data = _data || {};
            if (Array.isArray(json)) {
                var type = json[0],
                    isDictionary = type === 'dictionary';
                if (!isDictionary) {
                    if (_data.dictionary && json.length == 1 && /^#/.test(type))
                        return _data.dictionary[type];
                    type = Base.exports[type];
                }
                res = [];
                for (var i = type ? 1 : 0, l = json.length; i < l; i++)
                    res.push(Base.deserialize(json[i], create, _data));
                if (isDictionary) {
                    _data.dictionary = res[0];
                } else if (type) {
                    var args = res;
                    if (create) {
                        res = create(type, args);
                    } else {
                        res = Base.create(type.prototype);
                        type.apply(res, args);
                    }
                }
            } else if (Base.isPlainObject(json)) {
                res = {};
                for (var key in json)
                    res[key] = Base.deserialize(json[key], create, _data);
            }
            return res;
        },

        exportJSON: function(obj, options) {
            var json = Base.serialize(obj, options);
            return options && options.asString === false
                    ? json
                    : JSON.stringify(json);
        },

        importJSON: function(json, target) {
            return Base.deserialize(
                    typeof json === 'string' ? JSON.parse(json) : json,
                    function(type, args) {
                        var obj = target && target.constructor === type
                                ? target
                                : Base.create(type.prototype),
                            isTarget = obj === target;
                        if (args.length === 1 && obj instanceof Item
                                && (isTarget || !(obj instanceof Layer))) {
                            var arg = args[0];
                            if (Base.isPlainObject(arg))
                                arg.insert = false;
                        }
                        type.apply(obj, args);
                        if (isTarget)
                            target = null;
                        return obj;
                    });
        },

        splice: function(list, items, index, remove) {
            var amount = items && items.length,
                append = index === undefined;
            index = append ? list.length : index;
            if (index > list.length)
                index = list.length;
            for (var i = 0; i < amount; i++)
                items[i]._index = index + i;
            if (append) {
                list.push.apply(list, items);
                return [];
            } else {
                var args = [index, remove];
                if (items)
                    args.push.apply(args, items);
                var removed = list.splice.apply(list, args);
                for (var i = 0, l = removed.length; i < l; i++)
                    removed[i]._index = undefined;
                for (var i = index + amount, l = list.length; i < l; i++)
                    list[i]._index = i;
                return removed;
            }
        },

        capitalize: function(str) {
            return str.replace(/\b[a-z]/g, function(match) {
                return match.toUpperCase();
            });
        },

        camelize: function(str) {
            return str.replace(/-(.)/g, function(all, chr) {
                return chr.toUpperCase();
            });
        },

        hyphenate: function(str) {
            return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        }
    }
});

var Emitter = {
    on: function(type, func) {
        if (typeof type !== 'string') {
            Base.each(type, function(value, key) {
                this.on(key, value);
            }, this);
        } else {
            var entry = this._eventTypes[type];
            if (entry) {
                var handlers = this._callbacks = this._callbacks || {};
                handlers = handlers[type] = handlers[type] || [];
                if (handlers.indexOf(func) === -1) { 
                    handlers.push(func);
                    if (entry.install && handlers.length == 1)
                        entry.install.call(this, type);
                }
            }
        }
        return this;
    },

    off: function(type, func) {
        if (typeof type !== 'string') {
            Base.each(type, function(value, key) {
                this.off(key, value);
            }, this);
            return;
        }
        var entry = this._eventTypes[type],
            handlers = this._callbacks && this._callbacks[type],
            index;
        if (entry && handlers) {
            if (!func || (index = handlers.indexOf(func)) !== -1
                    && handlers.length === 1) {
                if (entry.uninstall)
                    entry.uninstall.call(this, type);
                delete this._callbacks[type];
            } else if (index !== -1) {
                handlers.splice(index, 1);
            }
        }
        return this;
    },

    once: function(type, func) {
        return this.on(type, function() {
            func.apply(this, arguments);
            this.off(type, func);
        });
    },

    emit: function(type, event) {
        var handlers = this._callbacks && this._callbacks[type];
        if (!handlers)
            return false;
        var args = [].slice.call(arguments, 1);
        for (var i = 0, l = handlers.length; i < l; i++) {
            if (handlers[i].apply(this, args) === false
                    && event && event.stop) {
                event.stop();
                break;
            }
        }
        return true;
    },

    responds: function(type) {
        return !!(this._callbacks && this._callbacks[type]);
    },

    attach: '#on',
    detach: '#off',
    fire: '#emit',

    _installEvents: function(install) {
        var handlers = this._callbacks,
            key = install ? 'install' : 'uninstall';
        for (var type in handlers) {
            if (handlers[type].length > 0) {
                var entry = this._eventTypes[type],
                    func = entry[key];
                if (func)
                    func.call(this, type);
            }
        }
    },

    statics: {
        inject: function inject(src) {
            var events = src._events;
            if (events) {
                var types = {};
                Base.each(events, function(entry, key) {
                    var isString = typeof entry === 'string',
                        name = isString ? entry : key,
                        part = Base.capitalize(name),
                        type = name.substring(2).toLowerCase();
                    types[type] = isString ? {} : entry;
                    name = '_' + name;
                    src['get' + part] = function() {
                        return this[name];
                    };
                    src['set' + part] = function(func) {
                        var prev = this[name];
                        if (prev)
                            this.off(type, prev);
                        if (func)
                            this.on(type, func);
                        this[name] = func;
                    };
                });
                src._eventTypes = types;
            }
            return inject.base.apply(this, arguments);
        }
    }
};

var PaperScope = Base.extend({
    _class: 'PaperScope',

    initialize: function PaperScope() {console.log('here');
        paper = this;
        this.settings = new Base({
            applyMatrix: true,
            handleSize: 4,
            hitTolerance: 0
        });
        this.project = null;
        this.projects = [];
        this.tools = [];
        this.palettes = [];
        this._id = PaperScope._id++;
        PaperScope._scopes[this._id] = this;
        var proto = PaperScope.prototype;
        if ( noCanvas ) {
            return;
        }
        if (!this.support) {
            var ctx = CanvasProvider.getContext(1, 1);
            proto.support = {
                nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
                nativeBlendModes: BlendMode.nativeModes
            };
            CanvasProvider.release(ctx);
        }

        if (!this.browser) {
            var browser = proto.browser = {};
            navigator.userAgent.toLowerCase().replace(
                /(opera|chrome|safari|webkit|firefox|msie|trident)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
                function(all, n, v1, v2, rv) {
                    if (!browser.chrome) {
                        var v = n === 'opera' ? v2 : v1;
                        if (n === 'trident') {
                            v = rv;
                            n = 'msie';
                        }
                        browser.version = v;
                        browser.versionNumber = parseFloat(v);
                        browser.name = n;
                        browser[n] = true;
                    }
                }
            );
            if (browser.chrome)
                delete browser.webkit;
        }
    },

    version: '0.9.21',

    getView: function() {
        return this.project && this.project.getView();
    },

    getPaper: function() {
        return this;
    },

    execute: function(code, url, options) {
        paper.PaperScript.execute(code, this, url, options);
        View.updateFocus();
    },

    install: function(scope) {
        var that = this;
        Base.each(['project', 'view', 'tool'], function(key) {
            Base.define(scope, key, {
                configurable: true,
                get: function() {
                    return that[key];
                }
            });
        });
        for (var key in this)
            if (!/^_/.test(key) && this[key])
                scope[key] = this[key];
    },

    setup: function(element) {
        paper = this;
        this.project = new Project(element);
        return this;
    },

    activate: function() {
        paper = this;
    },

    clear: function() {
        for (var i = this.projects.length - 1; i >= 0; i--)
            this.projects[i].remove();
        for (var i = this.tools.length - 1; i >= 0; i--)
            this.tools[i].remove();
        for (var i = this.palettes.length - 1; i >= 0; i--)
            this.palettes[i].remove();
    },

    remove: function() {
        this.clear();
        delete PaperScope._scopes[this._id];
    },

    statics: new function() {
        function handleAttribute(name) {
            name += 'Attribute';
            return function(el, attr) {
                return el[name](attr) || el[name]('data-paper-' + attr);
            };
        }

        return {
            _scopes: {},
            _id: 0,

            get: function(id) {
                return this._scopes[id] || null;
            },

            getAttribute: handleAttribute('get'),
            hasAttribute: handleAttribute('has')
        };
    }
});

var PaperScopeItem = Base.extend(Emitter, {

    initialize: function(activate) {
        this._scope = paper;
        this._index = this._scope[this._list].push(this) - 1;
        if (activate || !this._scope[this._reference])
            this.activate();
    },

    activate: function() {
        if (!this._scope)
            return false;
        var prev = this._scope[this._reference];
        if (prev && prev !== this)
            prev.emit('deactivate');
        this._scope[this._reference] = this;
        this.emit('activate', prev);
        return true;
    },

    isActive: function() {
        return this._scope[this._reference] === this;
    },

    remove: function() {
        if (this._index == null)
            return false;
        Base.splice(this._scope[this._list], null, this._index, 1);
        if (this._scope[this._reference] == this)
            this._scope[this._reference] = null;
        this._scope = null;
        return true;
    }
});

var Formatter = Base.extend({
    initialize: function(precision) {
        this.precision = precision || 5;
        this.multiplier = Math.pow(10, this.precision);
    },

    number: function(val) {
        return Math.round(val * this.multiplier) / this.multiplier;
    },

    pair: function(val1, val2, separator) {
        return this.number(val1) + (separator || ',') + this.number(val2);
    },

    point: function(val, separator) {
        return this.number(val.x) + (separator || ',') + this.number(val.y);
    },

    size: function(val, separator) {
        return this.number(val.width) + (separator || ',')
                + this.number(val.height);
    },

    rectangle: function(val, separator) {
        return this.point(val, separator) + (separator || ',')
                + this.size(val, separator);
    }
});

Formatter.instance = new Formatter();

var Numerical = new function() {

    var abscissas = [
        [  0.5773502691896257645091488],
        [0,0.7745966692414833770358531],
        [  0.3399810435848562648026658,0.8611363115940525752239465],
        [0,0.5384693101056830910363144,0.9061798459386639927976269],
        [  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
        [0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
        [  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
        [0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
        [  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
        [0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
        [  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
        [0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
        [  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
        [0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
        [  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
    ];

    var weights = [
        [1],
        [0.8888888888888888888888889,0.5555555555555555555555556],
        [0.6521451548625461426269361,0.3478548451374538573730639],
        [0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
        [0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
        [0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
        [0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
        [0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
        [0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
        [0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
        [0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
        [0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
        [0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
        [0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
        [0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
    ];

    var abs = Math.abs,
        sqrt = Math.sqrt,
        pow = Math.pow,
        cos = Math.cos,
        PI = Math.PI,
        TOLERANCE = 10e-6,
        EPSILON = 10e-12;

    function setupRoots(roots, min, max) {
        var unbound = min === undefined,
            minE = min - EPSILON,
            maxE = max + EPSILON,
            count = 0;
        return function(root) {
            if (unbound || root > minE && root < maxE)
                roots[count++] = root < min ? min : root > max ? max : root;
            return count;
        };
    }

    return {
        TOLERANCE: TOLERANCE,
        EPSILON: EPSILON,
        KAPPA: 4 * (sqrt(2) - 1) / 3,

        isZero: function(val) {
            return abs(val) <= EPSILON;
        },

        integrate: function(f, a, b, n) {
            var x = abscissas[n - 2],
                w = weights[n - 2],
                A = (b - a) * 0.5,
                B = A + a,
                i = 0,
                m = (n + 1) >> 1,
                sum = n & 1 ? w[i++] * f(B) : 0; 
            while (i < m) {
                var Ax = A * x[i];
                sum += w[i++] * (f(B + Ax) + f(B - Ax));
            }
            return A * sum;
        },

        findRoot: function(f, df, x, a, b, n, tolerance) {
            for (var i = 0; i < n; i++) {
                var fx = f(x),
                    dx = fx / df(x),
                    nx = x - dx;
                if (abs(dx) < tolerance)
                    return nx;
                if (fx > 0) {
                    b = x;
                    x = nx <= a ? (a + b) * 0.5 : nx;
                } else {
                    a = x;
                    x = nx >= b ? (a + b) * 0.5 : nx;
                }
            }
            return x;
        },

        solveQuadratic: function(a, b, c, roots, min, max) {
            var add = setupRoots(roots, min, max);

            if (abs(a) < EPSILON) {
                if (abs(b) >= EPSILON)
                    return add(-c / b);
                return abs(c) < EPSILON ? -1 : 0; 
            }
            var p = b / (2 * a);
            var q = c / a;
            var p2 = p * p;
            if (p2 < q - EPSILON)
                return 0;
            var s = p2 > q ? sqrt(p2 - q) : 0,
                count = add(s - p);
            if (s > 0)
                count = add(-s - p);
            return count;
        },

        solveCubic: function(a, b, c, d, roots, min, max) {
            if (abs(a) < EPSILON)
                return Numerical.solveQuadratic(b, c, d, roots, min, max);

            b /= a;
            c /= a;
            d /= a;
            var add = setupRoots(roots, min, max),
                bb = b * b,
                p = (bb - 3 * c) / 9,
                q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
                ppp = p * p * p,
                D = q * q - ppp;
            b /= 3;
            if (abs(D) < EPSILON) {
                if (abs(q) < EPSILON) 
                    return add(-b);
                var sqp = sqrt(p),
                    snq = q > 0 ? 1 : -1;
                add(-snq * 2 * sqp - b);
                return add(snq * sqp - b);
            }
            if (D < 0) { 
                var sqp = sqrt(p),
                    phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
                    t = -2 * sqp,
                    o = 2 * PI / 3;
                add(t * cos(phi) - b);
                add(t * cos(phi + o) - b);
                return add(t * cos(phi - o) - b);
            }
            var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
            return add(A + p / A - b);
        }
    };
};

var Point = Base.extend({
    _class: 'Point',
    _readIndex: true,

    initialize: function Point(arg0, arg1) {
        var type = typeof arg0;
        if (type === 'number') {
            var hasY = typeof arg1 === 'number';
            this.x = arg0;
            this.y = hasY ? arg1 : arg0;
            if (this.__read)
                this.__read = hasY ? 2 : 1;
        } else if (type === 'undefined' || arg0 === null) {
            this.x = this.y = 0;
            if (this.__read)
                this.__read = arg0 === null ? 1 : 0;
        } else {
            if (Array.isArray(arg0)) {
                this.x = arg0[0];
                this.y = arg0.length > 1 ? arg0[1] : arg0[0];
            } else if (arg0.x != null) {
                this.x = arg0.x;
                this.y = arg0.y;
            } else if (arg0.width != null) {
                this.x = arg0.width;
                this.y = arg0.height;
            } else if (arg0.angle != null) {
                this.x = arg0.length;
                this.y = 0;
                this.setAngle(arg0.angle);
            } else {
                this.x = this.y = 0;
                if (this.__read)
                    this.__read = 0;
            }
            if (this.__read)
                this.__read = 1;
        }
    },

    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },

    equals: function(point) {
        return this === point || point
                && (this.x === point.x && this.y === point.y
                    || Array.isArray(point)
                        && this.x === point[0] && this.y === point[1])
                || false;
    },

    clone: function() {
        return new Point(this.x, this.y);
    },

    toString: function() {
        var f = Formatter.instance;
        return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
    },

    _serialize: function(options) {
        var f = options.formatter;
        return [f.number(this.x), f.number(this.y)];
    },

    getLength: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    setLength: function(length) {
        if (this.isZero()) {
            var angle = this._angle || 0;
            this.set(
                Math.cos(angle) * length,
                Math.sin(angle) * length
            );
        } else {
            var scale = length / this.getLength();
            if (Numerical.isZero(scale))
                this.getAngle();
            this.set(
                this.x * scale,
                this.y * scale
            );
        }
    },
    getAngle: function() {
        return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
    },

    setAngle: function(angle) {
        this.setAngleInRadians.call(this, angle * Math.PI / 180);
    },

    getAngleInDegrees: '#getAngle',
    setAngleInDegrees: '#setAngle',

    getAngleInRadians: function() {
        if (!arguments.length) {
            return this.isZero()
                    ? this._angle || 0
                    : this._angle = Math.atan2(this.y, this.x);
        } else {
            var point = Point.read(arguments),
                div = this.getLength() * point.getLength();
            if (Numerical.isZero(div)) {
                return NaN;
            } else {
                var a = this.dot(point) / div;
                return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
            }
        }
    },

    setAngleInRadians: function(angle) {
        this._angle = angle;
        if (!this.isZero()) {
            var length = this.getLength();
            this.set(
                Math.cos(angle) * length,
                Math.sin(angle) * length
            );
        }
    },

    getQuadrant: function() {
        return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
    }
}, {
    beans: false,

    getDirectedAngle: function() {
        var point = Point.read(arguments);
        return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
    },

    getDistance: function() {
        var point = Point.read(arguments),
            x = point.x - this.x,
            y = point.y - this.y,
            d = x * x + y * y,
            squared = Base.read(arguments);
        return squared ? d : Math.sqrt(d);
    },

    normalize: function(length) {
        if (length === undefined)
            length = 1;
        var current = this.getLength(),
            scale = current !== 0 ? length / current : 0,
            point = new Point(this.x * scale, this.y * scale);
        if (scale >= 0)
            point._angle = this._angle;
        return point;
    },

    rotate: function(angle, center) {
        if (angle === 0)
            return this.clone();
        angle = angle * Math.PI / 180;
        var point = center ? this.subtract(center) : this,
            s = Math.sin(angle),
            c = Math.cos(angle);
        point = new Point(
            point.x * c - point.y * s,
            point.x * s + point.y * c
        );
        return center ? point.add(center) : point;
    },

    transform: function(matrix) {
        return matrix ? matrix._transformPoint(this) : this;
    },

    add: function() {
        var point = Point.read(arguments);
        return new Point(this.x + point.x, this.y + point.y);
    },

    subtract: function() {
        var point = Point.read(arguments);
        return new Point(this.x - point.x, this.y - point.y);
    },

    multiply: function() {
        var point = Point.read(arguments);
        return new Point(this.x * point.x, this.y * point.y);
    },

    divide: function() {
        var point = Point.read(arguments);
        return new Point(this.x / point.x, this.y / point.y);
    },

    modulo: function() {
        var point = Point.read(arguments);
        return new Point(this.x % point.x, this.y % point.y);
    },

    negate: function() {
        return new Point(-this.x, -this.y);
    },

    isInside: function() {
        return Rectangle.read(arguments).contains(this);
    },

    isClose: function(point, tolerance) {
        return this.getDistance(point) < tolerance;
    },

    isColinear: function(point) {
        return Math.abs(this.cross(point)) < 0.00001;
    },

    isOrthogonal: function(point) {
        return Math.abs(this.dot(point)) < 0.00001;
    },

    isZero: function() {
        return Numerical.isZero(this.x) && Numerical.isZero(this.y);
    },

    isNaN: function() {
        return isNaN(this.x) || isNaN(this.y);
    },

    dot: function() {
        var point = Point.read(arguments);
        return this.x * point.x + this.y * point.y;
    },

    cross: function() {
        var point = Point.read(arguments);
        return this.x * point.y - this.y * point.x;
    },

    project: function() {
        var point = Point.read(arguments);
        if (point.isZero()) {
            return new Point(0, 0);
        } else {
            var scale = this.dot(point) / point.dot(point);
            return new Point(
                point.x * scale,
                point.y * scale
            );
        }
    },

    statics: {
        min: function() {
            var point1 = Point.read(arguments),
                point2 = Point.read(arguments);
            return new Point(
                Math.min(point1.x, point2.x),
                Math.min(point1.y, point2.y)
            );
        },

        max: function() {
            var point1 = Point.read(arguments),
                point2 = Point.read(arguments);
            return new Point(
                Math.max(point1.x, point2.x),
                Math.max(point1.y, point2.y)
            );
        },

        random: function() {
            return new Point(Math.random(), Math.random());
        }
    }
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
    var op = Math[name];
    this[name] = function() {
        return new Point(op(this.x), op(this.y));
    };
}, {}));

var LinkedPoint = Point.extend({
    initialize: function Point(x, y, owner, setter) {
        this._x = x;
        this._y = y;
        this._owner = owner;
        this._setter = setter;
    },

    set: function(x, y, _dontNotify) {
        this._x = x;
        this._y = y;
        if (!_dontNotify)
            this._owner[this._setter](this);
        return this;
    },

    getX: function() {
        return this._x;
    },

    setX: function(x) {
        this._x = x;
        this._owner[this._setter](this);
    },

    getY: function() {
        return this._y;
    },

    setY: function(y) {
        this._y = y;
        this._owner[this._setter](this);
    }
});

var Size = Base.extend({
    _class: 'Size',
    _readIndex: true,

    initialize: function Size(arg0, arg1) {
        var type = typeof arg0;
        if (type === 'number') {
            var hasHeight = typeof arg1 === 'number';
            this.width = arg0;
            this.height = hasHeight ? arg1 : arg0;
            if (this.__read)
                this.__read = hasHeight ? 2 : 1;
        } else if (type === 'undefined' || arg0 === null) {
            this.width = this.height = 0;
            if (this.__read)
                this.__read = arg0 === null ? 1 : 0;
        } else {
            if (Array.isArray(arg0)) {
                this.width = arg0[0];
                this.height = arg0.length > 1 ? arg0[1] : arg0[0];
            } else if (arg0.width != null) {
                this.width = arg0.width;
                this.height = arg0.height;
            } else if (arg0.x != null) {
                this.width = arg0.x;
                this.height = arg0.y;
            } else {
                this.width = this.height = 0;
                if (this.__read)
                    this.__read = 0;
            }
            if (this.__read)
                this.__read = 1;
        }
    },

    set: function(width, height) {
        this.width = width;
        this.height = height;
        return this;
    },

    equals: function(size) {
        return size === this || size && (this.width === size.width
                && this.height === size.height
                || Array.isArray(size) && this.width === size[0]
                    && this.height === size[1]) || false;
    },

    clone: function() {
        return new Size(this.width, this.height);
    },

    toString: function() {
        var f = Formatter.instance;
        return '{ width: ' + f.number(this.width)
                + ', height: ' + f.number(this.height) + ' }';
    },

    _serialize: function(options) {
        var f = options.formatter;
        return [f.number(this.width),
                f.number(this.height)];
    },

    add: function() {
        var size = Size.read(arguments);
        return new Size(this.width + size.width, this.height + size.height);
    },

    subtract: function() {
        var size = Size.read(arguments);
        return new Size(this.width - size.width, this.height - size.height);
    },

    multiply: function() {
        var size = Size.read(arguments);
        return new Size(this.width * size.width, this.height * size.height);
    },

    divide: function() {
        var size = Size.read(arguments);
        return new Size(this.width / size.width, this.height / size.height);
    },

    modulo: function() {
        var size = Size.read(arguments);
        return new Size(this.width % size.width, this.height % size.height);
    },

    negate: function() {
        return new Size(-this.width, -this.height);
    },

    isZero: function() {
        return Numerical.isZero(this.width) && Numerical.isZero(this.height);
    },

    isNaN: function() {
        return isNaN(this.width) || isNaN(this.height);
    },

    statics: {
        min: function(size1, size2) {
            return new Size(
                Math.min(size1.width, size2.width),
                Math.min(size1.height, size2.height));
        },

        max: function(size1, size2) {
            return new Size(
                Math.max(size1.width, size2.width),
                Math.max(size1.height, size2.height));
        },

        random: function() {
            return new Size(Math.random(), Math.random());
        }
    }
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
    var op = Math[name];
    this[name] = function() {
        return new Size(op(this.width), op(this.height));
    };
}, {}));

var LinkedSize = Size.extend({
    initialize: function Size(width, height, owner, setter) {
        this._width = width;
        this._height = height;
        this._owner = owner;
        this._setter = setter;
    },

    set: function(width, height, _dontNotify) {
        this._width = width;
        this._height = height;
        if (!_dontNotify)
            this._owner[this._setter](this);
        return this;
    },

    getWidth: function() {
        return this._width;
    },

    setWidth: function(width) {
        this._width = width;
        this._owner[this._setter](this);
    },

    getHeight: function() {
        return this._height;
    },

    setHeight: function(height) {
        this._height = height;
        this._owner[this._setter](this);
    }
});

var Rectangle = Base.extend({
    _class: 'Rectangle',
    _readIndex: true,
    beans: true,

    initialize: function Rectangle(arg0, arg1, arg2, arg3) {
        var type = typeof arg0,
            read = 0;
        if (type === 'number') {
            this.x = arg0;
            this.y = arg1;
            this.width = arg2;
            this.height = arg3;
            read = 4;
        } else if (type === 'undefined' || arg0 === null) {
            this.x = this.y = this.width = this.height = 0;
            read = arg0 === null ? 1 : 0;
        } else if (arguments.length === 1) {
            if (Array.isArray(arg0)) {
                this.x = arg0[0];
                this.y = arg0[1];
                this.width = arg0[2];
                this.height = arg0[3];
                read = 1;
            } else if (arg0.x !== undefined || arg0.width !== undefined) {
                this.x = arg0.x || 0;
                this.y = arg0.y || 0;
                this.width = arg0.width || 0;
                this.height = arg0.height || 0;
                read = 1;
            } else if (arg0.from === undefined && arg0.to === undefined) {
                this.x = this.y = this.width = this.height = 0;
                this._set(arg0);
                read = 1;
            }
        }
        if (!read) {
            var point = Point.readNamed(arguments, 'from'),
                next = Base.peek(arguments);
            this.x = point.x;
            this.y = point.y;
            if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
                var to = Point.readNamed(arguments, 'to');
                this.width = to.x - point.x;
                this.height = to.y - point.y;
                if (this.width < 0) {
                    this.x = to.x;
                    this.width = -this.width;
                }
                if (this.height < 0) {
                    this.y = to.y;
                    this.height = -this.height;
                }
            } else {
                var size = Size.read(arguments);
                this.width = size.width;
                this.height = size.height;
            }
            read = arguments.__index;
        }
        if (this.__read)
            this.__read = read;
    },

    set: function(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
    },

    clone: function() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    },

    equals: function(rect) {
        var rt = Base.isPlainValue(rect)
                ? Rectangle.read(arguments)
                : rect;
        return rt === this
                || rt && this.x === rt.x && this.y === rt.y
                    && this.width === rt.width && this.height === rt.height
                || false;
    },

    toString: function() {
        var f = Formatter.instance;
        return '{ x: ' + f.number(this.x)
                + ', y: ' + f.number(this.y)
                + ', width: ' + f.number(this.width)
                + ', height: ' + f.number(this.height)
                + ' }';
    },

    _serialize: function(options) {
        var f = options.formatter;
        return [f.number(this.x),
                f.number(this.y),
                f.number(this.width),
                f.number(this.height)];
    },

    getPoint: function(_dontLink) {
        var ctor = _dontLink ? Point : LinkedPoint;
        return new ctor(this.x, this.y, this, 'setPoint');
    },

    setPoint: function() {
        var point = Point.read(arguments);
        this.x = point.x;
        this.y = point.y;
    },

    getSize: function(_dontLink) {
        var ctor = _dontLink ? Size : LinkedSize;
        return new ctor(this.width, this.height, this, 'setSize');
    },

    setSize: function() {
        var size = Size.read(arguments);
        if (this._fixX)
            this.x += (this.width - size.width) * this._fixX;
        if (this._fixY)
            this.y += (this.height - size.height) * this._fixY;
        this.width = size.width;
        this.height = size.height;
        this._fixW = 1;
        this._fixH = 1;
    },

    getLeft: function() {
        return this.x;
    },

    setLeft: function(left) {
        if (!this._fixW)
            this.width -= left - this.x;
        this.x = left;
        this._fixX = 0;
    },

    getTop: function() {
        return this.y;
    },

    setTop: function(top) {
        if (!this._fixH)
            this.height -= top - this.y;
        this.y = top;
        this._fixY = 0;
    },

    getRight: function() {
        return this.x + this.width;
    },

    setRight: function(right) {
        if (this._fixX !== undefined && this._fixX !== 1)
            this._fixW = 0;
        if (this._fixW)
            this.x = right - this.width;
        else
            this.width = right - this.x;
        this._fixX = 1;
    },

    getBottom: function() {
        return this.y + this.height;
    },

    setBottom: function(bottom) {
        if (this._fixY !== undefined && this._fixY !== 1)
            this._fixH = 0;
        if (this._fixH)
            this.y = bottom - this.height;
        else
            this.height = bottom - this.y;
        this._fixY = 1;
    },

    getCenterX: function() {
        return this.x + this.width * 0.5;
    },

    setCenterX: function(x) {
        this.x = x - this.width * 0.5;
        this._fixX = 0.5;
    },

    getCenterY: function() {
        return this.y + this.height * 0.5;
    },

    setCenterY: function(y) {
        this.y = y - this.height * 0.5;
        this._fixY = 0.5;
    },

    getCenter: function(_dontLink) {
        var ctor = _dontLink ? Point : LinkedPoint;
        return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
    },

    setCenter: function() {
        var point = Point.read(arguments);
        this.setCenterX(point.x);
        this.setCenterY(point.y);
        return this;
    },

    getArea: function() {
        return this.width * this.height;
    },

    isEmpty: function() {
        return this.width === 0 || this.height === 0;
    },

    contains: function(arg) {
        return arg && arg.width !== undefined
                || (Array.isArray(arg) ? arg : arguments).length == 4
                ? this._containsRectangle(Rectangle.read(arguments))
                : this._containsPoint(Point.read(arguments));
    },

    _containsPoint: function(point) {
        var x = point.x,
            y = point.y;
        return x >= this.x && y >= this.y
                && x <= this.x + this.width
                && y <= this.y + this.height;
    },

    _containsRectangle: function(rect) {
        var x = rect.x,
            y = rect.y;
        return x >= this.x && y >= this.y
                && x + rect.width <= this.x + this.width
                && y + rect.height <= this.y + this.height;
    },

    intersects: function() {
        var rect = Rectangle.read(arguments);
        return rect.x + rect.width > this.x
                && rect.y + rect.height > this.y
                && rect.x < this.x + this.width
                && rect.y < this.y + this.height;
    },

    touches: function() {
        var rect = Rectangle.read(arguments);
        return rect.x + rect.width >= this.x
                && rect.y + rect.height >= this.y
                && rect.x <= this.x + this.width
                && rect.y <= this.y + this.height;
    },

    intersect: function() {
        var rect = Rectangle.read(arguments),
            x1 = Math.max(this.x, rect.x),
            y1 = Math.max(this.y, rect.y),
            x2 = Math.min(this.x + this.width, rect.x + rect.width),
            y2 = Math.min(this.y + this.height, rect.y + rect.height);
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },

    unite: function() {
        var rect = Rectangle.read(arguments),
            x1 = Math.min(this.x, rect.x),
            y1 = Math.min(this.y, rect.y),
            x2 = Math.max(this.x + this.width, rect.x + rect.width),
            y2 = Math.max(this.y + this.height, rect.y + rect.height);
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },

    include: function() {
        var point = Point.read(arguments);
        var x1 = Math.min(this.x, point.x),
            y1 = Math.min(this.y, point.y),
            x2 = Math.max(this.x + this.width, point.x),
            y2 = Math.max(this.y + this.height, point.y);
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },

    expand: function() {
        var amount = Size.read(arguments),
            hor = amount.width,
            ver = amount.height;
        return new Rectangle(this.x - hor / 2, this.y - ver / 2,
                this.width + hor, this.height + ver);
    },

    scale: function(hor, ver) {
        return this.expand(this.width * hor - this.width,
                this.height * (ver === undefined ? hor : ver) - this.height);
    }
}, Base.each([
        ['Top', 'Left'], ['Top', 'Right'],
        ['Bottom', 'Left'], ['Bottom', 'Right'],
        ['Left', 'Center'], ['Top', 'Center'],
        ['Right', 'Center'], ['Bottom', 'Center']
    ],
    function(parts, index) {
        var part = parts.join('');
        var xFirst = /^[RL]/.test(part);
        if (index >= 4)
            parts[1] += xFirst ? 'Y' : 'X';
        var x = parts[xFirst ? 0 : 1],
            y = parts[xFirst ? 1 : 0],
            getX = 'get' + x,
            getY = 'get' + y,
            setX = 'set' + x,
            setY = 'set' + y,
            get = 'get' + part,
            set = 'set' + part;
        this[get] = function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this[getX](), this[getY](), this, set);
        };
        this[set] = function() {
            var point = Point.read(arguments);
            this[setX](point.x);
            this[setY](point.y);
        };
    }, {
        beans: true
    }
));

var LinkedRectangle = Rectangle.extend({
    initialize: function Rectangle(x, y, width, height, owner, setter) {
        this.set(x, y, width, height, true);
        this._owner = owner;
        this._setter = setter;
    },

    set: function(x, y, width, height, _dontNotify) {
        this._x = x;
        this._y = y;
        this._width = width;
        this._height = height;
        if (!_dontNotify)
            this._owner[this._setter](this);
        return this;
    }
}, new function() {
    var proto = Rectangle.prototype;

    return Base.each(['x', 'y', 'width', 'height'], function(key) {
        var part = Base.capitalize(key);
        var internal = '_' + key;
        this['get' + part] = function() {
            return this[internal];
        };

        this['set' + part] = function(value) {
            this[internal] = value;
            if (!this._dontNotify)
                this._owner[this._setter](this);
        };
    }, Base.each(['Point', 'Size', 'Center',
            'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
            'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
            'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
        function(key) {
            var name = 'set' + key;
            this[name] = function() {
                this._dontNotify = true;
                proto[name].apply(this, arguments);
                this._dontNotify = false;
                this._owner[this._setter](this);
            };
        }, {
            isSelected: function() {
                return this._owner._boundsSelected;
            },

            setSelected: function(selected) {
                var owner = this._owner;
                if (owner.setSelected) {
                    owner._boundsSelected = selected;
                    owner.setSelected(selected || owner._selectedSegmentState > 0);
                }
            }
        })
    );
});

var Matrix = Base.extend({
    _class: 'Matrix',

    initialize: function Matrix(arg) {
        var count = arguments.length,
            ok = true;
        if (count === 6) {
            this.set.apply(this, arguments);
        } else if (count === 1) {
            if (arg instanceof Matrix) {
                this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
            } else if (Array.isArray(arg)) {
                this.set.apply(this, arg);
            } else {
                ok = false;
            }
        } else if (count === 0) {
            this.reset();
        } else {
            ok = false;
        }
        if (!ok)
            throw new Error('Unsupported matrix parameters');
    },

    set: function(a, c, b, d, tx, ty, _dontNotify) {
        this._a = a;
        this._c = c;
        this._b = b;
        this._d = d;
        this._tx = tx;
        this._ty = ty;
        if (!_dontNotify)
            this._changed();
        return this;
    },

    _serialize: function(options) {
        return Base.serialize(this.getValues(), options);
    },

    _changed: function() {
        var owner = this._owner;
        if (owner) {
            if (owner._applyMatrix) {
                owner.transform(null, true);
            } else {
                owner._changed(9);
            }
        }
    },

    clone: function() {
        return new Matrix(this._a, this._c, this._b, this._d,
                this._tx, this._ty);
    },

    equals: function(mx) {
        return mx === this || mx && this._a === mx._a && this._b === mx._b
                && this._c === mx._c && this._d === mx._d
                && this._tx === mx._tx && this._ty === mx._ty
                || false;
    },

    toString: function() {
        var f = Formatter.instance;
        return '[[' + [f.number(this._a), f.number(this._b),
                    f.number(this._tx)].join(', ') + '], ['
                + [f.number(this._c), f.number(this._d),
                    f.number(this._ty)].join(', ') + ']]';
    },

    reset: function(_dontNotify) {
        this._a = this._d = 1;
        this._c = this._b = this._tx = this._ty = 0;
        if (!_dontNotify)
            this._changed();
        return this;
    },

    apply: function() {
        var owner = this._owner;
        if (owner) {
            owner.transform(null, true);
            return this.isIdentity();
        }
        return false;
    },

    translate: function() {
        var point = Point.read(arguments),
            x = point.x,
            y = point.y;
        this._tx += x * this._a + y * this._b;
        this._ty += x * this._c + y * this._d;
        this._changed();
        return this;
    },

    scale: function() {
        var scale = Point.read(arguments),
            center = Point.read(arguments, 0, { readNull: true });
        if (center)
            this.translate(center);
        this._a *= scale.x;
        this._c *= scale.x;
        this._b *= scale.y;
        this._d *= scale.y;
        if (center)
            this.translate(center.negate());
        this._changed();
        return this;
    },

    rotate: function(angle ) {
        angle *= Math.PI / 180;
        var center = Point.read(arguments, 1),
            x = center.x,
            y = center.y,
            cos = Math.cos(angle),
            sin = Math.sin(angle),
            tx = x - x * cos + y * sin,
            ty = y - x * sin - y * cos,
            a = this._a,
            b = this._b,
            c = this._c,
            d = this._d;
        this._a = cos * a + sin * b;
        this._b = -sin * a + cos * b;
        this._c = cos * c + sin * d;
        this._d = -sin * c + cos * d;
        this._tx += tx * a + ty * b;
        this._ty += tx * c + ty * d;
        this._changed();
        return this;
    },

    shear: function() {
        var shear = Point.read(arguments),
            center = Point.read(arguments, 0, { readNull: true });
        if (center)
            this.translate(center);
        var a = this._a,
            c = this._c;
        this._a += shear.y * this._b;
        this._c += shear.y * this._d;
        this._b += shear.x * a;
        this._d += shear.x * c;
        if (center)
            this.translate(center.negate());
        this._changed();
        return this;
    },

    skew: function() {
        var skew = Point.read(arguments),
            center = Point.read(arguments, 0, { readNull: true }),
            toRadians = Math.PI / 180,
            shear = new Point(Math.tan(skew.x * toRadians),
                Math.tan(skew.y * toRadians));
        return this.shear(shear, center);
    },

    concatenate: function(mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            a2 = mx._a,
            b2 = mx._b,
            c2 = mx._c,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + c2 * b1;
        this._b = b2 * a1 + d2 * b1;
        this._c = a2 * c1 + c2 * d1;
        this._d = b2 * c1 + d2 * d1;
        this._tx += tx2 * a1 + ty2 * b1;
        this._ty += tx2 * c1 + ty2 * d1;
        this._changed();
        return this;
    },

    preConcatenate: function(mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._b,
            c2 = mx._c,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        this._a = a2 * a1 + b2 * c1;
        this._b = a2 * b1 + b2 * d1;
        this._c = c2 * a1 + d2 * c1;
        this._d = c2 * b1 + d2 * d1;
        this._tx = a2 * tx1 + b2 * ty1 + tx2;
        this._ty = c2 * tx1 + d2 * ty1 + ty2;
        this._changed();
        return this;
    },

    chain: function(mx) {
        var a1 = this._a,
            b1 = this._b,
            c1 = this._c,
            d1 = this._d,
            tx1 = this._tx,
            ty1 = this._ty,
            a2 = mx._a,
            b2 = mx._b,
            c2 = mx._c,
            d2 = mx._d,
            tx2 = mx._tx,
            ty2 = mx._ty;
        return new Matrix(
                a2 * a1 + c2 * b1,
                a2 * c1 + c2 * d1,
                b2 * a1 + d2 * b1,
                b2 * c1 + d2 * d1,
                tx1 + tx2 * a1 + ty2 * b1,
                ty1 + tx2 * c1 + ty2 * d1);
    },

    isIdentity: function() {
        return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
                && this._tx === 0 && this._ty === 0;
    },

    orNullIfIdentity: function() {
        return this.isIdentity() ? null : this;
    },

    isInvertible: function() {
        return !!this._getDeterminant();
    },

    isSingular: function() {
        return !this._getDeterminant();
    },

    transform: function( src, dst, count) {
        return arguments.length < 3
            ? this._transformPoint(Point.read(arguments))
            : this._transformCoordinates(src, dst, count);
    },

    _transformPoint: function(point, dest, _dontNotify) {
        var x = point.x,
            y = point.y;
        if (!dest)
            dest = new Point();
        return dest.set(
            x * this._a + y * this._b + this._tx,
            x * this._c + y * this._d + this._ty,
            _dontNotify
        );
    },

    _transformCoordinates: function(src, dst, count) {
        var i = 0,
            j = 0,
            max = 2 * count;
        while (i < max) {
            var x = src[i++],
                y = src[i++];
            dst[j++] = x * this._a + y * this._b + this._tx;
            dst[j++] = x * this._c + y * this._d + this._ty;
        }
        return dst;
    },

    _transformCorners: function(rect) {
        var x1 = rect.x,
            y1 = rect.y,
            x2 = x1 + rect.width,
            y2 = y1 + rect.height,
            coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
        return this._transformCoordinates(coords, coords, 4);
    },

    _transformBounds: function(bounds, dest, _dontNotify) {
        var coords = this._transformCorners(bounds),
            min = coords.slice(0, 2),
            max = coords.slice();
        for (var i = 2; i < 8; i++) {
            var val = coords[i],
                j = i & 1;
            if (val < min[j])
                min[j] = val;
            else if (val > max[j])
                max[j] = val;
        }
        if (!dest)
            dest = new Rectangle();
        return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
                _dontNotify);
    },

    inverseTransform: function() {
        return this._inverseTransform(Point.read(arguments));
    },

    _getDeterminant: function() {
        var det = this._a * this._d - this._b * this._c;
        return isFinite(det) && !Numerical.isZero(det)
                && isFinite(this._tx) && isFinite(this._ty)
                ? det : null;
    },

    _inverseTransform: function(point, dest, _dontNotify) {
        var det = this._getDeterminant();
        if (!det)
            return null;
        var x = point.x - this._tx,
            y = point.y - this._ty;
        if (!dest)
            dest = new Point();
        return dest.set(
            (x * this._d - y * this._b) / det,
            (y * this._a - x * this._c) / det,
            _dontNotify
        );
    },

    decompose: function() {
        var a = this._a, b = this._b, c = this._c, d = this._d;
        if (Numerical.isZero(a * d - b * c))
            return null;

        var scaleX = Math.sqrt(a * a + b * b);
        a /= scaleX;
        b /= scaleX;

        var shear = a * c + b * d;
        c -= a * shear;
        d -= b * shear;

        var scaleY = Math.sqrt(c * c + d * d);
        c /= scaleY;
        d /= scaleY;
        shear /= scaleY;

        if (a * d < b * c) {
            a = -a;
            b = -b;
            shear = -shear;
            scaleX = -scaleX;
        }

        return {
            scaling: new Point(scaleX, scaleY),
            rotation: -Math.atan2(b, a) * 180 / Math.PI,
            shearing: shear
        };
    },

    getValues: function() {
        return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
    },

    getTranslation: function() {
        return new Point(this._tx, this._ty);
    },

    getScaling: function() {
        return (this.decompose() || {}).scaling;
    },

    getRotation: function() {
        return (this.decompose() || {}).rotation;
    },

    inverted: function() {
        var det = this._getDeterminant();
        return det && new Matrix(
                this._d / det,
                -this._c / det,
                -this._b / det,
                this._a / det,
                (this._b * this._ty - this._d * this._tx) / det,
                (this._c * this._tx - this._a * this._ty) / det);
    },

    shiftless: function() {
        return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
    },

    applyToContext: function(ctx) {
        ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
    }
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
    var part = Base.capitalize(name),
        prop = '_' + name;
    this['get' + part] = function() {
        return this[prop];
    };
    this['set' + part] = function(value) {
        this[prop] = value;
        this._changed();
    };
}, {}));

var Line = Base.extend({
    _class: 'Line',

    initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
        var asVector = false;
        if (arguments.length >= 4) {
            this._px = arg0;
            this._py = arg1;
            this._vx = arg2;
            this._vy = arg3;
            asVector = arg4;
        } else {
            this._px = arg0.x;
            this._py = arg0.y;
            this._vx = arg1.x;
            this._vy = arg1.y;
            asVector = arg2;
        }
        if (!asVector) {
            this._vx -= this._px;
            this._vy -= this._py;
        }
    },

    getPoint: function() {
        return new Point(this._px, this._py);
    },

    getVector: function() {
        return new Point(this._vx, this._vy);
    },

    getLength: function() {
        return this.getVector().getLength();
    },

    intersect: function(line, isInfinite) {
        return Line.intersect(
                this._px, this._py, this._vx, this._vy,
                line._px, line._py, line._vx, line._vy,
                true, isInfinite);
    },

    getSide: function(point) {
        return Line.getSide(
                this._px, this._py, this._vx, this._vy,
                point.x, point.y, true);
    },

    getDistance: function(point) {
        return Math.abs(Line.getSignedDistance(
                this._px, this._py, this._vx, this._vy,
                point.x, point.y, true));
    },

    statics: {
        intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
                isInfinite) {
            if (!asVector) {
                avx -= apx;
                avy -= apy;
                bvx -= bpx;
                bvy -= bpy;
            }
            var cross = avx * bvy - avy * bvx;
            if (!Numerical.isZero(cross)) {
                var dx = apx - bpx,
                    dy = apy - bpy,
                    ta = (bvx * dy - bvy * dx) / cross,
                    tb = (avx * dy - avy * dx) / cross;
                if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
                    return new Point(
                                apx + ta * avx,
                                apy + ta * avy);
            }
        },

        getSide: function(px, py, vx, vy, x, y, asVector) {
            if (!asVector) {
                vx -= px;
                vy -= py;
            }
            var v2x = x - px,
                v2y = y - py,
                ccw = v2x * vy - v2y * vx; 
            if (ccw === 0) {
                ccw = v2x * vx + v2y * vy; 
                if (ccw > 0) {
                    v2x -= vx;
                    v2y -= vy;
                    ccw = v2x * vx + v2y * vy;
                    if (ccw < 0)
                        ccw = 0;
                }
            }
            return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
        },

        getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
            if (!asVector) {
                vx -= px;
                vy -= py;
            }
            if (Numerical.isZero(vx))
                return x - px;
            var m = vy / vx, 
                b = py - m * px; 
            return (y - (m * x) - b) / Math.sqrt(m * m + 1);
        }
    }
});

var Project = PaperScopeItem.extend({
    _class: 'Project',
    _list: 'projects',
    _reference: 'project',

    initialize: function Project(element) {
        PaperScopeItem.call(this, true);
        this.layers = [];
        this._activeLayer = null;
        this.symbols = [];
        this._currentStyle = new Style(null, null, this);
        this._view = View.create(this,
                element || CanvasProvider.getCanvas(1, 1));
        this._selectedItems = {};
        this._selectedItemCount = 0;
        this._updateVersion = 0;
    },

    _serialize: function(options, dictionary) {
        return Base.serialize(this.layers, options, true, dictionary);
    },

    clear: function() {
        for (var i = this.layers.length - 1; i >= 0; i--)
            this.layers[i].remove();
        this.symbols = [];
    },

    isEmpty: function() {
        return this.layers.length === 0;
    },

    remove: function remove() {
        if (!remove.base.call(this))
            return false;
        if (this._view)
            this._view.remove();
        return true;
    },

    getView: function() {
        return this._view;
    },

    getCurrentStyle: function() {
        return this._currentStyle;
    },

    setCurrentStyle: function(style) {
        this._currentStyle.initialize(style);
    },

    getIndex: function() {
        return this._index;
    },

    getOptions: function() {
        return this._scope.settings;
    },

    getActiveLayer: function() {
        return this._activeLayer || new Layer({ project: this });
    },

    getSelectedItems: function() {
        var items = [];
        for (var id in this._selectedItems) {
            var item = this._selectedItems[id];
            if (item.isInserted())
                items.push(item);
        }
        return items;
    },

    addChild: function(child) {
        if (child instanceof Layer) {
            Base.splice(this.layers, [child]);
            if (!this._activeLayer)
                this._activeLayer = child;
        } else if (child instanceof Item) {
            (this._activeLayer
                || this.addChild(new Layer(Item.NO_INSERT))).addChild(child);
        } else {
            child = null;
        }
        return child;
    },

    _updateSelection: function(item) {
        var id = item._id,
            selectedItems = this._selectedItems;
        if (item._selected) {
            if (selectedItems[id] !== item) {
                this._selectedItemCount++;
                selectedItems[id] = item;
            }
        } else if (selectedItems[id] === item) {
            this._selectedItemCount--;
            delete selectedItems[id];
        }
    },

    selectAll: function() {
        var layers = this.layers;
        for (var i = 0, l = layers.length; i < l; i++)
            layers[i].setFullySelected(true);
    },

    deselectAll: function() {
        var selectedItems = this._selectedItems;
        for (var i in selectedItems)
            selectedItems[i].setFullySelected(false);
    },

    hitTest: function() {
        var point = Point.read(arguments),
            options = HitResult.getOptions(Base.read(arguments));
        for (var i = this.layers.length - 1; i >= 0; i--) {
            var res = this.layers[i]._hitTest(point, options);
            if (res) return res;
        }
        return null;
    },

    getItems: function(match) {
        return Item._getItems(this.layers, match);
    },

    getItem: function(match) {
        return Item._getItems(this.layers, match, null, null, true)[0] || null;
    },

    importJSON: function(json) {
        this.activate();
        var layer = this._activeLayer;
        return Base.importJSON(json, layer && layer.isEmpty() && layer);
    },

    draw: function(ctx, matrix, pixelRatio) {
        this._updateVersion++;
        ctx.save();
        matrix.applyToContext(ctx);
        var param = new Base({
            offset: new Point(0, 0),
            pixelRatio: pixelRatio,
            viewMatrix: matrix.isIdentity() ? null : matrix,
            matrices: [new Matrix()], 
            updateMatrix: true
        });
        for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
            layers[i].draw(ctx, param);
        ctx.restore();

        if (this._selectedItemCount > 0) {
            ctx.save();
            ctx.strokeWidth = 1;
            var items = this._selectedItems,
                size = this._scope.settings.handleSize,
                version = this._updateVersion;
            for (var id in items)
                items[id]._drawSelection(ctx, matrix, size, items, version);
            ctx.restore();
        }
    }
});

var Symbol = Base.extend({
    _class: 'Symbol',

    initialize: function Symbol(item, dontCenter) {
        this._id = Symbol._id = (Symbol._id || 0) + 1;
        this.project = paper.project;
        this.project.symbols.push(this);
        if (item)
            this.setDefinition(item, dontCenter);
    },

    _serialize: function(options, dictionary) {
        return dictionary.add(this, function() {
            return Base.serialize([this._class, this._definition],
                    options, false, dictionary);
        });
    },

    _changed: function(flags) {
        if (flags & 8) {
            Item._clearBoundsCache(this);
        }
        if (flags & 1) {
            this.project._needsUpdate = true;
        }
    },

    getDefinition: function() {
        return this._definition;
    },

    setDefinition: function(item, _dontCenter) {
        if (item._parentSymbol)
            item = item.clone();
        if (this._definition)
            this._definition._parentSymbol = null;
        this._definition = item;
        item.remove();
        item.setSelected(false);
        if (!_dontCenter)
            item.setPosition(new Point());
        item._parentSymbol = this;
        this._changed(9);
    },

    place: function(position) {
        return new PlacedSymbol(this, position);
    },

    clone: function() {
        return new Symbol(this._definition.clone(false));
    }
});

var Item = Base.extend(Emitter, {
    statics: {
        extend: function extend(src) {
            if (src._serializeFields)
                src._serializeFields = new Base(
                        this.prototype._serializeFields, src._serializeFields);
            return extend.base.apply(this, arguments);
        },

        NO_INSERT: { insert: false }
    },

    _class: 'Item',
    _applyMatrix: true,
    _canApplyMatrix: true,
    _boundsSelected: false,
    _selectChildren: false,
    _serializeFields: {
        name: null,
        applyMatrix: null,
        matrix: new Matrix(),
        pivot: null,
        locked: false,
        visible: true,
        blendMode: 'normal',
        opacity: 1,
        guide: false,
        selected: false,
        clipMask: false,
        data: {}
    },

    initialize: function Item() {
    },

    _initialize: function(props, point) {
        var hasProps = props && Base.isPlainObject(props),
            internal = hasProps && props.internal === true,
            matrix = this._matrix = new Matrix(),
            project = hasProps && props.project || paper.project;
        if (!internal)
            this._id = Item._id = (Item._id || 0) + 1;
        this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
        if (point)
            matrix.translate(point);
        matrix._owner = this;
        this._style = new Style(project._currentStyle, this, project);
        if (!this._project) {
            if (internal || hasProps && props.insert === false) {
                this._setProject(project);
            } else if (hasProps && props.parent) {
                this.setParent(props.parent);
            } else {
                (project._activeLayer || new Layer()).addChild(this);
            }
        }
        if (hasProps && props !== Item.NO_INSERT)
            this._set(props, { insert: true, parent: true }, true);
        return hasProps;
    },

    _events: new function() {

        var mouseFlags = {
            mousedown: {
                mousedown: 1,
                mousedrag: 1,
                click: 1,
                doubleclick: 1
            },
            mouseup: {
                mouseup: 1,
                mousedrag: 1,
                click: 1,
                doubleclick: 1
            },
            mousemove: {
                mousedrag: 1,
                mousemove: 1,
                mouseenter: 1,
                mouseleave: 1
            }
        };

        var mouseEvent = {
            install: function(type) {
                var counters = this.getView()._eventCounters;
                if (counters) {
                    for (var key in mouseFlags) {
                        counters[key] = (counters[key] || 0)
                                + (mouseFlags[key][type] || 0);
                    }
                }
            },
            uninstall: function(type) {
                var counters = this.getView()._eventCounters;
                if (counters) {
                    for (var key in mouseFlags)
                        counters[key] -= mouseFlags[key][type] || 0;
                }
            }
        };

        return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
            'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
            function(name) {
                this[name] = mouseEvent;
            }, {
                onFrame: {
                    install: function() {
                        this._animateItem(true);
                    },
                    uninstall: function() {
                        this._animateItem(false);
                    }
                },

                onLoad: {}
            }
        );
    },

    _animateItem: function(animate) {
        this.getView()._animateItem(this, animate);
    },

    _serialize: function(options, dictionary) {
        var props = {},
            that = this;

        function serialize(fields) {
            for (var key in fields) {
                var value = that[key];
                if (!Base.equals(value, key === 'leading'
                        ? fields.fontSize * 1.2 : fields[key])) {
                    props[key] = Base.serialize(value, options,
                            key !== 'data', dictionary);
                }
            }
        }

        serialize(this._serializeFields);
        if (!(this instanceof Group))
            serialize(this._style._defaults);
        return [ this._class, props ];
    },

    _changed: function(flags) {
        var symbol = this._parentSymbol,
            cacheParent = this._parent || symbol,
            project = this._project;
        if (flags & 8) {
            this._bounds = this._position = this._decomposed =
                    this._globalMatrix = this._currentPath = undefined;
        }
        if (cacheParent
                && (flags & 40)) {
            Item._clearBoundsCache(cacheParent);
        }
        if (flags & 2) {
            Item._clearBoundsCache(this);
        }
        if (project) {
            if (flags & 1) {
                project._needsUpdate = true;
            }
            if (project._changes) {
                var entry = project._changesById[this._id];
                if (entry) {
                    entry.flags |= flags;
                } else {
                    entry = { item: this, flags: flags };
                    project._changesById[this._id] = entry;
                    project._changes.push(entry);
                }
            }
        }
        if (symbol)
            symbol._changed(flags);
    },

    set: function(props) {
        if (props)
            this._set(props);
        return this;
    },

    getId: function() {
        return this._id;
    },

    getName: function() {
        return this._name;
    },

    setName: function(name, unique) {

        if (this._name)
            this._removeNamed();
        if (name === (+name) + '')
            throw new Error(
                    'Names consisting only of numbers are not supported.');
        var parent = this._parent;
        if (name && parent) {
            var children = parent._children,
                namedChildren = parent._namedChildren,
                orig = name,
                i = 1;
            while (unique && children[name])
                name = orig + ' ' + (i++);
            (namedChildren[name] = namedChildren[name] || []).push(this);
            children[name] = this;
        }
        this._name = name || undefined;
        this._changed(128);
    },

    getStyle: function() {
        return this._style;
    },

    setStyle: function(style) {
        this.getStyle().set(style);
    }
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
    function(name) {
        var part = Base.capitalize(name),
            name = '_' + name;
        this['get' + part] = function() {
            return this[name];
        };
        this['set' + part] = function(value) {
            if (value != this[name]) {
                this[name] = value;
                this._changed(name === '_locked'
                        ? 128 : 129);
            }
        };
    },
{}), {
    beans: true,

    _locked: false,

    _visible: true,

    _blendMode: 'normal',

    _opacity: 1,

    _guide: false,

    isSelected: function() {
        if (this._selectChildren) {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++)
                if (children[i].isSelected())
                    return true;
        }
        return this._selected;
    },

    setSelected: function(selected, noChildren) {
        if (!noChildren && this._selectChildren) {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++)
                children[i].setSelected(selected);
        }
        if ((selected = !!selected) ^ this._selected) {
            this._selected = selected;
            this._project._updateSelection(this);
            this._changed(129);
        }
    },

    _selected: false,

    isFullySelected: function() {
        var children = this._children;
        if (children && this._selected) {
            for (var i = 0, l = children.length; i < l; i++)
                if (!children[i].isFullySelected())
                    return false;
            return true;
        }
        return this._selected;
    },

    setFullySelected: function(selected) {
        var children = this._children;
        if (children) {
            for (var i = 0, l = children.length; i < l; i++)
                children[i].setFullySelected(selected);
        }
        this.setSelected(selected, true);
    },

    isClipMask: function() {
        return this._clipMask;
    },

    setClipMask: function(clipMask) {
        if (this._clipMask != (clipMask = !!clipMask)) {
            this._clipMask = clipMask;
            if (clipMask) {
                this.setFillColor(null);
                this.setStrokeColor(null);
            }
            this._changed(129);
            if (this._parent)
                this._parent._changed(1024);
        }
    },

    _clipMask: false,

    getData: function() {
        if (!this._data)
            this._data = {};
        return this._data;
    },

    setData: function(data) {
        this._data = data;
    },

    getPosition: function(_dontLink) {
        var position = this._position,
            ctor = _dontLink ? Point : LinkedPoint;
        if (!position) {
            var pivot = this._pivot;
            position = this._position = pivot
                    ? this._matrix._transformPoint(pivot)
                    : this.getBounds().getCenter(true);
        }
        return new ctor(position.x, position.y, this, 'setPosition');
    },

    setPosition: function() {
        this.translate(Point.read(arguments).subtract(this.getPosition(true)));
    },

    getPivot: function(_dontLink) {
        var pivot = this._pivot;
        if (pivot) {
            var ctor = _dontLink ? Point : LinkedPoint;
            pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
        }
        return pivot;
    },

    setPivot: function() {
        this._pivot = Point.read(arguments);
        this._position = undefined;
    },

    _pivot: null,

    getRegistration: '#getPivot',
    setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
        'internalBounds', 'internalRoughBounds'],
    function(key) {
        var getter = 'get' + Base.capitalize(key),
            match = key.match(/^internal(.*)$/),
            internalGetter = match ? 'get' + match[1] : null;
        this[getter] = function(_matrix) {
            var boundsGetter = this._boundsGetter,
                name = !internalGetter && (typeof boundsGetter === 'string'
                        ? boundsGetter : boundsGetter && boundsGetter[getter])
                        || getter,
                bounds = this._getCachedBounds(name, _matrix, this,
                        internalGetter);
            return key === 'bounds'
                    ? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
                            bounds.height, this, 'setBounds')
                    : bounds;
        };
    },
{
    beans: true,

    _getBounds: function(getter, matrix, cacheItem) {
        var children = this._children;
        if (!children || children.length == 0)
            return new Rectangle();
        var x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            if (child._visible && !child.isEmpty()) {
                var rect = child._getCachedBounds(getter,
                        matrix && matrix.chain(child._matrix), cacheItem);
                x1 = Math.min(rect.x, x1);
                y1 = Math.min(rect.y, y1);
                x2 = Math.max(rect.x + rect.width, x2);
                y2 = Math.max(rect.y + rect.height, y2);
            }
        }
        return isFinite(x1)
                ? new Rectangle(x1, y1, x2 - x1, y2 - y1)
                : new Rectangle();
    },

    setBounds: function() {
        var rect = Rectangle.read(arguments),
            bounds = this.getBounds(),
            matrix = new Matrix(),
            center = rect.getCenter();
        matrix.translate(center);
        if (rect.width != bounds.width || rect.height != bounds.height) {
            matrix.scale(
                    bounds.width != 0 ? rect.width / bounds.width : 1,
                    bounds.height != 0 ? rect.height / bounds.height : 1);
        }
        center = bounds.getCenter();
        matrix.translate(-center.x, -center.y);
        this.transform(matrix);
    },

    _getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
        matrix = matrix && matrix.orNullIfIdentity();
        var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
            cache = (!matrix || matrix.equals(_matrix)) && getter;
        var cacheParent = this._parent || this._parentSymbol;
        if (cacheParent) {
            var id = cacheItem._id,
                ref = cacheParent._boundsCache = cacheParent._boundsCache || {
                    ids: {},
                    list: []
                };
            if (!ref.ids[id]) {
                ref.list.push(cacheItem);
                ref.ids[id] = cacheItem;
            }
        }
        if (cache && this._bounds && this._bounds[cache])
            return this._bounds[cache].clone();
        var bounds = this._getBounds(internalGetter || getter,
                matrix || _matrix, cacheItem);
        if (cache) {
            if (!this._bounds)
                this._bounds = {};
            var cached = this._bounds[cache] = bounds.clone();
            cached._internal = !!internalGetter;
        }
        return bounds;
    },

    statics: {
        _clearBoundsCache: function(item) {
            var cache = item._boundsCache;
            if (cache) {
                item._bounds = item._position = item._boundsCache = undefined;
                for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
                    var other = list[i];
                    if (other !== item) {
                        other._bounds = other._position = undefined;
                        if (other._boundsCache)
                            Item._clearBoundsCache(other);
                    }
                }
            }
        }
    }

}), {
    beans: true,

    _decompose: function() {
        return this._decomposed = this._matrix.decompose();
    },

    getRotation: function() {
        var decomposed = this._decomposed || this._decompose();
        return decomposed && decomposed.rotation;
    },

    setRotation: function(rotation) {
        var current = this.getRotation();
        if (current != null && rotation != null) {
            var decomposed = this._decomposed;
            this.rotate(rotation - current);
            decomposed.rotation = rotation;
            this._decomposed = decomposed;
        }
    },

    getScaling: function(_dontLink) {
        var decomposed = this._decomposed || this._decompose(),
            scaling = decomposed && decomposed.scaling,
            ctor = _dontLink ? Point : LinkedPoint;
        return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
    },

    setScaling: function() {
        var current = this.getScaling();
        if (current) {
            var scaling = Point.read(arguments, 0, { clone: true }),
                decomposed = this._decomposed;
            this.scale(scaling.x / current.x, scaling.y / current.y);
            decomposed.scaling = scaling;
            this._decomposed = decomposed;
        }
    },

    getMatrix: function() {
        return this._matrix;
    },

    setMatrix: function(matrix) {
        this._matrix.initialize(matrix);
        if (this._applyMatrix) {
            this.transform(null, true);
        } else {
            this._changed(9);
        }
    },

    getGlobalMatrix: function(_dontClone) {
        var matrix = this._globalMatrix,
            updateVersion = this._project._updateVersion;
        if (matrix && matrix._updateVersion !== updateVersion)
            matrix = null;
        if (!matrix) {
            matrix = this._globalMatrix = this._matrix.clone();
            var parent = this._parent;
            if (parent)
                matrix.preConcatenate(parent.getGlobalMatrix(true));
            matrix._updateVersion = updateVersion;
        }
        return _dontClone ? matrix : matrix.clone();
    },

    getApplyMatrix: function() {
        return this._applyMatrix;
    },

    setApplyMatrix: function(transform) {
        if (this._applyMatrix = this._canApplyMatrix && !!transform)
            this.transform(null, true);
    },

    getTransformContent: '#getApplyMatrix',
    setTransformContent: '#setApplyMatrix',
}, {
    getProject: function() {
        return this._project;
    },

    _setProject: function(project, installEvents) {
        if (this._project !== project) {
            if (this._project)
                this._installEvents(false);
            this._project = project;
            var children = this._children;
            for (var i = 0, l = children && children.length; i < l; i++)
                children[i]._setProject(project);
            installEvents = true;
        }
        if (installEvents)
            this._installEvents(true);
    },

    getView: function() {
        return this._project.getView();
    },

    _installEvents: function _installEvents(install) {
        _installEvents.base.call(this, install);
        var children = this._children;
        for (var i = 0, l = children && children.length; i < l; i++)
            children[i]._installEvents(install);
    },

    getLayer: function() {
        var parent = this;
        while (parent = parent._parent) {
            if (parent instanceof Layer)
                return parent;
        }
        return null;
    },

    getParent: function() {
        return this._parent;
    },

    setParent: function(item) {
        return item.addChild(this);
    },

    getChildren: function() {
        return this._children;
    },

    setChildren: function(items) {
        this.removeChildren();
        this.addChildren(items);
    },

    getFirstChild: function() {
        return this._children && this._children[0] || null;
    },

    getLastChild: function() {
        return this._children && this._children[this._children.length - 1]
                || null;
    },

    getNextSibling: function() {
        return this._parent && this._parent._children[this._index + 1] || null;
    },

    getPreviousSibling: function() {
        return this._parent && this._parent._children[this._index - 1] || null;
    },

    getIndex: function() {
        return this._index;
    },

    equals: function(item) {
        return item === this || item && this._class === item._class
                && this._style.equals(item._style)
                && this._matrix.equals(item._matrix)
                && this._locked === item._locked
                && this._visible === item._visible
                && this._blendMode === item._blendMode
                && this._opacity === item._opacity
                && this._clipMask === item._clipMask
                && this._guide === item._guide
                && this._equals(item)
                || false;
    },

    _equals: function(item) {
        return Base.equals(this._children, item._children);
    },

    clone: function(insert) {
        return this._clone(new this.constructor(Item.NO_INSERT), insert);
    },

    _clone: function(copy, insert) {
        copy.setStyle(this._style);
        if (this._children) {
            for (var i = 0, l = this._children.length; i < l; i++)
                copy.addChild(this._children[i].clone(false), true);
        }
        if (insert || insert === undefined)
            copy.insertAbove(this);
        var keys = ['_locked', '_visible', '_blendMode', '_opacity',
                '_clipMask', '_guide', '_applyMatrix'];
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            if (this.hasOwnProperty(key))
                copy[key] = this[key];
        }
        copy._matrix.initialize(this._matrix);
        copy._data = this._data ? Base.clone(this._data) : null;
        copy.setSelected(this._selected);
        if (this._name)
            copy.setName(this._name, true);
        return copy;
    },

    copyTo: function(itemOrProject) {
        return itemOrProject.addChild(this.clone(false));
    },

    rasterize: function(resolution) {
        var bounds = this.getStrokeBounds(),
            scale = (resolution || this.getView().getResolution()) / 72,
            topLeft = bounds.getTopLeft().floor(),
            bottomRight = bounds.getBottomRight().ceil(),
            size = new Size(bottomRight.subtract(topLeft)),
            canvas = CanvasProvider.getCanvas(size.multiply(scale)),
            ctx = canvas.getContext('2d'),
            matrix = new Matrix().scale(scale).translate(topLeft.negate());
        ctx.save();
        matrix.applyToContext(ctx);
        this.draw(ctx, new Base({ matrices: [matrix] }));
        ctx.restore();
        var raster = new Raster(Item.NO_INSERT);
        raster.setCanvas(canvas);
        raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
                .scale(1 / scale));
        raster.insertAbove(this);
        return raster;
    },

    contains: function() {
        return !!this._contains(
                this._matrix._inverseTransform(Point.read(arguments)));
    },

    _contains: function(point) {
        if (this._children) {
            for (var i = this._children.length - 1; i >= 0; i--) {
                if (this._children[i].contains(point))
                    return true;
            }
            return false;
        }
        return point.isInside(this.getInternalBounds());
    },

    isInside: function() {
        return Rectangle.read(arguments).contains(this.getBounds());
    },

    _asPathItem: function() {
        return new Path.Rectangle({
            rectangle: this.getInternalBounds(),
            matrix: this._matrix,
            insert: false,
        });
    },

    intersects: function(item, _matrix) {
        if (!(item instanceof Item))
            return false;
        return this._asPathItem().getIntersections(item._asPathItem(),
                _matrix || item._matrix).length > 0;
    },

    hitTest: function() {
        return this._hitTest(
                Point.read(arguments),
                HitResult.getOptions(Base.read(arguments)));
    },

    _hitTest: function(point, options) {
        if (this._locked || !this._visible || this._guide && !options.guides
                || this.isEmpty())
            return null;

        var matrix = this._matrix,
            parentTotalMatrix = options._totalMatrix,
            view = this.getView(),
            totalMatrix = options._totalMatrix = parentTotalMatrix
                    ? parentTotalMatrix.chain(matrix)
                    : this.getGlobalMatrix().preConcatenate(view._matrix),
            tolerancePadding = options._tolerancePadding = new Size(
                        Path._getPenPadding(1, totalMatrix.inverted())
                    ).multiply(
                        Math.max(options.tolerance, 0.00001)
                    );
        point = matrix._inverseTransform(point);

        if (!this._children && !this.getInternalRoughBounds()
                .expand(tolerancePadding.multiply(2))._containsPoint(point))
            return null;
        var checkSelf = !(options.guides && !this._guide
                || options.selected && !this._selected
                || options.type && options.type !== Base.hyphenate(this._class)
                || options.class && !(this instanceof options.class)),
            that = this,
            res;

        function checkBounds(type, part) {
            var pt = bounds['get' + part]();
            if (point.subtract(pt).divide(tolerancePadding).length <= 1)
                return new HitResult(type, that,
                        { name: Base.hyphenate(part), point: pt });
        }

        if (checkSelf && (options.center || options.bounds) && this._parent) {
            var bounds = this.getInternalBounds();
            if (options.center)
                res = checkBounds('center', 'Center');
            if (!res && options.bounds) {
                var points = [
                    'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
                    'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
                ];
                for (var i = 0; i < 8 && !res; i++)
                    res = checkBounds('bounds', points[i]);
            }
        }

        var children = !res && this._children;
        if (children) {
            var opts = this._getChildHitTestOptions(options);
            for (var i = children.length - 1; i >= 0 && !res; i--)
                res = children[i]._hitTest(point, opts);
        }
        if (!res && checkSelf)
            res = this._hitTestSelf(point, options);
        if (res && res.point)
            res.point = matrix.transform(res.point);
        options._totalMatrix = parentTotalMatrix;
        return res;
    },

    _getChildHitTestOptions: function(options) {
        return options;
    },

    _hitTestSelf: function(point, options) {
        if (options.fill && this.hasFill() && this._contains(point))
            return new HitResult('fill', this);
    },

    matches: function(name, compare) {
        function matchObject(obj1, obj2) {
            for (var i in obj1) {
                if (obj1.hasOwnProperty(i)) {
                    var val1 = obj1[i],
                        val2 = obj2[i];
                    if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                        if (!matchObject(val1, val2))
                            return false;
                    } else if (!Base.equals(val1, val2)) {
                        return false;
                    }
                }
            }
            return true;
        }
        if (typeof name === 'object') {
            for (var key in name) {
                if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
                    return false;
            }
        } else {
            var value = /^(empty|editable)$/.test(name)
                    ? this['is' + Base.capitalize(name)]()
                    : name === 'type'
                        ? Base.hyphenate(this._class)
                        : this[name];
            if (/^(constructor|class)$/.test(name)) {
                if (!(this instanceof compare))
                    return false;
            } else if (compare instanceof RegExp) {
                if (!compare.test(value))
                    return false;
            } else if (typeof compare === 'function') {
                if (!compare(value))
                    return false;
            } else if (Base.isPlainObject(compare)) {
                if (!matchObject(compare, value))
                    return false;
            } else if (!Base.equals(value, compare)) {
                return false;
            }
        }
        return true;
    },

    getItems: function(match) {
        return Item._getItems(this._children, match, this._matrix);
    },

    getItem: function(match) {
        return Item._getItems(this._children, match, this._matrix, null, true)
                [0] || null;
    },

    statics: {
        _getItems: function _getItems(children, match, matrix, param,
                firstOnly) {
            if (!param) {
                var overlapping = match.overlapping,
                    inside = match.inside,
                    bounds = overlapping || inside,
                    rect =  bounds && Rectangle.read([bounds]);
                param = {
                    items: [], 
                    inside: rect,
                    overlapping: overlapping && new Path.Rectangle({
                        rectangle: rect,
                        insert: false
                    })
                };
                if (bounds)
                    match = Base.set({}, match,
                            { inside: true, overlapping: true });
            }
            var items = param.items,
                inside = param.inside,
                overlapping = param.overlapping;
            matrix = inside && (matrix || new Matrix());
            for (var i = 0, l = children && children.length; i < l; i++) {
                var child = children[i],
                    childMatrix = matrix && matrix.chain(child._matrix),
                    add = true;
                if (inside) {
                    var bounds = child.getBounds(childMatrix);
                    if (!inside.intersects(bounds))
                        continue;
                    if (!(inside && inside.contains(bounds)) && !(overlapping
                            && overlapping.intersects(child, childMatrix)))
                        add = false;
                }
                if (add && child.matches(match)) {
                    items.push(child);
                    if (firstOnly)
                        break;
                }
                _getItems(child._children, match,
                        childMatrix, param,
                        firstOnly);
                if (firstOnly && items.length > 0)
                    break;
            }
            return items;
        }
    }
}, {

    importJSON: function(json) {
        var res = Base.importJSON(json, this);
        return res !== this
                ? this.addChild(res)
                : res;
    },

    addChild: function(item, _preserve) {
        return this.insertChild(undefined, item, _preserve);
    },

    insertChild: function(index, item, _preserve) {
        var res = this.insertChildren(index, [item], _preserve);
        return res && res[0];
    },

    addChildren: function(items, _preserve) {
        return this.insertChildren(this._children.length, items, _preserve);
    },

    insertChildren: function(index, items, _preserve, _proto) {
        var children = this._children;
        if (children && items && items.length > 0) {
            items = Array.prototype.slice.apply(items);
            for (var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                if (_proto && !(item instanceof _proto)) {
                    items.splice(i, 1);
                } else {
                    item._remove(false, true);
                }
            }
            Base.splice(children, items, index, 0);
            var project = this._project,
                notifySelf = project && project._changes;
            for (var i = 0, l = items.length; i < l; i++) {
                var item = items[i];
                item._parent = this;
                item._setProject(this._project, true);
                if (item._name)
                    item.setName(item._name);
                if (notifySelf)
                    this._changed(5);
            }
            this._changed(11);
        } else {
            items = null;
        }
        return items;
    },

    _insert: function(above, item, _preserve) {
        if (!item._parent)
            return null;
        var index = item._index + (above ? 1 : 0);
        if (item._parent === this._parent && index > this._index)
            index--;
        return item._parent.insertChild(index, this, _preserve);
    },

    insertAbove: function(item, _preserve) {
        return this._insert(true, item, _preserve);
    },

    insertBelow: function(item, _preserve) {
        return this._insert(false, item, _preserve);
    },

    sendToBack: function() {
        return this._parent.insertChild(0, this);
    },

    bringToFront: function() {
        return this._parent.addChild(this);
    },

    appendTop: '#addChild',

    appendBottom: function(item) {
        return this.insertChild(0, item);
    },

    moveAbove: '#insertAbove',

    moveBelow: '#insertBelow',

    reduce: function() {
        if (this._children && this._children.length === 1) {
            var child = this._children[0].reduce();
            child.insertAbove(this);
            child.setStyle(this._style);
            this.remove();
            return child;
        }
        return this;
    },

    _removeNamed: function() {
        var parent = this._parent;
        if (parent) {
            var children = parent._children,
                namedChildren = parent._namedChildren,
                name = this._name,
                namedArray = namedChildren[name],
                index = namedArray ? namedArray.indexOf(this) : -1;
            if (index !== -1) {
                if (children[name] == this)
                    delete children[name];
                namedArray.splice(index, 1);
                if (namedArray.length) {
                    children[name] = namedArray[namedArray.length - 1];
                } else {
                    delete namedChildren[name];
                }
            }
        }
    },

    _remove: function(notifySelf, notifyParent) {
        var parent = this._parent;
        if (parent) {
            if (this._name)
                this._removeNamed();
            if (this._index != null)
                Base.splice(parent._children, null, this._index, 1);
            this._installEvents(false);
            if (notifySelf) {
                var project = this._project;
                if (project && project._changes)
                    this._changed(5);
            }
            if (notifyParent)
                parent._changed(11);
            this._parent = null;
            return true;
        }
        return false;
    },

    remove: function() {
        return this._remove(true, true);
    },

    replaceWith: function(item) {
        var ok = item && item.insertBelow(this);
        if (ok)
            this.remove();
        return ok;
    },

    removeChildren: function(from, to) {
        if (!this._children)
            return null;
        from = from || 0;
        to = Base.pick(to, this._children.length);
        var removed = Base.splice(this._children, null, from, to - from);
        for (var i = removed.length - 1; i >= 0; i--) {
            removed[i]._remove(true, false);
        }
        if (removed.length > 0)
            this._changed(11);
        return removed;
    },

    clear: '#removeChildren',

    reverseChildren: function() {
        if (this._children) {
            this._children.reverse();
            for (var i = 0, l = this._children.length; i < l; i++)
                this._children[i]._index = i;
            this._changed(11);
        }
    },

    isEmpty: function() {
        return !this._children || this._children.length === 0;
    },

    isEditable: function() {
        var item = this;
        while (item) {
            if (!item._visible || item._locked)
                return false;
            item = item._parent;
        }
        return true;
    },

    hasFill: function() {
        return this.getStyle().hasFill();
    },

    hasStroke: function() {
        return this.getStyle().hasStroke();
    },

    hasShadow: function() {
        return this.getStyle().hasShadow();
    },

    _getOrder: function(item) {
        function getList(item) {
            var list = [];
            do {
                list.unshift(item);
            } while (item = item._parent);
            return list;
        }
        var list1 = getList(this),
            list2 = getList(item);
        for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
            if (list1[i] != list2[i]) {
                return list1[i]._index < list2[i]._index ? 1 : -1;
            }
        }
        return 0;
    },

    hasChildren: function() {
        return this._children && this._children.length > 0;
    },

    isInserted: function() {
        return this._parent ? this._parent.isInserted() : false;
    },

    isAbove: function(item) {
        return this._getOrder(item) === -1;
    },

    isBelow: function(item) {
        return this._getOrder(item) === 1;
    },

    isParent: function(item) {
        return this._parent === item;
    },

    isChild: function(item) {
        return item && item._parent === this;
    },

    isDescendant: function(item) {
        var parent = this;
        while (parent = parent._parent) {
            if (parent == item)
                return true;
        }
        return false;
    },

    isAncestor: function(item) {
        return item ? item.isDescendant(this) : false;
    },

    isGroupedWith: function(item) {
        var parent = this._parent;
        while (parent) {
            if (parent._parent
                && /^(Group|Layer|CompoundPath)$/.test(parent._class)
                && item.isDescendant(parent))
                    return true;
            parent = parent._parent;
        }
        return false;
    },

    translate: function() {
        var mx = new Matrix();
        return this.transform(mx.translate.apply(mx, arguments));
    },

    rotate: function(angle ) {
        return this.transform(new Matrix().rotate(angle,
                Point.read(arguments, 1, { readNull: true })
                    || this.getPosition(true)));
    }
}, Base.each(['scale', 'shear', 'skew'], function(name) {
    this[name] = function() {
        var point = Point.read(arguments),
            center = Point.read(arguments, 0, { readNull: true });
        return this.transform(new Matrix()[name](point,
                center || this.getPosition(true)));
    };
}, {

}), {
    transform: function(matrix, _applyMatrix) {
        if (matrix && matrix.isIdentity())
            matrix = null;
        var _matrix = this._matrix,
            applyMatrix = (_applyMatrix || this._applyMatrix)
                && (!_matrix.isIdentity() || matrix);
        if (!matrix && !applyMatrix)
            return this;
        if (matrix)
            _matrix.preConcatenate(matrix);
        if (applyMatrix = applyMatrix && this._transformContent(_matrix)) {
            var pivot = this._pivot,
                style = this._style,
                fillColor = style.getFillColor(true),
                strokeColor = style.getStrokeColor(true);
            if (pivot)
                _matrix._transformPoint(pivot, pivot, true);
            if (fillColor)
                fillColor.transform(_matrix);
            if (strokeColor)
                strokeColor.transform(_matrix);
            _matrix.reset(true);
        }
        var bounds = this._bounds,
            position = this._position;
        this._changed(9);
        var decomp = bounds && matrix && matrix.decompose();
        if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
            for (var key in bounds) {
                var rect = bounds[key];
                if (applyMatrix || !rect._internal)
                    matrix._transformBounds(rect, rect);
            }
            var getter = this._boundsGetter,
                rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
            if (rect)
                this._position = rect.getCenter(true);
            this._bounds = bounds;
        } else if (matrix && position) {
            this._position = matrix._transformPoint(position, position);
        }
        return this;
    },

    _transformContent: function(matrix) {
        var children = this._children;
        if (children) {
            for (var i = 0, l = children.length; i < l; i++)
                children[i].transform(matrix, true);
            return true;
        }
    },

    globalToLocal: function() {
        return this.getGlobalMatrix(true)._inverseTransform(
                Point.read(arguments));
    },

    localToGlobal: function() {
        return this.getGlobalMatrix(true)._transformPoint(
                Point.read(arguments));
    },

    parentToLocal: function() {
        return this._matrix._inverseTransform(Point.read(arguments));
    },

    localToParent: function() {
        return this._matrix._transformPoint(Point.read(arguments));
    },

    fitBounds: function(rectangle, fill) {
        rectangle = Rectangle.read(arguments);
        var bounds = this.getBounds(),
            itemRatio = bounds.height / bounds.width,
            rectRatio = rectangle.height / rectangle.width,
            scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
                    ? rectangle.width / bounds.width
                    : rectangle.height / bounds.height,
            newBounds = new Rectangle(new Point(),
                    new Size(bounds.width * scale, bounds.height * scale));
        newBounds.setCenter(rectangle.getCenter());
        this.setBounds(newBounds);
    },

    _setStyles: function(ctx) {
        var style = this._style,
            fillColor = style.getFillColor(),
            strokeColor = style.getStrokeColor(),
            shadowColor = style.getShadowColor();
        if (fillColor)
            ctx.fillStyle = fillColor.toCanvasStyle(ctx);
        if (strokeColor) {
            var strokeWidth = style.getStrokeWidth();
            if (strokeWidth > 0) {
                ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
                ctx.lineWidth = strokeWidth;
                var strokeJoin = style.getStrokeJoin(),
                    strokeCap = style.getStrokeCap(),
                    miterLimit = style.getMiterLimit();
                if (strokeJoin)
                    ctx.lineJoin = strokeJoin;
                if (strokeCap)
                    ctx.lineCap = strokeCap;
                if (miterLimit)
                    ctx.miterLimit = miterLimit;
                if (paper.support.nativeDash) {
                    var dashArray = style.getDashArray(),
                        dashOffset = style.getDashOffset();
                    if (dashArray && dashArray.length) {
                        if ('setLineDash' in ctx) {
                            ctx.setLineDash(dashArray);
                            ctx.lineDashOffset = dashOffset;
                        } else {
                            ctx.mozDash = dashArray;
                            ctx.mozDashOffset = dashOffset;
                        }
                    }
                }
            }
        }
        if (shadowColor) {
            var shadowBlur = style.getShadowBlur();
            if (shadowBlur > 0) {
                ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
                ctx.shadowBlur = shadowBlur;
                var offset = this.getShadowOffset();
                ctx.shadowOffsetX = offset.x;
                ctx.shadowOffsetY = offset.y;
            }
        }
    },

    draw: function(ctx, param, parentStrokeMatrix) {
        var updateVersion = this._updateVersion = this._project._updateVersion;
        if (!this._visible || this._opacity === 0)
            return;
        var matrices = param.matrices,
            viewMatrix = param.viewMatrix,
            matrix = this._matrix,
            globalMatrix = matrices[matrices.length - 1].chain(matrix);
        if (!globalMatrix.isInvertible())
            return;

        function getViewMatrix(matrix) {
            return viewMatrix ? viewMatrix.chain(matrix) : matrix;
        }

        matrices.push(globalMatrix);
        if (param.updateMatrix) {
            globalMatrix._updateVersion = updateVersion;
            this._globalMatrix = globalMatrix;
        }

        var blendMode = this._blendMode,
            opacity = this._opacity,
            normalBlend = blendMode === 'normal',
            nativeBlend = BlendMode.nativeModes[blendMode],
            direct = normalBlend && opacity === 1
                    || param.dontStart 
                    || param.clip
                    || (nativeBlend || normalBlend && opacity < 1)
                        && this._canComposite(),
            pixelRatio = param.pixelRatio,
            mainCtx, itemOffset, prevOffset;
        if (!direct) {
            var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
            if (!bounds.width || !bounds.height)
                return;
            prevOffset = param.offset;
            itemOffset = param.offset = bounds.getTopLeft().floor();
            mainCtx = ctx;
            ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
                    .multiply(pixelRatio));
            if (pixelRatio !== 1)
                ctx.scale(pixelRatio, pixelRatio);
        }
        ctx.save();
        var strokeMatrix = parentStrokeMatrix
                ? parentStrokeMatrix.chain(matrix)
                : !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
            clip = !direct && param.clipItem,
            transform = !strokeMatrix || clip;
        if (direct) {
            ctx.globalAlpha = opacity;
            if (nativeBlend)
                ctx.globalCompositeOperation = blendMode;
        } else if (transform) {
            ctx.translate(-itemOffset.x, -itemOffset.y);
        }
        if (transform)
            (direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
        if (clip)
            param.clipItem.draw(ctx, param.extend({ clip: true }));
        if (strokeMatrix) {
            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            var offset = param.offset;
            if (offset)
                ctx.translate(-offset.x, -offset.y);
        }
        this._draw(ctx, param, strokeMatrix);
        ctx.restore();
        matrices.pop();
        if (param.clip && !param.dontFinish)
            ctx.clip();
        if (!direct) {
            BlendMode.process(blendMode, ctx, mainCtx, opacity,
                    itemOffset.subtract(prevOffset).multiply(pixelRatio));
            CanvasProvider.release(ctx);
            param.offset = prevOffset;
        }
    },

    _isUpdated: function(updateVersion) {
        var parent = this._parent;
        if (parent instanceof CompoundPath)
            return parent._isUpdated(updateVersion);
        var updated = this._updateVersion === updateVersion;
        if (!updated && parent && parent._visible
                && parent._isUpdated(updateVersion)) {
            this._updateVersion = updateVersion;
            updated = true;
        }
        return updated;
    },

    _drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
        if ((this._drawSelected || this._boundsSelected)
                && this._isUpdated(updateVersion)) {
            var color = this.getSelectedColor(true)
                    || this.getLayer().getSelectedColor(true),
                mx = matrix.chain(this.getGlobalMatrix(true));
            ctx.strokeStyle = ctx.fillStyle = color
                    ? color.toCanvasStyle(ctx) : '#009dec';
            if (this._drawSelected)
                this._drawSelected(ctx, mx, selectedItems);
            if (this._boundsSelected) {
                var half = size / 2;
                    coords = mx._transformCorners(this.getInternalBounds());
                ctx.beginPath();
                for (var i = 0; i < 8; i++)
                    ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
                ctx.closePath();
                ctx.stroke();
                for (var i = 0; i < 8; i++)
                    ctx.fillRect(coords[i] - half, coords[++i] - half,
                            size, size);
            }
        }
    },

    _canComposite: function() {
        return false;
    }
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
    this['removeOn' + Base.capitalize(name)] = function() {
        var hash = {};
        hash[name] = true;
        return this.removeOn(hash);
    };
}, {

    removeOn: function(obj) {
        for (var name in obj) {
            if (obj[name]) {
                var key = 'mouse' + name,
                    project = this._project,
                    sets = project._removeSets = project._removeSets || {};
                sets[key] = sets[key] || {};
                sets[key][this._id] = this;
            }
        }
        return this;
    }
}));

var Group = Item.extend({
    _class: 'Group',
    _selectChildren: true,
    _serializeFields: {
        children: []
    },

    initialize: function Group(arg) {
        this._children = [];
        this._namedChildren = {};
        if (!this._initialize(arg))
            this.addChildren(Array.isArray(arg) ? arg : arguments);
    },

    _changed: function _changed(flags) {
        _changed.base.call(this, flags);
        if (flags & 1026) {
            this._clipItem = undefined;
        }
    },

    _getClipItem: function() {
        var clipItem = this._clipItem;
        if (clipItem === undefined) {
            clipItem = null;
            for (var i = 0, l = this._children.length; i < l; i++) {
                var child = this._children[i];
                if (child._clipMask) {
                    clipItem = child;
                    break;
                }
            }
            this._clipItem = clipItem;
        }
        return clipItem;
    },

    isClipped: function() {
        return !!this._getClipItem();
    },

    setClipped: function(clipped) {
        var child = this.getFirstChild();
        if (child)
            child.setClipMask(clipped);
    },

    _draw: function(ctx, param) {
        var clip = param.clip,
            clipItem = !clip && this._getClipItem(),
            draw = true;
        param = param.extend({ clipItem: clipItem, clip: false });
        if (clip) {
            if (this._currentPath) {
                ctx.currentPath = this._currentPath;
                draw = false;
            } else {
                ctx.beginPath();
                param.dontStart = param.dontFinish = true;
            }
        } else if (clipItem) {
            clipItem.draw(ctx, param.extend({ clip: true }));
        }
        if (draw) {
            for (var i = 0, l = this._children.length; i < l; i++) {
                var item = this._children[i];
                if (item !== clipItem)
                    item.draw(ctx, param);
            }
        }
        if (clip) {
            this._currentPath = ctx.currentPath;
        }
    }
});

var Layer = Group.extend({
    _class: 'Layer',

    initialize: function Layer(arg) {
        var props = Base.isPlainObject(arg)
                ? new Base(arg) 
                : { children: Array.isArray(arg) ? arg : arguments },
            insert = props.insert;
        props.insert = false;
        Group.call(this, props);
        if (insert || insert === undefined) {
            this._project.addChild(this);
            this.activate();
        }
    },

    _remove: function _remove(notify) {
        if (this._parent)
            return _remove.base.call(this, notify);
        if (this._index != null) {
            var project = this._project;
            if (project._activeLayer === this)
                project._activeLayer = this.getNextSibling()
                        || this.getPreviousSibling();
            Base.splice(project.layers, null, this._index, 1);
            this._installEvents(false);
            project._needsUpdate = true;
            return true;
        }
        return false;
    },

    getNextSibling: function getNextSibling() {
        return this._parent ? getNextSibling.base.call(this)
                : this._project.layers[this._index + 1] || null;
    },

    getPreviousSibling: function getPreviousSibling() {
        return this._parent ? getPreviousSibling.base.call(this)
                : this._project.layers[this._index - 1] || null;
    },

    isInserted: function isInserted() {
        return this._parent ? isInserted.base.call(this) : this._index != null;
    },

    activate: function() {
        this._project._activeLayer = this;
    },

    _insert: function _insert(above, item, _preserve) {
        if (item instanceof Layer && !item._parent) {
            this._remove(true, true);
            Base.splice(item._project.layers, [this],
                    item._index + (above ? 1 : 0), 0);
            this._setProject(item._project, true);
            return this;
        }
        return _insert.base.call(this, above, item, _preserve);
    }
});

var Shape = Item.extend({
    _class: 'Shape',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsSelected: true,
    _serializeFields: {
        type: null,
        size: null,
        radius: null
    },

    initialize: function Shape(props) {
        this._initialize(props);
    },

    _equals: function(item) {
        return this._type === item._type
            && this._size.equals(item._size)
            && Base.equals(this._radius, item._radius);
    },

    clone: function(insert) {
        var copy = new Shape(Item.NO_INSERT);
        copy.setType(this._type);
        copy.setSize(this._size);
        copy.setRadius(this._radius);
        return this._clone(copy, insert);
    },

    getType: function() {
        return this._type;
    },

    setType: function(type) {
        this._type = type;
    },

    getShape: '#getType',
    setShape: '#setType',

    getSize: function() {
        var size = this._size;
        return new LinkedSize(size.width, size.height, this, 'setSize');
    },

    setSize: function() {
        var size = Size.read(arguments);
        if (!this._size) {
            this._size = size.clone();
        } else if (!this._size.equals(size)) {
            var type = this._type,
                width = size.width,
                height = size.height;
            if (type === 'rectangle') {
                var radius = Size.min(this._radius, size.divide(2));
                this._radius.set(radius.width, radius.height);
            } else if (type === 'circle') {
                width = height = (width + height) / 2;
                this._radius = width / 2;
            } else if (type === 'ellipse') {
                this._radius.set(width / 2, height / 2);
            }
            this._size.set(width, height);
            this._changed(9);
        }
    },

    getRadius: function() {
        var rad = this._radius;
        return this._type === 'circle'
                ? rad
                : new LinkedSize(rad.width, rad.height, this, 'setRadius');
    },

    setRadius: function(radius) {
        var type = this._type;
        if (type === 'circle') {
            if (radius === this._radius)
                return;
            var size = radius * 2;
            this._radius = radius;
            this._size.set(size, size);
        } else {
            radius = Size.read(arguments);
            if (!this._radius) {
                this._radius = radius.clone();
            } else {
                if (this._radius.equals(radius))
                    return;
                this._radius.set(radius.width, radius.height);
                if (type === 'rectangle') {
                    var size = Size.max(this._size, radius.multiply(2));
                    this._size.set(size.width, size.height);
                } else if (type === 'ellipse') {
                    this._size.set(radius.width * 2, radius.height * 2);
                }
            }
        }
        this._changed(9);
    },

    isEmpty: function() {
        return false;
    },

    toPath: function(insert) {
        var path = new Path[Base.capitalize(this._type)]({
            center: new Point(),
            size: this._size,
            radius: this._radius,
            insert: false
        });
        path.setStyle(this._style);
        path.transform(this._matrix);
        if (insert || insert === undefined)
            path.insertAbove(this);
        return path;
    },

    _draw: function(ctx, param, strokeMatrix) {
        var style = this._style,
            hasFill = style.hasFill(),
            hasStroke = style.hasStroke(),
            dontPaint = param.dontFinish || param.clip,
            untransformed = !strokeMatrix;
        if (hasFill || hasStroke || dontPaint) {
            var type = this._type,
                radius = this._radius,
                isCircle = type === 'circle';
            if (!param.dontStart)
                ctx.beginPath();
            if (untransformed && isCircle) {
                ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
            } else {
                var rx = isCircle ? radius : radius.width,
                    ry = isCircle ? radius : radius.height,
                    size = this._size,
                    width = size.width,
                    height = size.height;
                if (untransformed && type === 'rect' && rx === 0 && ry === 0) {
                    ctx.rect(-width / 2, -height / 2, width, height);
                } else {
                    var x = width / 2,
                        y = height / 2,
                        kappa = 1 - 0.5522847498307936,
                        cx = rx * kappa,
                        cy = ry * kappa,
                        c = [
                            -x, -y + ry,
                            -x, -y + cy,
                            -x + cx, -y,
                            -x + rx, -y,
                            x - rx, -y,
                            x - cx, -y,
                            x, -y + cy,
                            x, -y + ry,
                            x, y - ry,
                            x, y - cy,
                            x - cx, y,
                            x - rx, y,
                            -x + rx, y,
                            -x + cx, y,
                            -x, y - cy,
                            -x, y - ry
                        ];
                    if (strokeMatrix)
                        strokeMatrix.transform(c, c, 32);
                    ctx.moveTo(c[0], c[1]);
                    ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
                    if (x !== rx)
                        ctx.lineTo(c[8], c[9]);
                    ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
                    if (y !== ry)
                        ctx.lineTo(c[16], c[17]);
                    ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
                    if (x !== rx)
                        ctx.lineTo(c[24], c[25]);
                    ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
                }
            }
            ctx.closePath();
        }
        if (!dontPaint && (hasFill || hasStroke)) {
            this._setStyles(ctx);
            if (hasFill) {
                ctx.fill(style.getWindingRule());
                ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (hasStroke)
                ctx.stroke();
        }
    },

    _canComposite: function() {
        return !(this.hasFill() && this.hasStroke());
    },

    _getBounds: function(getter, matrix) {
        var rect = new Rectangle(this._size).setCenter(0, 0);
        if (getter !== 'getBounds' && this.hasStroke())
            rect = rect.expand(this.getStrokeWidth());
        return matrix ? matrix._transformBounds(rect) : rect;
    }
},
new function() { 

    function getCornerCenter(that, point, expand) {
        var radius = that._radius;
        if (!radius.isZero()) {
            var halfSize = that._size.divide(2);
            for (var i = 0; i < 4; i++) {
                var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
                    corner = dir.multiply(halfSize),
                    center = corner.subtract(dir.multiply(radius)),
                    rect = new Rectangle(corner, center);
                if ((expand ? rect.expand(expand) : rect).contains(point))
                    return center;
            }
        }
    }

    function getEllipseRadius(point, radius) {
        var angle = point.getAngleInRadians(),
            width = radius.width * 2,
            height = radius.height * 2,
            x = width * Math.sin(angle),
            y = height * Math.cos(angle);
        return width * height / (2 * Math.sqrt(x * x + y * y));
    }

    return {
        _contains: function _contains(point) {
            if (this._type === 'rectangle') {
                var center = getCornerCenter(this, point);
                return center
                        ? point.subtract(center).divide(this._radius)
                            .getLength() <= 1
                        : _contains.base.call(this, point);
            } else {
                return point.divide(this.size).getLength() <= 0.5;
            }
        },

        _hitTestSelf: function _hitTestSelf(point, options) {
            var hit = false;
            if (this.hasStroke()) {
                var type = this._type,
                    radius = this._radius,
                    strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
                if (type === 'rectangle') {
                    var center = getCornerCenter(this, point, strokeWidth);
                    if (center) {
                        var pt = point.subtract(center);
                        hit = 2 * Math.abs(pt.getLength()
                                - getEllipseRadius(pt, radius)) <= strokeWidth;
                    } else {
                        var rect = new Rectangle(this._size).setCenter(0, 0),
                            outer = rect.expand(strokeWidth),
                            inner = rect.expand(-strokeWidth);
                        hit = outer._containsPoint(point)
                                && !inner._containsPoint(point);
                    }
                } else {
                    if (type === 'ellipse')
                        radius = getEllipseRadius(point, radius);
                    hit = 2 * Math.abs(point.getLength() - radius)
                            <= strokeWidth;
                }
            }
            return hit
                    ? new HitResult('stroke', this)
                    : _hitTestSelf.base.apply(this, arguments);
        }
    };
}, {

statics: new function() {
    function createShape(type, point, size, radius, args) {
        var item = new Shape(Base.getNamed(args));
        item._type = type;
        item._size = size;
        item._radius = radius;
        return item.translate(point);
    }

    return {
        Circle: function() {
            var center = Point.readNamed(arguments, 'center'),
                radius = Base.readNamed(arguments, 'radius');
            return createShape('circle', center, new Size(radius * 2), radius,
                    arguments);
        },

        Rectangle: function() {
            var rect = Rectangle.readNamed(arguments, 'rectangle'),
                radius = Size.min(Size.readNamed(arguments, 'radius'),
                        rect.getSize(true).divide(2));
            return createShape('rectangle', rect.getCenter(true),
                    rect.getSize(true), radius, arguments);
        },

        Ellipse: function() {
            var ellipse = Shape._readEllipse(arguments),
                radius = ellipse.radius;
            return createShape('ellipse', ellipse.center, radius.multiply(2),
                    radius, arguments);
        },

        _readEllipse: function(args) {
            var center,
                radius;
            if (Base.hasNamed(args, 'radius')) {
                center = Point.readNamed(args, 'center');
                radius = Size.readNamed(args, 'radius');
            } else {
                var rect = Rectangle.readNamed(args, 'rectangle');
                center = rect.getCenter(true);
                radius = rect.getSize(true).divide(2);
            }
            return { center: center, radius: radius };
        }
    };
}});

var Raster = Item.extend({
    _class: 'Raster',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsGetter: 'getBounds',
    _boundsSelected: true,
    _serializeFields: {
        source: null
    },

    initialize: function Raster(object, position) {
        if (!this._initialize(object,
                position !== undefined && Point.read(arguments, 1))) {
            if (typeof object === 'string') {
                this.setSource(object);
            } else {
                this.setImage(object);
            }
        }
        if (!this._size)
            this._size = new Size();
    },

    _equals: function(item) {
        return this.getSource() === item.getSource();
    },

    clone: function(insert) {
        var copy = new Raster(Item.NO_INSERT),
            image = this._image,
            canvas = this._canvas;
        if (image) {
            copy.setImage(image);
        } else if (canvas) {
            var copyCanvas = CanvasProvider.getCanvas(this._size);
            copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
            copy.setCanvas(copyCanvas);
        }
        return this._clone(copy, insert);
    },

    getSize: function() {
        var size = this._size;
        return new LinkedSize(size.width, size.height, this, 'setSize');
    },

    setSize: function() {
        var size = Size.read(arguments);
        if (!this._size.equals(size)) {
            var element = this.getElement();
            this.setCanvas(CanvasProvider.getCanvas(size));
            if (element)
                this.getContext(true).drawImage(element, 0, 0,
                        size.width, size.height);
        }
    },

    getWidth: function() {
        return this._size.width;
    },

    getHeight: function() {
        return this._size.height;
    },

    isEmpty: function() {
        return this._size.width === 0 && this._size.height === 0;
    },

    getResolution: function() {
        var matrix = this._matrix,
            orig = new Point(0, 0).transform(matrix),
            u = new Point(1, 0).transform(matrix).subtract(orig),
            v = new Point(0, 1).transform(matrix).subtract(orig);
        return new Size(
            72 / u.getLength(),
            72 / v.getLength()
        );
    },

    getPpi: '#getResolution',

    getImage: function() {
        return this._image;
    },

    setImage: function(image) {
        if (this._canvas)
            CanvasProvider.release(this._canvas);
        if (image && image.getContext) {
            this._image = null;
            this._canvas = image;
        } else {
            this._image = image;
            this._canvas = null;
        }
        this._size = new Size(
                image ? image.naturalWidth || image.width : 0,
                image ? image.naturalHeight || image.height : 0);
        this._context = null;
        this._changed(521);
    },

    getCanvas: function() {
        if (!this._canvas) {
            var ctx = CanvasProvider.getContext(this._size);
            try {
                if (this._image)
                    ctx.drawImage(this._image, 0, 0);
                this._canvas = ctx.canvas;
            } catch (e) {
                CanvasProvider.release(ctx);
            }
        }
        return this._canvas;
    },

    setCanvas: '#setImage',

    getContext: function(modify) {
        if (!this._context)
            this._context = this.getCanvas().getContext('2d');
        if (modify) {
            this._image = null;
            this._changed(513);
        }
        return this._context;
    },

    setContext: function(context) {
        this._context = context;
    },

    getSource: function() {
        return this._image && this._image.src || this.toDataURL();
    },

    setSource: function(src) {
        var that = this,
            image;

        function loaded() {
            var view = that.getView();
            if (view) {
                paper = view._scope;
                that.setImage(image);
                that.emit('load');
                view.update();
            }
        }

            image = document.getElementById(src) || new Image();

        if (image.naturalWidth && image.naturalHeight) {
            setTimeout(loaded, 0);
        } else {
            DomEvent.add(image, {
                load: loaded
            });
            if (!image.src)
                image.src = src;
        }
        this.setImage(image);
    },

    getElement: function() {
        return this._canvas || this._image;
    }
}, {
    beans: false,

    getSubCanvas: function() {
        var rect = Rectangle.read(arguments),
            ctx = CanvasProvider.getContext(rect.getSize());
        ctx.drawImage(this.getCanvas(), rect.x, rect.y,
                rect.width, rect.height, 0, 0, rect.width, rect.height);
        return ctx.canvas;
    },

    getSubRaster: function() {
        var rect = Rectangle.read(arguments),
            raster = new Raster(Item.NO_INSERT);
        raster.setCanvas(this.getSubCanvas(rect));
        raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
        raster._matrix.preConcatenate(this._matrix);
        raster.insertAbove(this);
        return raster;
    },

    toDataURL: function() {
        var src = this._image && this._image.src;
        if (/^data:/.test(src))
            return src;
        var canvas = this.getCanvas();
        return canvas ? canvas.toDataURL() : null;
    },

    drawImage: function(image ) {
        var point = Point.read(arguments, 1);
        this.getContext(true).drawImage(image, point.x, point.y);
    },

    getAverageColor: function(object) {
        var bounds, path;
        if (!object) {
            bounds = this.getBounds();
        } else if (object instanceof PathItem) {
            path = object;
            bounds = object.getBounds();
        } else if (object.width) {
            bounds = new Rectangle(object);
        } else if (object.x) {
            bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
        }
        var sampleSize = 32,
            width = Math.min(bounds.width, sampleSize),
            height = Math.min(bounds.height, sampleSize);
        var ctx = Raster._sampleContext;
        if (!ctx) {
            ctx = Raster._sampleContext = CanvasProvider.getContext(
                    new Size(sampleSize));
        } else {
            ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
        }
        ctx.save();
        var matrix = new Matrix()
                .scale(width / bounds.width, height / bounds.height)
                .translate(-bounds.x, -bounds.y);
        matrix.applyToContext(ctx);
        if (path)
            path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
        this._matrix.applyToContext(ctx);
        ctx.drawImage(this.getElement(),
                -this._size.width / 2, -this._size.height / 2);
        ctx.restore();
        var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
                Math.ceil(height)).data,
            channels = [0, 0, 0],
            total = 0;
        for (var i = 0, l = pixels.length; i < l; i += 4) {
            var alpha = pixels[i + 3];
            total += alpha;
            alpha /= 255;
            channels[0] += pixels[i] * alpha;
            channels[1] += pixels[i + 1] * alpha;
            channels[2] += pixels[i + 2] * alpha;
        }
        for (var i = 0; i < 3; i++)
            channels[i] /= total;
        return total ? Color.read(channels) : null;
    },

    getPixel: function() {
        var point = Point.read(arguments);
        var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
        return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
                data[3] / 255);
    },

    setPixel: function() {
        var point = Point.read(arguments),
            color = Color.read(arguments),
            components = color._convert('rgb'),
            alpha = color._alpha,
            ctx = this.getContext(true),
            imageData = ctx.createImageData(1, 1),
            data = imageData.data;
        data[0] = components[0] * 255;
        data[1] = components[1] * 255;
        data[2] = components[2] * 255;
        data[3] = alpha != null ? alpha * 255 : 255;
        ctx.putImageData(imageData, point.x, point.y);
    },

    createImageData: function() {
        var size = Size.read(arguments);
        return this.getContext().createImageData(size.width, size.height);
    },

    getImageData: function() {
        var rect = Rectangle.read(arguments);
        if (rect.isEmpty())
            rect = new Rectangle(this._size);
        return this.getContext().getImageData(rect.x, rect.y,
                rect.width, rect.height);
    },

    setImageData: function(data ) {
        var point = Point.read(arguments, 1);
        this.getContext(true).putImageData(data, point.x, point.y);
    },

    _getBounds: function(getter, matrix) {
        var rect = new Rectangle(this._size).setCenter(0, 0);
        return matrix ? matrix._transformBounds(rect) : rect;
    },

    _hitTestSelf: function(point) {
        if (this._contains(point)) {
            var that = this;
            return new HitResult('pixel', that, {
                offset: point.add(that._size.divide(2)).round(),
                color: {
                    get: function() {
                        return that.getPixel(this.offset);
                    }
                }
            });
        }
    },

    _draw: function(ctx) {
        var element = this.getElement();
        if (element) {
            ctx.globalAlpha = this._opacity;
            ctx.drawImage(element,
                    -this._size.width / 2, -this._size.height / 2);
        }
    },

    _canComposite: function() {
        return true;
    }
});

var PlacedSymbol = Item.extend({
    _class: 'PlacedSymbol',
    _applyMatrix: false,
    _canApplyMatrix: false,
    _boundsGetter: { getBounds: 'getStrokeBounds' },
    _boundsSelected: true,
    _serializeFields: {
        symbol: null
    },

    initialize: function PlacedSymbol(arg0, arg1) {
        if (!this._initialize(arg0,
                arg1 !== undefined && Point.read(arguments, 1)))
            this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
    },

    _equals: function(item) {
        return this._symbol === item._symbol;
    },

    getSymbol: function() {
        return this._symbol;
    },

    setSymbol: function(symbol) {
        this._symbol = symbol;
        this._changed(9);
    },

    clone: function(insert) {
        var copy = new PlacedSymbol(Item.NO_INSERT);
        copy.setSymbol(this._symbol);
        return this._clone(copy, insert);
    },

    isEmpty: function() {
        return this._symbol._definition.isEmpty();
    },

    _getBounds: function(getter, matrix, cacheItem) {
        var definition = this.symbol._definition;
        return definition._getCachedBounds(getter,
                matrix && matrix.chain(definition._matrix), cacheItem);
    },

    _hitTestSelf: function(point, options) {
        var res = this._symbol._definition._hitTest(point, options);
        if (res)
            res.item = this;
        return res;
    },

    _draw: function(ctx, param) {
        this.symbol._definition.draw(ctx, param);
    }

});

var HitResult = Base.extend({
    _class: 'HitResult',

    initialize: function HitResult(type, item, values) {
        this.type = type;
        this.item = item;
        if (values) {
            values.enumerable = true;
            this.inject(values);
        }
    },

    statics: {
        getOptions: function(options) {
            return new Base({
                type: null,
                tolerance: paper.settings.hitTolerance,
                fill: !options,
                stroke: !options,
                segments: !options,
                handles: false,
                ends: false,
                center: false,
                bounds: false,
                guides: false,
                selected: false
            }, options);
        }
    }
});

var Segment = Base.extend({
    _class: 'Segment',
    beans: true,

    initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
        var count = arguments.length,
            point, handleIn, handleOut;
        if (count === 0) {
        } else if (count === 1) {
            if (arg0.point) {
                point = arg0.point;
                handleIn = arg0.handleIn;
                handleOut = arg0.handleOut;
            } else {
                point = arg0;
            }
        } else if (count === 2 && typeof arg0 === 'number') {
            point = arguments;
        } else if (count <= 3) {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
        } else { 
            point = arg0 !== undefined ? [ arg0, arg1 ] : null;
            handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
            handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
        }
        new SegmentPoint(point, this, '_point');
        new SegmentPoint(handleIn, this, '_handleIn');
        new SegmentPoint(handleOut, this, '_handleOut');
    },

    _serialize: function(options) {
        return Base.serialize(this.isLinear() ? this._point
                : [this._point, this._handleIn, this._handleOut],
                options, true);
    },

    _changed: function(point) {
        var path = this._path;
        if (!path)
            return;
        var curves = path._curves,
            index = this._index,
            curve;
        if (curves) {
            if ((!point || point === this._point || point === this._handleIn)
                    && (curve = index > 0 ? curves[index - 1] : path._closed
                        ? curves[curves.length - 1] : null))
                curve._changed();
            if ((!point || point === this._point || point === this._handleOut)
                    && (curve = curves[index]))
                curve._changed();
        }
        path._changed(25);
    },

    getPoint: function() {
        return this._point;
    },

    setPoint: function() {
        var point = Point.read(arguments);
        this._point.set(point.x, point.y);
    },

    getHandleIn: function() {
        return this._handleIn;
    },

    setHandleIn: function() {
        var point = Point.read(arguments);
        this._handleIn.set(point.x, point.y);
    },

    getHandleOut: function() {
        return this._handleOut;
    },

    setHandleOut: function() {
        var point = Point.read(arguments);
        this._handleOut.set(point.x, point.y);
    },

    isLinear: function() {
        return this._handleIn.isZero() && this._handleOut.isZero();
    },

    setLinear: function(linear) {
        if (linear) {
            this._handleIn.set(0, 0);
            this._handleOut.set(0, 0);
        } else {
        }
    },

    isColinear: function(segment) {
        var next1 = this.getNext(),
            next2 = segment.getNext();
        return this._handleOut.isZero() && next1._handleIn.isZero()
                && segment._handleOut.isZero() && next2._handleIn.isZero()
                && next1._point.subtract(this._point).isColinear(
                    next2._point.subtract(segment._point));
    },

    isOrthogonal: function() {
        var prev = this.getPrevious(),
            next = this.getNext();
        return prev._handleOut.isZero() && this._handleIn.isZero()
            && this._handleOut.isZero() && next._handleIn.isZero()
            && this._point.subtract(prev._point).isOrthogonal(
                    next._point.subtract(this._point));
    },

    isArc: function() {
        var next = this.getNext(),
            handle1 = this._handleOut,
            handle2 = next._handleIn,
            kappa = 0.5522847498307936;
        if (handle1.isOrthogonal(handle2)) {
            var from = this._point,
                to = next._point,
                corner = new Line(from, handle1, true).intersect(
                        new Line(to, handle2, true), true);
            return corner && Numerical.isZero(handle1.getLength() /
                    corner.subtract(from).getLength() - kappa)
                && Numerical.isZero(handle2.getLength() /
                    corner.subtract(to).getLength() - kappa);
        }
        return false;
    },

    _selectionState: 0,

    isSelected: function(_point) {
        var state = this._selectionState;
        return !_point ? !!(state & 7)
            : _point === this._point ? !!(state & 4)
            : _point === this._handleIn ? !!(state & 1)
            : _point === this._handleOut ? !!(state & 2)
            : false;
    },

    setSelected: function(selected, _point) {
        var path = this._path,
            selected = !!selected, 
            state = this._selectionState,
            oldState = state,
            flag = !_point ? 7
                    : _point === this._point ? 4
                    : _point === this._handleIn ? 1
                    : _point === this._handleOut ? 2
                    : 0;
        if (selected) {
            state |= flag;
        } else {
            state &= ~flag;
        }
        this._selectionState = state;
        if (path && state !== oldState) {
            path._updateSelection(this, oldState, state);
            path._changed(129);
        }
    },

    getIndex: function() {
        return this._index !== undefined ? this._index : null;
    },

    getPath: function() {
        return this._path || null;
    },

    getCurve: function() {
        var path = this._path,
            index = this._index;
        if (path) {
            if (index > 0 && !path._closed
                    && index === path._segments.length - 1)
                index--;
            return path.getCurves()[index] || null;
        }
        return null;
    },

    getLocation: function() {
        var curve = this.getCurve();
        return curve
                ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
                : null;
    },

    getNext: function() {
        var segments = this._path && this._path._segments;
        return segments && (segments[this._index + 1]
                || this._path._closed && segments[0]) || null;
    },

    getPrevious: function() {
        var segments = this._path && this._path._segments;
        return segments && (segments[this._index - 1]
                || this._path._closed && segments[segments.length - 1]) || null;
    },

    reverse: function() {
        return new Segment(this._point, this._handleOut, this._handleIn);
    },

    remove: function() {
        return this._path ? !!this._path.removeSegment(this._index) : false;
    },

    clone: function() {
        return new Segment(this._point, this._handleIn, this._handleOut);
    },

    equals: function(segment) {
        return segment === this || segment && this._class === segment._class
                && this._point.equals(segment._point)
                && this._handleIn.equals(segment._handleIn)
                && this._handleOut.equals(segment._handleOut)
                || false;
    },

    toString: function() {
        var parts = [ 'point: ' + this._point ];
        if (!this._handleIn.isZero())
            parts.push('handleIn: ' + this._handleIn);
        if (!this._handleOut.isZero())
            parts.push('handleOut: ' + this._handleOut);
        return '{ ' + parts.join(', ') + ' }';
    },

    transform: function(matrix) {
        this._transformCoordinates(matrix, new Array(6), true);
        this._changed();
    },

    _transformCoordinates: function(matrix, coords, change) {
        var point = this._point,
            handleIn = !change || !this._handleIn.isZero()
                    ? this._handleIn : null,
            handleOut = !change || !this._handleOut.isZero()
                    ? this._handleOut : null,
            x = point._x,
            y = point._y,
            i = 2;
        coords[0] = x;
        coords[1] = y;
        if (handleIn) {
            coords[i++] = handleIn._x + x;
            coords[i++] = handleIn._y + y;
        }
        if (handleOut) {
            coords[i++] = handleOut._x + x;
            coords[i++] = handleOut._y + y;
        }
        if (matrix) {
            matrix._transformCoordinates(coords, coords, i / 2);
            x = coords[0];
            y = coords[1];
            if (change) {
                point._x = x;
                point._y = y;
                i  = 2;
                if (handleIn) {
                    handleIn._x = coords[i++] - x;
                    handleIn._y = coords[i++] - y;
                }
                if (handleOut) {
                    handleOut._x = coords[i++] - x;
                    handleOut._y = coords[i++] - y;
                }
            } else {
                if (!handleIn) {
                    coords[i++] = x;
                    coords[i++] = y;
                }
                if (!handleOut) {
                    coords[i++] = x;
                    coords[i++] = y;
                }
            }
        }
        return coords;
    }
});

var SegmentPoint = Point.extend({
    initialize: function SegmentPoint(point, owner, key) {
        var x, y, selected;
        if (!point) {
            x = y = 0;
        } else if ((x = point[0]) !== undefined) { 
            y = point[1];
        } else {
            var pt = point;
            if ((x = pt.x) === undefined) {
                pt = Point.read(arguments);
                x = pt.x;
            }
            y = pt.y;
            selected = pt.selected;
        }
        this._x = x;
        this._y = y;
        this._owner = owner;
        owner[key] = this;
        if (selected)
            this.setSelected(true);
    },

    set: function(x, y) {
        this._x = x;
        this._y = y;
        this._owner._changed(this);
        return this;
    },

    _serialize: function(options) {
        var f = options.formatter,
            x = f.number(this._x),
            y = f.number(this._y);
        return this.isSelected()
                ? { x: x, y: y, selected: true }
                : [x, y];
    },

    getX: function() {
        return this._x;
    },

    setX: function(x) {
        this._x = x;
        this._owner._changed(this);
    },

    getY: function() {
        return this._y;
    },

    setY: function(y) {
        this._y = y;
        this._owner._changed(this);
    },

    isZero: function() {
        return Numerical.isZero(this._x) && Numerical.isZero(this._y);
    },

    setSelected: function(selected) {
        this._owner.setSelected(selected, this);
    },

    isSelected: function() {
        return this._owner.isSelected(this);
    }
});

var Curve = Base.extend({
    _class: 'Curve',

    initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
        var count = arguments.length;
        if (count === 3) {
            this._path = arg0;
            this._segment1 = arg1;
            this._segment2 = arg2;
        } else if (count === 0) {
            this._segment1 = new Segment();
            this._segment2 = new Segment();
        } else if (count === 1) {
            this._segment1 = new Segment(arg0.segment1);
            this._segment2 = new Segment(arg0.segment2);
        } else if (count === 2) {
            this._segment1 = new Segment(arg0);
            this._segment2 = new Segment(arg1);
        } else {
            var point1, handle1, handle2, point2;
            if (count === 4) {
                point1 = arg0;
                handle1 = arg1;
                handle2 = arg2;
                point2 = arg3;
            } else if (count === 8) {
                point1 = [arg0, arg1];
                point2 = [arg6, arg7];
                handle1 = [arg2 - arg0, arg3 - arg1];
                handle2 = [arg4 - arg6, arg5 - arg7];
            }
            this._segment1 = new Segment(point1, null, handle1);
            this._segment2 = new Segment(point2, handle2, null);
        }
    },

    _changed: function() {
        this._length = this._bounds = undefined;
    },

    getPoint1: function() {
        return this._segment1._point;
    },

    setPoint1: function() {
        var point = Point.read(arguments);
        this._segment1._point.set(point.x, point.y);
    },

    getPoint2: function() {
        return this._segment2._point;
    },

    setPoint2: function() {
        var point = Point.read(arguments);
        this._segment2._point.set(point.x, point.y);
    },

    getHandle1: function() {
        return this._segment1._handleOut;
    },

    setHandle1: function() {
        var point = Point.read(arguments);
        this._segment1._handleOut.set(point.x, point.y);
    },

    getHandle2: function() {
        return this._segment2._handleIn;
    },

    setHandle2: function() {
        var point = Point.read(arguments);
        this._segment2._handleIn.set(point.x, point.y);
    },

    getSegment1: function() {
        return this._segment1;
    },

    getSegment2: function() {
        return this._segment2;
    },

    getPath: function() {
        return this._path;
    },

    getIndex: function() {
        return this._segment1._index;
    },

    getNext: function() {
        var curves = this._path && this._path._curves;
        return curves && (curves[this._segment1._index + 1]
                || this._path._closed && curves[0]) || null;
    },

    getPrevious: function() {
        var curves = this._path && this._path._curves;
        return curves && (curves[this._segment1._index - 1]
                || this._path._closed && curves[curves.length - 1]) || null;
    },

    isSelected: function() {
        return this.getPoint1().isSelected()
                && this.getHandle2().isSelected()
                && this.getHandle2().isSelected()
                && this.getPoint2().isSelected();
    },

    setSelected: function(selected) {
        this.getPoint1().setSelected(selected);
        this.getHandle1().setSelected(selected);
        this.getHandle2().setSelected(selected);
        this.getPoint2().setSelected(selected);
    },

    getValues: function(matrix) {
        return Curve.getValues(this._segment1, this._segment2, matrix);
    },

    getPoints: function() {
        var coords = this.getValues(),
            points = [];
        for (var i = 0; i < 8; i += 2)
            points.push(new Point(coords[i], coords[i + 1]));
        return points;
    },

    getLength: function() {
        if (this._length == null) {
            this._length = this.isLinear()
                ? this._segment2._point.getDistance(this._segment1._point)
                : Curve.getLength(this.getValues(), 0, 1);
        }
        return this._length;
    },

    getArea: function() {
        return Curve.getArea(this.getValues());
    },

    getPart: function(from, to) {
        return new Curve(Curve.getPart(this.getValues(), from, to));
    },

    getPartLength: function(from, to) {
        return Curve.getLength(this.getValues(), from, to);
    },

    isLinear: function() {
        return this._segment1._handleOut.isZero()
                && this._segment2._handleIn.isZero();
    },

    isHorizontal: function() {
        return this.isLinear() && Numerical.isZero(
                this._segment1._point._y - this._segment2._point._y);
    },

    getIntersections: function(curve) {
        return Curve.getIntersections(this.getValues(), curve.getValues(),
                this, curve, []);
    },

    _getParameter: function(offset, isParameter) {
        return isParameter
                ? offset
                : offset && offset.curve === this
                    ? offset.parameter
                    : offset === undefined && isParameter === undefined
                        ? 0.5 
                        : this.getParameterAt(offset, 0);
    },

    divide: function(offset, isParameter, ignoreLinear) {
        var parameter = this._getParameter(offset, isParameter),
            tolerance = 0.00001,
            res = null;
        if (parameter > tolerance && parameter < 1 - tolerance) {
            var parts = Curve.subdivide(this.getValues(), parameter),
                isLinear = ignoreLinear ? false : this.isLinear(),
                left = parts[0],
                right = parts[1];

            if (!isLinear) {
                this._segment1._handleOut.set(left[2] - left[0],
                        left[3] - left[1]);
                this._segment2._handleIn.set(right[4] - right[6],
                        right[5] - right[7]);
            }

            var x = left[6], y = left[7],
                segment = new Segment(new Point(x, y),
                        !isLinear && new Point(left[4] - x, left[5] - y),
                        !isLinear && new Point(right[2] - x, right[3] - y));

            if (this._path) {
                if (this._segment1._index > 0 && this._segment2._index === 0) {
                    this._path.add(segment);
                } else {
                    this._path.insert(this._segment2._index, segment);
                }
                res = this; 
            } else {
                var end = this._segment2;
                this._segment2 = segment;
                res = new Curve(segment, end);
            }
        }
        return res;
    },

    split: function(offset, isParameter) {
        return this._path
            ? this._path.split(this._segment1._index,
                    this._getParameter(offset, isParameter))
            : null;
    },

    reverse: function() {
        return new Curve(this._segment2.reverse(), this._segment1.reverse());
    },

    remove: function() {
        var removed = false;
        if (this._path) {
            var segment2 = this._segment2,
                handleOut = segment2._handleOut;
            removed = segment2.remove();
            if (removed)
                this._segment1._handleOut.set(handleOut.x, handleOut.y);
        }
        return removed;
    },

    clone: function() {
        return new Curve(this._segment1, this._segment2);
    },

    toString: function() {
        var parts = [ 'point1: ' + this._segment1._point ];
        if (!this._segment1._handleOut.isZero())
            parts.push('handle1: ' + this._segment1._handleOut);
        if (!this._segment2._handleIn.isZero())
            parts.push('handle2: ' + this._segment2._handleIn);
        parts.push('point2: ' + this._segment2._point);
        return '{ ' + parts.join(', ') + ' }';
    },

statics: {
    getValues: function(segment1, segment2, matrix) {
        var p1 = segment1._point,
            h1 = segment1._handleOut,
            h2 = segment2._handleIn,
            p2 = segment2._point,
            values = [
                p1._x, p1._y,
                p1._x + h1._x, p1._y + h1._y,
                p2._x + h2._x, p2._y + h2._y,
                p2._x, p2._y
            ];
        if (matrix)
            matrix._transformCoordinates(values, values, 4);
        return values;
    },

    evaluate: function(v, t, type) {
        var p1x = v[0], p1y = v[1],
            c1x = v[2], c1y = v[3],
            c2x = v[4], c2y = v[5],
            p2x = v[6], p2y = v[7],
            tolerance = 0.00001,
            x, y;

        if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
            var isZero = t < tolerance;
            x = isZero ? p1x : p2x;
            y = isZero ? p1y : p2y;
        } else {
            var cx = 3 * (c1x - p1x),
                bx = 3 * (c2x - c1x) - cx,
                ax = p2x - p1x - cx - bx,

                cy = 3 * (c1y - p1y),
                by = 3 * (c2y - c1y) - cy,
                ay = p2y - p1y - cy - by;
            if (type === 0) {
                x = ((ax * t + bx) * t + cx) * t + p1x;
                y = ((ay * t + by) * t + cy) * t + p1y;
            } else {
                if (t < tolerance && c1x === p1x && c1y === p1y
                        || t > 1 - tolerance && c2x === p2x && c2y === p2y) {
                    x = c2x - c1x;
                    y = c2y - c1y;
                } else if (t < tolerance) {
                    x = cx;
                    y = cy;
                } else if (t > 1 - tolerance) {
                    x = 3 * (p2x - c2x);
                    y = 3 * (p2y - c2y);
                } else {
                    x = (3 * ax * t + 2 * bx) * t + cx;
                    y = (3 * ay * t + 2 * by) * t + cy;
                }
                if (type === 3) {
                    var x2 = 6 * ax * t + 2 * bx,
                        y2 = 6 * ay * t + 2 * by;
                    return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
                }
            }
        }
        return type === 2 ? new Point(y, -x) : new Point(x, y);
    },

    subdivide: function(v, t) {
        var p1x = v[0], p1y = v[1],
            c1x = v[2], c1y = v[3],
            c2x = v[4], c2y = v[5],
            p2x = v[6], p2y = v[7];
        if (t === undefined)
            t = 0.5;
        var u = 1 - t,
            p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
            p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
            p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
            p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
            p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
            p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
        return [
            [p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y], 
            [p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y] 
        ];
    },

    solveCubic: function (v, coord, val, roots, min, max) {
        var p1 = v[coord],
            c1 = v[coord + 2],
            c2 = v[coord + 4],
            p2 = v[coord + 6],
            c = 3 * (c1 - p1),
            b = 3 * (c2 - c1) - c,
            a = p2 - p1 - c - b;
        return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
    },

    getParameterOf: function(v, x, y) {
        var tolerance = 0.00001;
        if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
            return 0;
        if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
            return 1;
        var txs = [],
            tys = [],
            sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
            sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
            tx, ty;
        for (var cx = 0;  sx == -1 || cx < sx;) {
            if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
                for (var cy = 0; sy == -1 || cy < sy;) {
                    if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
                        if (sx == -1) tx = ty;
                        else if (sy == -1) ty = tx;
                        if (Math.abs(tx - ty) < tolerance)
                            return (tx + ty) * 0.5;
                    }
                }
                if (sx == -1)
                    break;
            }
        }
        return null;
    },

    getPart: function(v, from, to) {
        if (from > 0)
            v = Curve.subdivide(v, from)[1]; 
        if (to < 1)
            v = Curve.subdivide(v, (to - from) / (1 - from))[0]; 
        return v;
    },

    isLinear: function(v) {
        var isZero = Numerical.isZero;
        return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
                && isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
    },

    isFlatEnough: function(v, tolerance) {
        var p1x = v[0], p1y = v[1],
            c1x = v[2], c1y = v[3],
            c2x = v[4], c2y = v[5],
            p2x = v[6], p2y = v[7],
            ux = 3 * c1x - 2 * p1x - p2x,
            uy = 3 * c1y - 2 * p1y - p2y,
            vx = 3 * c2x - 2 * p2x - p1x,
            vy = 3 * c2y - 2 * p2y - p1y;
        return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
                < 10 * tolerance * tolerance;
    },

    getArea: function(v) {
        var p1x = v[0], p1y = v[1],
            c1x = v[2], c1y = v[3],
            c2x = v[4], c2y = v[5],
            p2x = v[6], p2y = v[7];
        return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
                - 1.5 * c1y * p2x - 3.0 * p1y * c1x
                - 1.5 * p1y * c2x - 0.5 * p1y * p2x
                + 1.5 * c2y * p1x + 1.5 * c2y * c1x
                - 3.0 * c2y * p2x + 0.5 * p2y * p1x
                + 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
    },

    getBounds: function(v) {
        var min = v.slice(0, 2), 
            max = min.slice(), 
            roots = [0, 0];
        for (var i = 0; i < 2; i++)
            Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
                    i, 0, min, max, roots);
        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    },

    _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
        function add(value, padding) {
            var left = value - padding,
                right = value + padding;
            if (left < min[coord])
                min[coord] = left;
            if (right > max[coord])
                max[coord] = right;
        }
        var a = 3 * (v1 - v2) - v0 + v3,
            b = 2 * (v0 + v2) - 4 * v1,
            c = v1 - v0,
            count = Numerical.solveQuadratic(a, b, c, roots),
            tMin = 0.00001,
            tMax = 1 - tMin;
        add(v3, 0);
        for (var i = 0; i < count; i++) {
            var t = roots[i],
                u = 1 - t;
            if (tMin < t && t < tMax)
                add(u * u * u * v0
                    + 3 * u * u * t * v1
                    + 3 * u * t * t * v2
                    + t * t * t * v3,
                    padding);
        }
    }
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
    function(name) {
        this[name] = function() {
            if (!this._bounds)
                this._bounds = {};
            var bounds = this._bounds[name];
            if (!bounds) {
                bounds = this._bounds[name] = Path[name]([this._segment1,
                        this._segment2], false, this._path.getStyle());
            }
            return bounds.clone();
        };
    },
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
    function(name, index) {
        this[name + 'At'] = function(offset, isParameter) {
            var values = this.getValues();
            return Curve.evaluate(values, isParameter
                    ? offset : Curve.getParameterAt(values, offset, 0), index);
        };
        this[name] = function(parameter) {
            return Curve.evaluate(this.getValues(), parameter, index);
        };
    },
{
    beans: false,

    getParameterAt: function(offset, start) {
        return Curve.getParameterAt(this.getValues(), offset, start);
    },

    getParameterOf: function() {
        var point = Point.read(arguments);
        return Curve.getParameterOf(this.getValues(), point.x, point.y);
    },

    getLocationAt: function(offset, isParameter) {
        if (!isParameter)
            offset = this.getParameterAt(offset);
        return offset >= 0 && offset <= 1 && new CurveLocation(this, offset);
    },

    getLocationOf: function() {
        return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
                true);
    },

    getOffsetOf: function() {
        var loc = this.getLocationOf.apply(this, arguments);
        return loc ? loc.getOffset() : null;
    },

    getNearestLocation: function() {
        var point = Point.read(arguments),
            values = this.getValues(),
            count = 100,
            minDist = Infinity,
            minT = 0;

        function refine(t) {
            if (t >= 0 && t <= 1) {
                var dist = point.getDistance(
                        Curve.evaluate(values, t, 0), true);
                if (dist < minDist) {
                    minDist = dist;
                    minT = t;
                    return true;
                }
            }
        }

        for (var i = 0; i <= count; i++)
            refine(i / count);

        var step = 1 / (count * 2);
        while (step > 0.00001) {
            if (!refine(minT - step) && !refine(minT + step))
                step /= 2;
        }
        var pt = Curve.evaluate(values, minT, 0);
        return new CurveLocation(this, minT, pt, null, null, null,
                point.getDistance(pt));
    },

    getNearestPoint: function() {
        return this.getNearestLocation.apply(this, arguments).getPoint();
    }

}),
new function() { 

    function getLengthIntegrand(v) {
        var p1x = v[0], p1y = v[1],
            c1x = v[2], c1y = v[3],
            c2x = v[4], c2y = v[5],
            p2x = v[6], p2y = v[7],

            ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
            bx = 6 * (p1x + c2x) - 12 * c1x,
            cx = 3 * (c1x - p1x),

            ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
            by = 6 * (p1y + c2y) - 12 * c1y,
            cy = 3 * (c1y - p1y);

        return function(t) {
            var dx = (ax * t + bx) * t + cx,
                dy = (ay * t + by) * t + cy;
            return Math.sqrt(dx * dx + dy * dy);
        };
    }

    function getIterations(a, b) {
        return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
    }

    return {
        statics: true,

        getLength: function(v, a, b) {
            if (a === undefined)
                a = 0;
            if (b === undefined)
                b = 1;
            var isZero = Numerical.isZero;
            if (a === 0 && b === 1
                    && isZero(v[0] - v[2]) && isZero(v[1] - v[3])
                    && isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
                var dx = v[6] - v[0], 
                    dy = v[7] - v[1]; 
                return Math.sqrt(dx * dx + dy * dy);
            }
            var ds = getLengthIntegrand(v);
            return Numerical.integrate(ds, a, b, getIterations(a, b));
        },

        getParameterAt: function(v, offset, start) {
            if (start === undefined)
                start = offset < 0 ? 1 : 0
            if (offset === 0)
                return start;
            var forward = offset > 0,
                a = forward ? start : 0,
                b = forward ? 1 : start,
                ds = getLengthIntegrand(v),
                rangeLength = Numerical.integrate(ds, a, b,
                        getIterations(a, b));
            if (Math.abs(offset) >= rangeLength)
                return forward ? b : a;
            var guess = offset / rangeLength,
                length = 0;
            function f(t) {
                length += Numerical.integrate(ds, start, t,
                        getIterations(start, t));
                start = t;
                return length - offset;
            }
            return Numerical.findRoot(f, ds, start + guess, a, b, 16,
                    0.00001);
        }
    };
}, new function() { 
    function addLocation(locations, include, curve1, t1, point1, curve2, t2,
            point2) {
        var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
        if (!include || include(loc))
            locations.push(loc);
    }

    function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
            tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
        if (recursion > 20)
            return;
        var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
            tolerance = 0.00001,
            hullEpsilon = 1e-9,
            getSignedDistance = Line.getSignedDistance,
            d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
            d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
            factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
            dMin = factor * Math.min(0, d1, d2),
            dMax = factor * Math.max(0, d1, d2),
            dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
            dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
            dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
            dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
            tMinNew, tMaxNew, tDiff;
        if (q0x === q3x && uMax - uMin <= hullEpsilon && recursion > 3) {
            tMinNew = (tMax + tMin) / 2;
            tMaxNew = tMinNew;
            tDiff = 0;
        } else {
            var hull = getConvexHull(dp0, dp1, dp2, dp3),
                top = hull[0],
                bottom = hull[1],
                tMinClip, tMaxClip;
            tMinClip = clipConvexHull(top, bottom, dMin, dMax);
            top.reverse();
            bottom.reverse();
            tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
            if (tMinClip == null || tMaxClip == null)
                return false;
            v1 = Curve.getPart(v1, tMinClip, tMaxClip);
            tDiff = tMaxClip - tMinClip;
            tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
            tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
        }
        if (oldTDiff > 0.8 && tDiff > 0.8) {
            if (tMaxNew - tMinNew > uMax - uMin) {
                var parts = Curve.subdivide(v1, 0.5),
                    t = tMinNew + (tMaxNew - tMinNew) / 2;
                addCurveIntersections(
                    v2, parts[0], curve2, curve1, locations, include,
                    uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
                addCurveIntersections(
                    v2, parts[1], curve2, curve1, locations, include,
                    uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
            } else {
                var parts = Curve.subdivide(v2, 0.5),
                    t = uMin + (uMax - uMin) / 2;
                addCurveIntersections(
                    parts[0], v1, curve2, curve1, locations, include,
                    uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
                addCurveIntersections(
                    parts[1], v1, curve2, curve1, locations, include,
                    t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
            }
        } else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
            var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
                t2 = uMin + (uMax - uMin) / 2;
            if (reverse) {
                addLocation(locations, include,
                        curve2, t2, Curve.evaluate(v2, t2, 0),
                        curve1, t1, Curve.evaluate(v1, t1, 0));
            } else {
                addLocation(locations, include,
                        curve1, t1, Curve.evaluate(v1, t1, 0),
                        curve2, t2, Curve.evaluate(v2, t2, 0));
            }
        } else { 
            addCurveIntersections(v2, v1, curve2, curve1, locations, include,
                    uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
        }
    }

    function getConvexHull(dq0, dq1, dq2, dq3) {
        var p0 = [ 0, dq0 ],
            p1 = [ 1 / 3, dq1 ],
            p2 = [ 2 / 3, dq2 ],
            p3 = [ 1, dq3 ],
            getSignedDistance = Line.getSignedDistance,
            dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
            dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
            flip = false,
            hull;
        if (dist1 * dist2 < 0) {
            hull = [[p0, p1, p3], [p0, p2, p3]];
            flip = dist1 < 0;
        } else {
            var pmax, cross = 0,
                distZero = dist1 === 0 || dist2 === 0;
            if (Math.abs(dist1) > Math.abs(dist2)) {
                pmax = p1;
                cross = (dq3 - dq2 - (dq3 - dq0) / 3)
                        * (2 * (dq3 - dq2) - dq3 + dq1) / 3;
            } else {
                pmax = p2;
                cross = (dq1 - dq0 + (dq0 - dq3) / 3)
                        * (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
            }
            hull = cross < 0 || distZero
                    ? [[p0, pmax, p3], [p0, p3]]
                    : [[p0, p1, p2, p3], [p0, p3]];
            flip = dist1 ? dist1 < 0 : dist2 < 0;
        }
        return flip ? hull.reverse() : hull;
    }

    function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
        var tProxy,
            tVal = null,
            px, py,
            qx, qy;
        for (var i = 0, l = hullBottom.length - 1; i < l; i++) {
            py = hullBottom[i][1];
            qy = hullBottom[i + 1][1];
            if (py < qy) {
                tProxy = null;
            } else if (qy <= dMax) {
                px = hullBottom[i][0];
                qx = hullBottom[i + 1][0];
                tProxy = px + (dMax - py) * (qx - px) / (qy - py);
            } else {
                continue;
            }
            break;
        }
        if (hullTop[0][1] <= dMax)
            tProxy = hullTop[0][0];
        for (var i = 0, l = hullTop.length - 1; i < l; i++) {
            py = hullTop[i][1];
            qy = hullTop[i + 1][1];
            if (py >= dMin) {
                tVal = tProxy;
            } else if (py > qy) {
                tVal = null;
            } else if (qy >= dMin) {
                px = hullTop[i][0];
                qx = hullTop[i + 1][0];
                tVal = px + (dMin  - py) * (qx - px) / (qy - py);
            } else {
                continue;
            }
            break;
        }
        return tVal;
    }

    function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
            include) {
        var flip = Curve.isLinear(v1),
            vc = flip ? v2 : v1,
            vl = flip ? v1 : v2,
            lx1 = vl[0], ly1 = vl[1],
            lx2 = vl[6], ly2 = vl[7],
            ldx = lx2 - lx1,
            ldy = ly2 - ly1,
            angle = Math.atan2(-ldy, ldx),
            sin = Math.sin(angle),
            cos = Math.cos(angle),
            rlx2 = ldx * cos - ldy * sin,
            rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
            rvc = [];
        for(var i = 0; i < 8; i += 2) {
            var x = vc[i] - lx1,
                y = vc[i + 1] - ly1;
            rvc.push(
                x * cos - y * sin,
                y * cos + x * sin);
        }
        var roots = [],
            count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
        for (var i = 0; i < count; i++) {
            var tc = roots[i],
                x = Curve.evaluate(rvc, tc, 0).x;
            if (x >= 0 && x <= rlx2) {
                var tl = Curve.getParameterOf(rvl, x, 0),
                    t1 = flip ? tl : tc,
                    t2 = flip ? tc : tl;
                addLocation(locations, include,
                        curve1, t1, Curve.evaluate(v1, t1, 0),
                        curve2, t2, Curve.evaluate(v2, t2, 0));
            }
        }
    }

    function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
        var point = Line.intersect(
                v1[0], v1[1], v1[6], v1[7],
                v2[0], v2[1], v2[6], v2[7]);
        if (point) {
            var x = point.x,
                y = point.y;
            addLocation(locations, include,
                    curve1, Curve.getParameterOf(v1, x, y), point,
                    curve2, Curve.getParameterOf(v2, x, y), point);
        }
    }

    return { statics: {
        getIntersections: function(v1, v2, curve1, curve2, locations, include) {
            var linear1 = Curve.isLinear(v1),
                linear2 = Curve.isLinear(v2);
            (linear1 && linear2
                ? addLineIntersection
                : linear1 || linear2
                    ? addCurveLineIntersections
                    : addCurveIntersections)(
                        v1, v2, curve1, curve2, locations, include,
                        0, 1, 0, 1, 0, false, 0);
            return locations;
        }
    }};
});

var CurveLocation = Base.extend({
    _class: 'CurveLocation',
    beans: true,

    initialize: function CurveLocation(curve, parameter, point, _curve2,
            _parameter2, _point2, _distance) {
        this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
        this._curve = curve;
        this._segment1 = curve._segment1;
        this._segment2 = curve._segment2;
        this._parameter = parameter;
        this._point = point;
        this._curve2 = _curve2;
        this._parameter2 = _parameter2;
        this._point2 = _point2;
        this._distance = _distance;
    },

    getSegment: function(_preferFirst) {
        if (!this._segment) {
            var curve = this.getCurve(),
                parameter = this.getParameter();
            if (parameter === 1) {
                this._segment = curve._segment2;
            } else if (parameter === 0 || _preferFirst) {
                this._segment = curve._segment1;
            } else if (parameter == null) {
                return null;
            } else {
                this._segment = curve.getPartLength(0, parameter)
                    < curve.getPartLength(parameter, 1)
                        ? curve._segment1
                        : curve._segment2;
            }
        }
        return this._segment;
    },

    getCurve: function(_uncached) {
        if (!this._curve || _uncached) {
            this._curve = this._segment1.getCurve();
            if (this._curve.getParameterOf(this._point) == null)
                this._curve = this._segment2.getPrevious().getCurve();
        }
        return this._curve;
    },

    getIntersection: function() {
        var intersection = this._intersection;
        if (!intersection && this._curve2) {
            var param = this._parameter2;
            this._intersection = intersection = new CurveLocation(
                    this._curve2, param, this._point2 || this._point, this);
            intersection._intersection = this;
        }
        return intersection;
    },

    getPath: function() {
        var curve = this.getCurve();
        return curve && curve._path;
    },

    getIndex: function() {
        var curve = this.getCurve();
        return curve && curve.getIndex();
    },

    getOffset: function() {
        var path = this.getPath();
        return path ? path._getOffset(this) : this.getCurveOffset();
    },

    getCurveOffset: function() {
        var curve = this.getCurve(),
            parameter = this.getParameter();
        return parameter != null && curve && curve.getPartLength(0, parameter);
    },

    getParameter: function(_uncached) {
        if ((this._parameter == null || _uncached) && this._point) {
            var curve = this.getCurve(_uncached);
            this._parameter = curve && curve.getParameterOf(this._point);
        }
        return this._parameter;
    },

    getPoint: function(_uncached) {
        if ((!this._point || _uncached) && this._parameter != null) {
            var curve = this.getCurve(_uncached);
            this._point = curve && curve.getPointAt(this._parameter, true);
        }
        return this._point;
    },

    getDistance: function() {
        return this._distance;
    },

    divide: function() {
        var curve = this.getCurve(true);
        return curve && curve.divide(this.getParameter(true), true);
    },

    split: function() {
        var curve = this.getCurve(true);
        return curve && curve.split(this.getParameter(true), true);
    },

    equals: function(loc) {
        var isZero = Numerical.isZero;
        return this === loc
                || loc
                    && this._curve === loc._curve
                    && this._curve2 === loc._curve2
                    && isZero(this._parameter - loc._parameter)
                    && isZero(this._parameter2 - loc._parameter2)
                || false;
    },

    toString: function() {
        var parts = [],
            point = this.getPoint(),
            f = Formatter.instance;
        if (point)
            parts.push('point: ' + point);
        var index = this.getIndex();
        if (index != null)
            parts.push('index: ' + index);
        var parameter = this.getParameter();
        if (parameter != null)
            parts.push('parameter: ' + f.number(parameter));
        if (this._distance != null)
            parts.push('distance: ' + f.number(this._distance));
        return '{ ' + parts.join(', ') + ' }';
    }
}, Base.each(['getTangent', 'getNormal', 'getCurvature'], function(name) {
    var get = name + 'At';
    this[name] = function() {
        var parameter = this.getParameter(),
            curve = this.getCurve();
        return parameter != null && curve && curve[get](parameter, true);
    };
}, {}));

var PathItem = Item.extend({
    _class: 'PathItem',

    initialize: function PathItem() {
    },

    getIntersections: function(path, _matrix, _expand) {
        if (this === path)
            path = null;
        var locations = [],
            curves1 = this.getCurves(),
            curves2 = path ? path.getCurves() : curves1,
            matrix1 = this._matrix.orNullIfIdentity(),
            matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
                : matrix1,
            length1 = curves1.length,
            length2 = path ? curves2.length : length1,
            values2 = [],
            MIN = 1e-11,
            MAX = 1 - 1e-11;
        if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
            return [];
        for (var i = 0; i < length2; i++)
            values2[i] = curves2[i].getValues(matrix2);
        for (var i = 0; i < length1; i++) {
            var curve1 = curves1[i],
                values1 = path ? curve1.getValues(matrix1) : values2[i];
            if (!path) {
                var seg1 = curve1.getSegment1(),
                    seg2 = curve1.getSegment2(),
                    h1 = seg1._handleOut,
                    h2 = seg2._handleIn;
                if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
                        .intersect(new Line(seg2._point.subtract(h2),
                        h2.multiply(2), true), false)) {
                    var parts = Curve.subdivide(values1);
                    Curve.getIntersections(
                        parts[0], parts[1], curve1, curve1, locations,
                        function(loc) {
                            if (loc._parameter <= MAX) {
                                loc._parameter /= 2;
                                loc._parameter2 = 0.5 + loc._parameter2 / 2;
                                return true;
                            }
                        }
                    );
                }
            }
            for (var j = path ? 0 : i + 1; j < length2; j++) {
                Curve.getIntersections(
                    values1, values2[j], curve1, curves2[j], locations,
                    !path && (j === i + 1 || j === length2 - 1 && i === 0)
                        && function(loc) {
                            var t = loc._parameter;
                            return t >= MIN && t <= MAX;
                        }
                );
            }
        }
        var last = locations.length - 1;
        for (var i = last; i >= 0; i--) {
            var loc = locations[i],
                next = loc._curve.getNext(),
                next2 = loc._curve2.getNext();
            if (next && loc._parameter >= MAX) {
                loc._parameter = 0;
                loc._curve = next;
            }
            if (next2 && loc._parameter2 >= MAX) {
                loc._parameter2 = 0;
                loc._curve2 = next2;
            }
        }

        function compare(loc1, loc2) {
            var path1 = loc1.getPath(),
                path2 = loc2.getPath();
            return path1 === path2
                    ? (loc1.getIndex() + loc1.getParameter())
                            - (loc2.getIndex() + loc2.getParameter())
                    : path1._id - path2._id;
        }

        if (last > 0) {
            locations.sort(compare);
            for (var i = last; i >= 1; i--) {
                if (locations[i].equals(locations[i === 0 ? last : i - 1])) {
                    locations.splice(i, 1);
                    last--;
                }
            }
        }
        if (_expand) {
            for (var i = last; i >= 0; i--)
                locations.push(locations[i].getIntersection());
            locations.sort(compare);
        }
        return locations;
    },

    _asPathItem: function() {
        return this;
    },

    setPathData: function(data) {

        var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
            coords,
            relative = false,
            previous,
            control,
            current = new Point(),
            start = new Point();

        function getCoord(index, coord) {
            var val = +coords[index];
            if (relative)
                val += current[coord];
            return val;
        }

        function getPoint(index) {
            return new Point(
                getCoord(index, 'x'),
                getCoord(index + 1, 'y')
            );
        }

        this.clear();

        for (var i = 0, l = parts.length; i < l; i++) {
            var part = parts[i],
                command = part[0],
                lower = command.toLowerCase();
            coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
            var length = coords && coords.length;
            relative = command === lower;
            if (previous === 'z' && !/[mz]/.test(lower))
                this.moveTo(current = start);
            switch (lower) {
            case 'm':
            case 'l':
                var move = lower === 'm';
                if (move && previous && previous !== 'z')
                    this.closePath(true);
                for (var j = 0; j < length; j += 2)
                    this[j === 0 && move ? 'moveTo' : 'lineTo'](
                            current = getPoint(j));
                control = current;
                if (move)
                    start = current;
                break;
            case 'h':
            case 'v':
                var coord = lower === 'h' ? 'x' : 'y';
                for (var j = 0; j < length; j++) {
                    current[coord] = getCoord(j, coord);
                    this.lineTo(current);
                }
                control = current;
                break;
            case 'c':
                for (var j = 0; j < length; j += 6) {
                    this.cubicCurveTo(
                            getPoint(j),
                            control = getPoint(j + 2),
                            current = getPoint(j + 4));
                }
                break;
            case 's':
                for (var j = 0; j < length; j += 4) {
                    this.cubicCurveTo(
                            /[cs]/.test(previous)
                                    ? current.multiply(2).subtract(control)
                                    : current,
                            control = getPoint(j),
                            current = getPoint(j + 2));
                    previous = lower;
                }
                break;
            case 'q':
                for (var j = 0; j < length; j += 4) {
                    this.quadraticCurveTo(
                            control = getPoint(j),
                            current = getPoint(j + 2));
                }
                break;
            case 't':
                for (var j = 0; j < length; j += 2) {
                    this.quadraticCurveTo(
                            control = (/[qt]/.test(previous)
                                    ? current.multiply(2).subtract(control)
                                    : current),
                            current = getPoint(j));
                    previous = lower;
                }
                break;
            case 'a':
                for (var j = 0; j < length; j += 7) {
                    this.arcTo(current = getPoint(j + 5),
                            new Size(+coords[0], +coords[1]),
                            +coords[2], +coords[4], +coords[3]);
                }
                break;
            case 'z':
                this.closePath(true);
                break;
            }
            previous = lower;
        }
    },

    _canComposite: function() {
        return !(this.hasFill() && this.hasStroke());
    },

    _contains: function(point) {
        var winding = this._getWinding(point, false, true);
        return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
    }

});

var Path = PathItem.extend({
    _class: 'Path',
    _serializeFields: {
        segments: [],
        closed: false
    },

    initialize: function Path(arg) {
        this._closed = false;
        this._segments = [];
        var segments = Array.isArray(arg)
            ? typeof arg[0] === 'object'
                ? arg
                : arguments
            : arg && (arg.size === undefined && (arg.x !== undefined
                    || arg.point !== undefined))
                ? arguments
                : null;
        if (segments && segments.length > 0) {
            this.setSegments(segments);
        } else {
            this._curves = undefined; 
            this._selectedSegmentState = 0;
            if (!segments && typeof arg === 'string') {
                this.setPathData(arg);
                arg = null;
            }
        }
        this._initialize(!segments && arg);
    },

    _equals: function(item) {
        return Base.equals(this._segments, item._segments);
    },

    clone: function(insert) {
        var copy = new Path(Item.NO_INSERT);
        copy.setSegments(this._segments);
        copy._closed = this._closed;
        if (this._clockwise !== undefined)
            copy._clockwise = this._clockwise;
        return this._clone(copy, insert);
    },

    _changed: function _changed(flags) {
        _changed.base.call(this, flags);
        if (flags & 8) {
            var parent = this._parent;
            if (parent)
                parent._currentPath = undefined;
            this._length = this._clockwise = undefined;
            if (this._curves && !(flags & 16)) {
                for (var i = 0, l = this._curves.length; i < l; i++)
                    this._curves[i]._changed();
            }
            this._monoCurves = undefined;
        } else if (flags & 32) {
            this._bounds = undefined;
        }
    },

    getStyle: function() {
        var parent = this._parent;
        return (parent instanceof CompoundPath ? parent : this)._style;
    },

    getSegments: function() {
        return this._segments;
    },

    setSegments: function(segments) {
        var fullySelected = this.isFullySelected();
        this._segments.length = 0;
        this._selectedSegmentState = 0;
        this._curves = undefined;
        if (segments && segments.length > 0)
            this._add(Segment.readAll(segments));
        if (fullySelected)
            this.setFullySelected(true);
    },

    getFirstSegment: function() {
        return this._segments[0];
    },

    getLastSegment: function() {
        return this._segments[this._segments.length - 1];
    },

    getCurves: function() {
        var curves = this._curves,
            segments = this._segments;
        if (!curves) {
            var length = this._countCurves();
            curves = this._curves = new Array(length);
            for (var i = 0; i < length; i++)
                curves[i] = new Curve(this, segments[i],
                    segments[i + 1] || segments[0]);
        }
        return curves;
    },

    getFirstCurve: function() {
        return this.getCurves()[0];
    },

    getLastCurve: function() {
        var curves = this.getCurves();
        return curves[curves.length - 1];
    },

    isClosed: function() {
        return this._closed;
    },

    setClosed: function(closed) {
        if (this._closed != (closed = !!closed)) {
            this._closed = closed;
            if (this._curves) {
                var length = this._curves.length = this._countCurves();
                if (closed)
                    this._curves[length - 1] = new Curve(this,
                        this._segments[length - 1], this._segments[0]);
            }
            this._changed(25);
        }
    }
}, {
    beans: true,

    getPathData: function(_matrix, _precision) {
        var segments = this._segments,
            length = segments.length,
            f = new Formatter(_precision),
            coords = new Array(6),
            first = true,
            curX, curY,
            prevX, prevY,
            inX, inY,
            outX, outY,
            parts = [];

        function addSegment(segment, skipLine) {
            segment._transformCoordinates(_matrix, coords, false);
            curX = coords[0];
            curY = coords[1];
            if (first) {
                parts.push('M' + f.pair(curX, curY));
                first = false;
            } else {
                inX = coords[2];
                inY = coords[3];
                if (inX === curX && inY === curY
                        && outX === prevX && outY === prevY) {
                    if (!skipLine)
                        parts.push('l' + f.pair(curX - prevX, curY - prevY));
                } else {
                    parts.push('c' + f.pair(outX - prevX, outY - prevY)
                            + ' ' + f.pair(inX - prevX, inY - prevY)
                            + ' ' + f.pair(curX - prevX, curY - prevY));
                }
            }
            prevX = curX;
            prevY = curY;
            outX = coords[4];
            outY = coords[5];
        }

        if (length === 0)
            return '';

        for (var i = 0; i < length; i++)
            addSegment(segments[i]);
        if (this._closed && length > 0) {
            addSegment(segments[0], true);
            parts.push('z');
        }
        return parts.join('');
    }
}, {

    isEmpty: function() {
        return this._segments.length === 0;
    },

    isPolygon: function() {
        for (var i = 0, l = this._segments.length; i < l; i++) {
            if (!this._segments[i].isLinear())
                return false;
        }
        return true;
    },

    _transformContent: function(matrix) {
        var coords = new Array(6);
        for (var i = 0, l = this._segments.length; i < l; i++)
            this._segments[i]._transformCoordinates(matrix, coords, true);
        return true;
    },

    _add: function(segs, index) {
        var segments = this._segments,
            curves = this._curves,
            amount = segs.length,
            append = index == null,
            index = append ? segments.length : index;
        for (var i = 0; i < amount; i++) {
            var segment = segs[i];
            if (segment._path)
                segment = segs[i] = segment.clone();
            segment._path = this;
            segment._index = index + i;
            if (segment._selectionState)
                this._updateSelection(segment, 0, segment._selectionState);
        }
        if (append) {
            segments.push.apply(segments, segs);
        } else {
            segments.splice.apply(segments, [index, 0].concat(segs));
            for (var i = index + amount, l = segments.length; i < l; i++)
                segments[i]._index = i;
        }
        if (curves || segs._curves) {
            if (!curves)
                curves = this._curves = [];
            var from = index > 0 ? index - 1 : index,
                start = from,
                to = Math.min(from + amount, this._countCurves());
            if (segs._curves) {
                curves.splice.apply(curves, [from, 0].concat(segs._curves));
                start += segs._curves.length;
            }
            for (var i = start; i < to; i++)
                curves.splice(i, 0, new Curve(this, null, null));
            this._adjustCurves(from, to);
        }
        this._changed(25);
        return segs;
    },

    _adjustCurves: function(from, to) {
        var segments = this._segments,
            curves = this._curves,
            curve;
        for (var i = from; i < to; i++) {
            curve = curves[i];
            curve._path = this;
            curve._segment1 = segments[i];
            curve._segment2 = segments[i + 1] || segments[0];
            curve._changed();
        }
        if (curve = curves[this._closed && from === 0 ? segments.length - 1
                : from - 1]) {
            curve._segment2 = segments[from] || segments[0];
            curve._changed();
        }
        if (curve = curves[to]) {
            curve._segment1 = segments[to];
            curve._changed();
        }
    },

    _countCurves: function() {
        var length = this._segments.length;
        return !this._closed && length > 0 ? length - 1 : length;
    },

    add: function(segment1 ) {
        return arguments.length > 1 && typeof segment1 !== 'number'
            ? this._add(Segment.readAll(arguments))
            : this._add([ Segment.read(arguments) ])[0];
    },

    insert: function(index, segment1 ) {
        return arguments.length > 2 && typeof segment1 !== 'number'
            ? this._add(Segment.readAll(arguments, 1), index)
            : this._add([ Segment.read(arguments, 1) ], index)[0];
    },

    addSegment: function() {
        return this._add([ Segment.read(arguments) ])[0];
    },

    insertSegment: function(index ) {
        return this._add([ Segment.read(arguments, 1) ], index)[0];
    },

    addSegments: function(segments) {
        return this._add(Segment.readAll(segments));
    },

    insertSegments: function(index, segments) {
        return this._add(Segment.readAll(segments), index);
    },

    removeSegment: function(index) {
        return this.removeSegments(index, index + 1)[0] || null;
    },

    removeSegments: function(from, to, _includeCurves) {
        from = from || 0;
        to = Base.pick(to, this._segments.length);
        var segments = this._segments,
            curves = this._curves,
            count = segments.length, 
            removed = segments.splice(from, to - from),
            amount = removed.length;
        if (!amount)
            return removed;
        for (var i = 0; i < amount; i++) {
            var segment = removed[i];
            if (segment._selectionState)
                this._updateSelection(segment, segment._selectionState, 0);
            segment._index = segment._path = null;
        }
        for (var i = from, l = segments.length; i < l; i++)
            segments[i]._index = i;
        if (curves) {
            var index = from > 0 && to === count + (this._closed ? 1 : 0)
                    ? from - 1
                    : from,
                curves = curves.splice(index, amount);
            if (_includeCurves)
                removed._curves = curves.slice(1);
            this._adjustCurves(index, index);
        }
        this._changed(25);
        return removed;
    },

    clear: '#removeSegments',

    getLength: function() {
        if (this._length == null) {
            var curves = this.getCurves();
            this._length = 0;
            for (var i = 0, l = curves.length; i < l; i++)
                this._length += curves[i].getLength();
        }
        return this._length;
    },

    getArea: function() {
        var curves = this.getCurves();
        var area = 0;
        for (var i = 0, l = curves.length; i < l; i++)
            area += curves[i].getArea();
        return area;
    },

    isFullySelected: function() {
        var length = this._segments.length;
        return this._selected && length > 0 && this._selectedSegmentState
                === length * 7;
    },

    setFullySelected: function(selected) {
        if (selected)
            this._selectSegments(true);
        this.setSelected(selected);
    },

    setSelected: function setSelected(selected) {
        if (!selected)
            this._selectSegments(false);
        setSelected.base.call(this, selected);
    },

    _selectSegments: function(selected) {
        var length = this._segments.length;
        this._selectedSegmentState = selected
                ? length * 7 : 0;
        for (var i = 0; i < length; i++)
            this._segments[i]._selectionState = selected
                    ? 7 : 0;
    },

    _updateSelection: function(segment, oldState, newState) {
        segment._selectionState = newState;
        var total = this._selectedSegmentState += newState - oldState;
        if (total > 0)
            this.setSelected(true);
    },

    flatten: function(maxDistance) {
        var iterator = new PathIterator(this, 64, 0.1),
            pos = 0,
            step = iterator.length / Math.ceil(iterator.length / maxDistance),
            end = iterator.length + (this._closed ? -step : step) / 2;
        var segments = [];
        while (pos <= end) {
            segments.push(new Segment(iterator.evaluate(pos, 0)));
            pos += step;
        }
        this.setSegments(segments);
    },

    reduce: function() {
        var curves = this.getCurves();
        for (var i = curves.length - 1; i >= 0; i--) {
            var curve = curves[i];
            if (curve.isLinear() && curve.getLength() === 0)
                curve.remove();
        }
        return this;
    },

    simplify: function(tolerance) {
        if (this._segments.length > 2) {
            var fitter = new PathFitter(this, tolerance || 2.5);
            this.setSegments(fitter.fit());
        }
    },

    split: function(index, parameter) {
        if (parameter === null)
            return;
        if (arguments.length === 1) {
            var arg = index;
            if (typeof arg === 'number')
                arg = this.getLocationAt(arg);
            index = arg.index;
            parameter = arg.parameter;
        }
        var tolerance = 0.00001;
        if (parameter >= 1 - tolerance) {
            index++;
            parameter--;
        }
        var curves = this.getCurves();
        if (index >= 0 && index < curves.length) {
            if (parameter > tolerance) {
                curves[index++].divide(parameter, true);
            }
            var segs = this.removeSegments(index, this._segments.length, true),
                path;
            if (this._closed) {
                this.setClosed(false);
                path = this;
            } else if (index > 0) {
                path = this._clone(new Path().insertAbove(this, true));
            }
            path._add(segs, 0);
            this.addSegment(segs[0]);
            return path;
        }
        return null;
    },

    isClockwise: function() {
        if (this._clockwise !== undefined)
            return this._clockwise;
        return Path.isClockwise(this._segments);
    },

    setClockwise: function(clockwise) {
        if (this.isClockwise() != (clockwise = !!clockwise))
            this.reverse();
        this._clockwise = clockwise;
    },

    reverse: function() {
        this._segments.reverse();
        for (var i = 0, l = this._segments.length; i < l; i++) {
            var segment = this._segments[i];
            var handleIn = segment._handleIn;
            segment._handleIn = segment._handleOut;
            segment._handleOut = handleIn;
            segment._index = i;
        }
        this._curves = null;
        if (this._clockwise !== undefined)
            this._clockwise = !this._clockwise;
        this._changed(9);
    },

    join: function(path) {
        if (path) {
            var segments = path._segments,
                last1 = this.getLastSegment(),
                last2 = path.getLastSegment();
            if (last1._point.equals(last2._point))
                path.reverse();
            var first1,
                first2 = path.getFirstSegment();
            if (last1._point.equals(first2._point)) {
                last1.setHandleOut(first2._handleOut);
                this._add(segments.slice(1));
            } else {
                first1 = this.getFirstSegment();
                if (first1._point.equals(first2._point))
                    path.reverse();
                last2 = path.getLastSegment();
                if (first1._point.equals(last2._point)) {
                    first1.setHandleIn(last2._handleIn);
                    this._add(segments.slice(0, segments.length - 1), 0);
                } else {
                    this._add(segments.slice());
                }
            }
            if (path.closed)
                this._add([segments[0]]);
            path.remove();
        }
        var first = this.getFirstSegment(),
            last = this.getLastSegment();
        if (first !== last && first._point.equals(last._point)) {
            first.setHandleIn(last._handleIn);
            last.remove();
            this.setClosed(true);
        }
    },

    toShape: function(insert) {
        if (!this._closed)
            return null;

        var segments = this._segments,
            type,
            size,
            radius,
            topCenter;

        function isColinear(i, j) {
            return segments[i].isColinear(segments[j]);
        }

        function isOrthogonal(i) {
            return segments[i].isOrthogonal();
        }

        function isArc(i) {
            return segments[i].isArc();
        }

        function getDistance(i, j) {
            return segments[i]._point.getDistance(segments[j]._point);
        }

        if (this.isPolygon() && segments.length === 4
                && isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
            type = Shape.Rectangle;
            size = new Size(getDistance(0, 3), getDistance(0, 1));
            topCenter = segments[1]._point.add(segments[2]._point).divide(2);
        } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
                && isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
            type = Shape.Rectangle;
            size = new Size(getDistance(1, 6), getDistance(0, 3));
            radius = size.subtract(new Size(getDistance(0, 7),
                    getDistance(1, 2))).divide(2);
            topCenter = segments[3]._point.add(segments[4]._point).divide(2);
        } else if (segments.length === 4
                && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
            if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
                type = Shape.Circle;
                radius = getDistance(0, 2) / 2;
            } else {
                type = Shape.Ellipse;
                radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
            }
            topCenter = segments[1]._point;
        }

        if (type) {
            var center = this.getPosition(true),
                shape = new type({
                    center: center,
                    size: size,
                    radius: radius,
                    insert: false
                });
            shape.rotate(topCenter.subtract(center).getAngle() + 90);
            shape.setStyle(this._style);
            if (insert || insert === undefined)
                shape.insertAbove(this);
            return shape;
        }
        return null;
    },

    _hitTestSelf: function(point, options) {
        var that = this,
            style = this.getStyle(),
            segments = this._segments,
            numSegments = segments.length,
            closed = this._closed,
            tolerancePadding = options._tolerancePadding,
            strokePadding = tolerancePadding,
            join, cap, miterLimit,
            area, loc, res,
            hitStroke = options.stroke && style.hasStroke(),
            hitFill = options.fill && style.hasFill(),
            hitCurves = options.curves,
            radius = hitStroke
                    ? style.getStrokeWidth() / 2
                    : hitFill && options.tolerance > 0 || hitCurves
                        ? 0 : null;
        if (radius !== null) {
            if (radius > 0) {
                join = style.getStrokeJoin();
                cap = style.getStrokeCap();
                miterLimit = radius * style.getMiterLimit();
                strokePadding = tolerancePadding.add(new Point(radius, radius));
            } else {
                join = cap = 'round';
            }
        }

        function isCloseEnough(pt, padding) {
            return point.subtract(pt).divide(padding).length <= 1;
        }

        function checkSegmentPoint(seg, pt, name) {
            if (!options.selected || pt.isSelected()) {
                var anchor = seg._point;
                if (pt !== anchor)
                    pt = pt.add(anchor);
                if (isCloseEnough(pt, strokePadding)) {
                    return new HitResult(name, that, {
                        segment: seg,
                        point: pt
                    });
                }
            }
        }

        function checkSegmentPoints(seg, ends) {
            return (ends || options.segments)
                && checkSegmentPoint(seg, seg._point, 'segment')
                || (!ends && options.handles) && (
                    checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
                    checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
        }

        function addToArea(point) {
            area.add(point);
        }

        function checkSegmentStroke(segment) {
            if (join !== 'round' || cap !== 'round') {
                area = new Path({ internal: true, closed: true });
                if (closed || segment._index > 0
                        && segment._index < numSegments - 1) {
                    if (join !== 'round' && (segment._handleIn.isZero()
                            || segment._handleOut.isZero()))
                        Path._addBevelJoin(segment, join, radius, miterLimit,
                                addToArea, true);
                } else if (cap !== 'round') {
                    Path._addSquareCap(segment, cap, radius, addToArea, true);
                }
                if (!area.isEmpty()) {
                    var loc;
                    return area.contains(point)
                        || (loc = area.getNearestLocation(point))
                            && isCloseEnough(loc.getPoint(), tolerancePadding);
                }
            }
            return isCloseEnough(segment._point, strokePadding);
        }

        if (options.ends && !options.segments && !closed) {
            if (res = checkSegmentPoints(segments[0], true)
                    || checkSegmentPoints(segments[numSegments - 1], true))
                return res;
        } else if (options.segments || options.handles) {
            for (var i = 0; i < numSegments; i++)
                if (res = checkSegmentPoints(segments[i]))
                    return res;
        }
        if (radius !== null) {
            loc = this.getNearestLocation(point);
            if (loc) {
                var parameter = loc.getParameter();
                if (parameter === 0 || parameter === 1 && numSegments > 1) {
                    if (!checkSegmentStroke(loc.getSegment()))
                        loc = null;
                } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
                    loc = null;
                }
            }
            if (!loc && join === 'miter' && numSegments > 1) {
                for (var i = 0; i < numSegments; i++) {
                    var segment = segments[i];
                    if (point.getDistance(segment._point) <= miterLimit
                            && checkSegmentStroke(segment)) {
                        loc = segment.getLocation();
                        break;
                    }
                }
            }
        }
        return !loc && hitFill && this._contains(point)
                || loc && !hitStroke && !hitCurves
                    ? new HitResult('fill', this)
                    : loc
                        ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
                            location: loc,
                            point: loc.getPoint()
                        })
                        : null;
    }

}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
    function(name) {
        this[name + 'At'] = function(offset, isParameter) {
            var loc = this.getLocationAt(offset, isParameter);
            return loc && loc[name]();
        };
    },
{
    beans: false,

    _getOffset: function(location) {
        var index = location && location.getIndex();
        if (index != null) {
            var curves = this.getCurves(),
                offset = 0;
            for (var i = 0; i < index; i++)
                offset += curves[i].getLength();
            var curve = curves[index],
                parameter = location.getParameter();
            if (parameter > 0)
                offset += curve.getPartLength(0, parameter);
            return offset;
        }
        return null;
    },

    getLocationOf: function() {
        var point = Point.read(arguments),
            curves = this.getCurves();
        for (var i = 0, l = curves.length; i < l; i++) {
            var loc = curves[i].getLocationOf(point);
            if (loc)
                return loc;
        }
        return null;
    },

    getOffsetOf: function() {
        var loc = this.getLocationOf.apply(this, arguments);
        return loc ? loc.getOffset() : null;
    },

    getLocationAt: function(offset, isParameter) {
        var curves = this.getCurves(),
            length = 0;
        if (isParameter) {
            var index = ~~offset; 
            return curves[index].getLocationAt(offset - index, true);
        }
        for (var i = 0, l = curves.length; i < l; i++) {
            var start = length,
                curve = curves[i];
            length += curve.getLength();
            if (length > offset) {
                return curve.getLocationAt(offset - start);
            }
        }
        if (offset <= this.getLength())
            return new CurveLocation(curves[curves.length - 1], 1);
        return null;
    },

    getNearestLocation: function() {
        var point = Point.read(arguments),
            curves = this.getCurves(),
            minDist = Infinity,
            minLoc = null;
        for (var i = 0, l = curves.length; i < l; i++) {
            var loc = curves[i].getNearestLocation(point);
            if (loc._distance < minDist) {
                minDist = loc._distance;
                minLoc = loc;
            }
        }
        return minLoc;
    },

    getNearestPoint: function() {
        return this.getNearestLocation.apply(this, arguments).getPoint();
    }
}), new function() { 

    function drawHandles(ctx, segments, matrix, size) {
        var half = size / 2;

        function drawHandle(index) {
            var hX = coords[index],
                hY = coords[index + 1];
            if (pX != hX || pY != hY) {
                ctx.beginPath();
                ctx.moveTo(pX, pY);
                ctx.lineTo(hX, hY);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
                ctx.fill();
            }
        }

        var coords = new Array(6);
        for (var i = 0, l = segments.length; i < l; i++) {
            var segment = segments[i];
            segment._transformCoordinates(matrix, coords, false);
            var state = segment._selectionState,
                pX = coords[0],
                pY = coords[1];
            if (state & 1)
                drawHandle(2);
            if (state & 2)
                drawHandle(4);
            ctx.fillRect(pX - half, pY - half, size, size);
            if (!(state & 4)) {
                var fillStyle = ctx.fillStyle;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
                ctx.fillStyle = fillStyle;
            }
        }
    }

    function drawSegments(ctx, path, matrix) {
        var segments = path._segments,
            length = segments.length,
            coords = new Array(6),
            first = true,
            curX, curY,
            prevX, prevY,
            inX, inY,
            outX, outY;

        function drawSegment(segment) {
            if (matrix) {
                segment._transformCoordinates(matrix, coords, false);
                curX = coords[0];
                curY = coords[1];
            } else {
                var point = segment._point;
                curX = point._x;
                curY = point._y;
            }
            if (first) {
                ctx.moveTo(curX, curY);
                first = false;
            } else {
                if (matrix) {
                    inX = coords[2];
                    inY = coords[3];
                } else {
                    var handle = segment._handleIn;
                    inX = curX + handle._x;
                    inY = curY + handle._y;
                }
                if (inX === curX && inY === curY
                        && outX === prevX && outY === prevY) {
                    ctx.lineTo(curX, curY);
                } else {
                    ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
                }
            }
            prevX = curX;
            prevY = curY;
            if (matrix) {
                outX = coords[4];
                outY = coords[5];
            } else {
                var handle = segment._handleOut;
                outX = prevX + handle._x;
                outY = prevY + handle._y;
            }
        }

        for (var i = 0; i < length; i++)
            drawSegment(segments[i]);
        if (path._closed && length > 0)
            drawSegment(segments[0]);
    }

    return {
        _draw: function(ctx, param, strokeMatrix) {
            var dontStart = param.dontStart,
                dontPaint = param.dontFinish || param.clip,
                style = this.getStyle(),
                hasFill = style.hasFill(),
                hasStroke = style.hasStroke(),
                dashArray = style.getDashArray(),
                dashLength = !paper.support.nativeDash && hasStroke
                        && dashArray && dashArray.length;

            if (!dontStart)
                ctx.beginPath();

            if (!dontStart && this._currentPath) {
                ctx.currentPath = this._currentPath;
            } else if (hasFill || hasStroke && !dashLength || dontPaint) {
                drawSegments(ctx, this, strokeMatrix);
                if (this._closed)
                    ctx.closePath();
                if (!dontStart)
                    this._currentPath = ctx.currentPath;
            }

            function getOffset(i) {
                return dashArray[((i % dashLength) + dashLength) % dashLength];
            }

            if (!dontPaint && (hasFill || hasStroke)) {
                this._setStyles(ctx);
                if (hasFill) {
                    ctx.fill(style.getWindingRule());
                    ctx.shadowColor = 'rgba(0,0,0,0)';
                }
                if (hasStroke) {
                    if (dashLength) {
                        if (!dontStart)
                            ctx.beginPath();
                        var iterator = new PathIterator(this, 32, 0.25,
                                strokeMatrix),
                            length = iterator.length,
                            from = -style.getDashOffset(), to,
                            i = 0;
                        from = from % length;
                        while (from > 0) {
                            from -= getOffset(i--) + getOffset(i--);
                        }
                        while (from < length) {
                            to = from + getOffset(i++);
                            if (from > 0 || to > 0)
                                iterator.drawPart(ctx,
                                        Math.max(from, 0), Math.max(to, 0));
                            from = to + getOffset(i++);
                        }
                    }
                    ctx.stroke();
                }
            }
        },

        _drawSelected: function(ctx, matrix) {
            ctx.beginPath();
            drawSegments(ctx, this, matrix);
            ctx.stroke();
            drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
        }
    };
}, new function() { 

    function getFirstControlPoints(rhs) {
        var n = rhs.length,
            x = [], 
            tmp = [], 
            b = 2;
        x[0] = rhs[0] / b;
        for (var i = 1; i < n; i++) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4 : 2) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for (var i = 1; i < n; i++) {
            x[n - i - 1] -= tmp[n - i] * x[n - i];
        }
        return x;
    }

    return {
        smooth: function() {
            var segments = this._segments,
                size = segments.length,
                closed = this._closed,
                n = size,
                overlap = 0;
            if (size <= 2)
                return;
            if (closed) {
                overlap = Math.min(size, 4);
                n += Math.min(size, overlap) * 2;
            }
            var knots = [];
            for (var i = 0; i < size; i++)
                knots[i + overlap] = segments[i]._point;
            if (closed) {
                for (var i = 0; i < overlap; i++) {
                    knots[i] = segments[i + size - overlap]._point;
                    knots[i + size + overlap] = segments[i]._point;
                }
            } else {
                n--;
            }
            var rhs = [];

            for (var i = 1; i < n - 1; i++)
                rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
            rhs[0] = knots[0]._x + 2 * knots[1]._x;
            rhs[n - 1] = 3 * knots[n - 1]._x;
            var x = getFirstControlPoints(rhs);

            for (var i = 1; i < n - 1; i++)
                rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
            rhs[0] = knots[0]._y + 2 * knots[1]._y;
            rhs[n - 1] = 3 * knots[n - 1]._y;
            var y = getFirstControlPoints(rhs);

            if (closed) {
                for (var i = 0, j = size; i < overlap; i++, j++) {
                    var f1 = i / overlap,
                        f2 = 1 - f1,
                        ie = i + overlap,
                        je = j + overlap;
                    x[j] = x[i] * f1 + x[j] * f2;
                    y[j] = y[i] * f1 + y[j] * f2;
                    x[je] = x[ie] * f2 + x[je] * f1;
                    y[je] = y[ie] * f2 + y[je] * f1;
                }
                n--;
            }
            var handleIn = null;
            for (var i = overlap; i <= n - overlap; i++) {
                var segment = segments[i - overlap];
                if (handleIn)
                    segment.setHandleIn(handleIn.subtract(segment._point));
                if (i < n) {
                    segment.setHandleOut(
                            new Point(x[i], y[i]).subtract(segment._point));
                    handleIn = i < n - 1
                            ? new Point(
                                2 * knots[i + 1]._x - x[i + 1],
                                2 * knots[i + 1]._y - y[i + 1])
                            : new Point(
                                (knots[n]._x + x[n - 1]) / 2,
                                (knots[n]._y + y[n - 1]) / 2);
                }
            }
            if (closed && handleIn) {
                var segment = this._segments[0];
                segment.setHandleIn(handleIn.subtract(segment._point));
            }
        }
    };
}, new function() { 
    function getCurrentSegment(that) {
        var segments = that._segments;
        if (segments.length === 0)
            throw new Error('Use a moveTo() command first');
        return segments[segments.length - 1];
    }

    return {
        moveTo: function() {
            var segments = this._segments;
            if (segments.length === 1)
                this.removeSegment(0);
            if (!segments.length)
                this._add([ new Segment(Point.read(arguments)) ]);
        },

        moveBy: function() {
            throw new Error('moveBy() is unsupported on Path items.');
        },

        lineTo: function() {
            this._add([ new Segment(Point.read(arguments)) ]);
        },

        cubicCurveTo: function() {
            var handle1 = Point.read(arguments),
                handle2 = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this);
            current.setHandleOut(handle1.subtract(current._point));
            this._add([ new Segment(to, handle2.subtract(to)) ]);
        },

        quadraticCurveTo: function() {
            var handle = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.cubicCurveTo(
                handle.add(current.subtract(handle).multiply(1 / 3)),
                handle.add(to.subtract(handle).multiply(1 / 3)),
                to
            );
        },

        curveTo: function() {
            var through = Point.read(arguments),
                to = Point.read(arguments),
                t = Base.pick(Base.read(arguments), 0.5),
                t1 = 1 - t,
                current = getCurrentSegment(this)._point,
                handle = through.subtract(current.multiply(t1 * t1))
                    .subtract(to.multiply(t * t)).divide(2 * t * t1);
            if (handle.isNaN())
                throw new Error(
                    'Cannot put a curve through points with parameter = ' + t);
            this.quadraticCurveTo(handle, to);
        },

        arcTo: function() {
            var current = getCurrentSegment(this),
                from = current._point,
                to = Point.read(arguments),
                through,
                peek = Base.peek(arguments),
                clockwise = Base.pick(peek, true),
                center, extent, vector, matrix;
            if (typeof clockwise === 'boolean') {
                var middle = from.add(to).divide(2),
                through = middle.add(middle.subtract(from).rotate(
                        clockwise ? -90 : 90));
            } else if (Base.remain(arguments) <= 2) {
                through = to;
                to = Point.read(arguments);
            } else {
                var radius = Size.read(arguments);
                if (radius.isZero())
                    return this.lineTo(to);
                var rotation = Base.read(arguments),
                    clockwise = !!Base.read(arguments),
                    large = !!Base.read(arguments),
                    middle = from.add(to).divide(2),
                    pt = from.subtract(middle).rotate(-rotation),
                    x = pt.x,
                    y = pt.y,
                    abs = Math.abs,
                    EPSILON = 1e-11,
                    rx = abs(radius.width),
                    ry = abs(radius.height),
                    rxSq = rx * rx,
                    rySq = ry * ry,
                    xSq =  x * x,
                    ySq =  y * y;
                var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
                if (factor > 1) {
                    rx *= factor;
                    ry *= factor;
                    rxSq = rx * rx;
                    rySq = ry * ry;
                }
                factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
                        (rxSq * ySq + rySq * xSq);
                if (abs(factor) < EPSILON)
                    factor = 0;
                if (factor < 0)
                    throw new Error(
                            'Cannot create an arc with the given arguments');
                center = new Point(rx * y / ry, -ry * x / rx)
                        .multiply((large === clockwise ? -1 : 1)
                            * Math.sqrt(factor))
                        .rotate(rotation).add(middle);
                matrix = new Matrix().translate(center).rotate(rotation)
                        .scale(rx, ry);
                vector = matrix._inverseTransform(from);
                extent = vector.getDirectedAngle(matrix._inverseTransform(to));
                if (!clockwise && extent > 0)
                    extent -= 360;
                else if (clockwise && extent < 0)
                    extent += 360;
            }
            if (through) {
                var l1 = new Line(from.add(through).divide(2),
                            through.subtract(from).rotate(90), true),
                    l2 = new Line(through.add(to).divide(2),
                            to.subtract(through).rotate(90), true),
                    line = new Line(from, to),
                    throughSide = line.getSide(through);
                center = l1.intersect(l2, true);
                if (!center) {
                    if (!throughSide)
                        return this.lineTo(to);
                    throw new Error(
                            'Cannot create an arc with the given arguments');
                }
                vector = from.subtract(center);
                extent = vector.getDirectedAngle(to.subtract(center));
                var centerSide = line.getSide(center);
                if (centerSide === 0) {
                    extent = throughSide * Math.abs(extent);
                } else if (throughSide === centerSide) {
                    extent += extent < 0 ? 360 : -360;
                }
            }
            var ext = Math.abs(extent),
                count = ext >= 360 ? 4 : Math.ceil(ext / 90),
                inc = extent / count,
                half = inc * Math.PI / 360,
                z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
                segments = [];
            for (var i = 0; i <= count; i++) {
                var pt = to,
                    out = null;
                if (i < count) {
                    out = vector.rotate(90).multiply(z);
                    if (matrix) {
                        pt = matrix._transformPoint(vector);
                        out = matrix._transformPoint(vector.add(out))
                                .subtract(pt);
                    } else {
                        pt = center.add(vector);
                    }
                }
                if (i === 0) {
                    current.setHandleOut(out);
                } else {
                    var _in = vector.rotate(-90).multiply(z);
                    if (matrix) {
                        _in = matrix._transformPoint(vector.add(_in))
                                .subtract(pt);
                    }
                    segments.push(new Segment(pt, _in, out));
                }
                vector = vector.rotate(inc);
            }
            this._add(segments);
        },

        lineBy: function() {
            var to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.lineTo(current.add(to));
        },

        curveBy: function() {
            var through = Point.read(arguments),
                to = Point.read(arguments),
                parameter = Base.read(arguments),
                current = getCurrentSegment(this)._point;
            this.curveTo(current.add(through), current.add(to), parameter);
        },

        cubicCurveBy: function() {
            var handle1 = Point.read(arguments),
                handle2 = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.cubicCurveTo(current.add(handle1), current.add(handle2),
                    current.add(to));
        },

        quadraticCurveBy: function() {
            var handle = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.quadraticCurveTo(current.add(handle), current.add(to));
        },

        arcBy: function() {
            var current = getCurrentSegment(this)._point,
                point = current.add(Point.read(arguments)),
                clockwise = Base.pick(Base.peek(arguments), true);
            if (typeof clockwise === 'boolean') {
                this.arcTo(point, clockwise);
            } else {
                this.arcTo(point, current.add(Point.read(arguments)));
            }
        },

        closePath: function(join) {
            this.setClosed(true);
            if (join)
                this.join();
        }
    };
}, {  

    _getBounds: function(getter, matrix) {
        return Path[getter](this._segments, this._closed, this.getStyle(),
                matrix);
    },

statics: {
    isClockwise: function(segments) {
        var sum = 0;
        for (var i = 0, l = segments.length; i < l; i++) {
            var v = Curve.getValues(
                    segments[i], segments[i + 1 < l ? i + 1 : 0]);
            for (var j = 2; j < 8; j += 2)
                sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
        }
        return sum > 0;
    },

    getBounds: function(segments, closed, style, matrix, strokePadding) {
        var first = segments[0];
        if (!first)
            return new Rectangle();
        var coords = new Array(6),
            prevCoords = first._transformCoordinates(matrix, new Array(6), false),
            min = prevCoords.slice(0, 2), 
            max = min.slice(), 
            roots = new Array(2);

        function processSegment(segment) {
            segment._transformCoordinates(matrix, coords, false);
            for (var i = 0; i < 2; i++) {
                Curve._addBounds(
                    prevCoords[i], 
                    prevCoords[i + 4], 
                    coords[i + 2], 
                    coords[i], 
                    i, strokePadding ? strokePadding[i] : 0, min, max, roots);
            }
            var tmp = prevCoords;
            prevCoords = coords;
            coords = tmp;
        }

        for (var i = 1, l = segments.length; i < l; i++)
            processSegment(segments[i]);
        if (closed)
            processSegment(first);
        return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
    },

    getStrokeBounds: function(segments, closed, style, matrix) {
        if (!style.hasStroke())
            return Path.getBounds(segments, closed, style, matrix);
        var length = segments.length - (closed ? 0 : 1),
            radius = style.getStrokeWidth() / 2,
            padding = Path._getPenPadding(radius, matrix),
            bounds = Path.getBounds(segments, closed, style, matrix, padding),
            join = style.getStrokeJoin(),
            cap = style.getStrokeCap(),
            miterLimit = radius * style.getMiterLimit();
        var joinBounds = new Rectangle(new Size(padding).multiply(2));

        function add(point) {
            bounds = bounds.include(matrix
                ? matrix._transformPoint(point, point) : point);
        }

        function addRound(segment) {
            bounds = bounds.unite(joinBounds.setCenter(matrix
                ? matrix._transformPoint(segment._point) : segment._point));
        }

        function addJoin(segment, join) {
            var handleIn = segment._handleIn,
                handleOut = segment._handleOut;
            if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
                    && handleIn.isColinear(handleOut)) {
                addRound(segment);
            } else {
                Path._addBevelJoin(segment, join, radius, miterLimit, add);
            }
        }

        function addCap(segment, cap) {
            if (cap === 'round') {
                addRound(segment);
            } else {
                Path._addSquareCap(segment, cap, radius, add);
            }
        }

        for (var i = 1; i < length; i++)
            addJoin(segments[i], join);
        if (closed) {
            addJoin(segments[0], join);
        } else if (length > 0) {
            addCap(segments[0], cap);
            addCap(segments[segments.length - 1], cap);
        }
        return bounds;
    },

    _getPenPadding: function(radius, matrix) {
        if (!matrix)
            return [radius, radius];
        var mx = matrix.shiftless(),
            hor = mx.transform(new Point(radius, 0)),
            ver = mx.transform(new Point(0, radius)),
            phi = hor.getAngleInRadians(),
            a = hor.getLength(),
            b = ver.getLength();
        var sin = Math.sin(phi),
            cos = Math.cos(phi),
            tan = Math.tan(phi),
            tx = -Math.atan(b * tan / a),
            ty = Math.atan(b / (tan * a));
        return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
                Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
    },

    _addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
        var curve2 = segment.getCurve(),
            curve1 = curve2.getPrevious(),
            point = curve2.getPointAt(0, true),
            normal1 = curve1.getNormalAt(1, true),
            normal2 = curve2.getNormalAt(0, true),
            step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
        normal1.setLength(step);
        normal2.setLength(step);
        if (area) {
            addPoint(point);
            addPoint(point.add(normal1));
        }
        if (join === 'miter') {
            var corner = new Line(
                    point.add(normal1),
                    new Point(-normal1.y, normal1.x), true
                ).intersect(new Line(
                    point.add(normal2),
                    new Point(-normal2.y, normal2.x), true
                ), true);
            if (corner && point.getDistance(corner) <= miterLimit) {
                addPoint(corner);
                if (!area)
                    return;
            }
        }
        if (!area)
            addPoint(point.add(normal1));
        addPoint(point.add(normal2));
    },

    _addSquareCap: function(segment, cap, radius, addPoint, area) {
        var point = segment._point,
            loc = segment.getLocation(),
            normal = loc.getNormal().normalize(radius);
        if (area) {
            addPoint(point.subtract(normal));
            addPoint(point.add(normal));
        }
        if (cap === 'square')
            point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
        addPoint(point.add(normal));
        addPoint(point.subtract(normal));
    },

    getHandleBounds: function(segments, closed, style, matrix, strokePadding,
            joinPadding) {
        var coords = new Array(6),
            x1 = Infinity,
            x2 = -x1,
            y1 = x1,
            y2 = x2;
        for (var i = 0, l = segments.length; i < l; i++) {
            var segment = segments[i];
            segment._transformCoordinates(matrix, coords, false);
            for (var j = 0; j < 6; j += 2) {
                var padding = j === 0 ? joinPadding : strokePadding,
                    paddingX = padding ? padding[0] : 0,
                    paddingY = padding ? padding[1] : 0,
                    x = coords[j],
                    y = coords[j + 1],
                    xn = x - paddingX,
                    xx = x + paddingX,
                    yn = y - paddingY,
                    yx = y + paddingY;
                if (xn < x1) x1 = xn;
                if (xx > x2) x2 = xx;
                if (yn < y1) y1 = yn;
                if (yx > y2) y2 = yx;
            }
        }
        return new Rectangle(x1, y1, x2 - x1, y2 - y1);
    },

    getRoughBounds: function(segments, closed, style, matrix) {
        var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
            joinRadius = strokeRadius;
        if (strokeRadius > 0) {
            if (style.getStrokeJoin() === 'miter')
                joinRadius = strokeRadius * style.getMiterLimit();
            if (style.getStrokeCap() === 'square')
                joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
        }
        return Path.getHandleBounds(segments, closed, style, matrix,
                Path._getPenPadding(strokeRadius, matrix),
                Path._getPenPadding(joinRadius, matrix));
    }
}});

Path.inject({ statics: new function() {

    var kappa = 0.5522847498307936,
        ellipseSegments = [
            new Segment([-1, 0], [0, kappa ], [0, -kappa]),
            new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
            new Segment([1, 0], [0, -kappa], [0, kappa ]),
            new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
        ];

    function createPath(segments, closed, args) {
        var props = Base.getNamed(args),
            path = new Path(props && props.insert === false && Item.NO_INSERT);
        path._add(segments);
        path._closed = closed;
        return path.set(props);
    }

    function createEllipse(center, radius, args) {
        var segments = new Array(4);
        for (var i = 0; i < 4; i++) {
            var segment = ellipseSegments[i];
            segments[i] = new Segment(
                segment._point.multiply(radius).add(center),
                segment._handleIn.multiply(radius),
                segment._handleOut.multiply(radius)
            );
        }
        return createPath(segments, true, args);
    }

    return {
        Line: function() {
            return createPath([
                new Segment(Point.readNamed(arguments, 'from')),
                new Segment(Point.readNamed(arguments, 'to'))
            ], false, arguments);
        },

        Circle: function() {
            var center = Point.readNamed(arguments, 'center'),
                radius = Base.readNamed(arguments, 'radius');
            return createEllipse(center, new Size(radius), arguments);
        },

        Rectangle: function() {
            var rect = Rectangle.readNamed(arguments, 'rectangle'),
                radius = Size.readNamed(arguments, 'radius', 0,
                        { readNull: true }),
                bl = rect.getBottomLeft(true),
                tl = rect.getTopLeft(true),
                tr = rect.getTopRight(true),
                br = rect.getBottomRight(true),
                segments;
            if (!radius || radius.isZero()) {
                segments = [
                    new Segment(bl),
                    new Segment(tl),
                    new Segment(tr),
                    new Segment(br)
                ];
            } else {
                radius = Size.min(radius, rect.getSize(true).divide(2));
                var rx = radius.width,
                    ry = radius.height,
                    hx = rx * kappa,
                    hy = ry * kappa;
                segments = [
                    new Segment(bl.add(rx, 0), null, [-hx, 0]),
                    new Segment(bl.subtract(0, ry), [0, hy]),
                    new Segment(tl.add(0, ry), null, [0, -hy]),
                    new Segment(tl.add(rx, 0), [-hx, 0], null),
                    new Segment(tr.subtract(rx, 0), null, [hx, 0]),
                    new Segment(tr.add(0, ry), [0, -hy], null),
                    new Segment(br.subtract(0, ry), null, [0, hy]),
                    new Segment(br.subtract(rx, 0), [hx, 0])
                ];
            }
            return createPath(segments, true, arguments);
        },

        RoundRectangle: '#Rectangle',

        Ellipse: function() {
            var ellipse = Shape._readEllipse(arguments);
            return createEllipse(ellipse.center, ellipse.radius, arguments);
        },

        Oval: '#Ellipse',

        Arc: function() {
            var from = Point.readNamed(arguments, 'from'),
                through = Point.readNamed(arguments, 'through'),
                to = Point.readNamed(arguments, 'to'),
                props = Base.getNamed(arguments),
                path = new Path(props && props.insert === false
                        && Item.NO_INSERT);
            path.moveTo(from);
            path.arcTo(through, to);
            return path.set(props);
        },

        RegularPolygon: function() {
            var center = Point.readNamed(arguments, 'center'),
                sides = Base.readNamed(arguments, 'sides'),
                radius = Base.readNamed(arguments, 'radius'),
                step = 360 / sides,
                three = !(sides % 3),
                vector = new Point(0, three ? -radius : radius),
                offset = three ? -1 : 0.5,
                segments = new Array(sides);
            for (var i = 0; i < sides; i++)
                segments[i] = new Segment(center.add(
                    vector.rotate((i + offset) * step)));
            return createPath(segments, true, arguments);
        },

        Star: function() {
            var center = Point.readNamed(arguments, 'center'),
                points = Base.readNamed(arguments, 'points') * 2,
                radius1 = Base.readNamed(arguments, 'radius1'),
                radius2 = Base.readNamed(arguments, 'radius2'),
                step = 360 / points,
                vector = new Point(0, -1),
                segments = new Array(points);
            for (var i = 0; i < points; i++)
                segments[i] = new Segment(center.add(vector.rotate(step * i)
                        .multiply(i % 2 ? radius2 : radius1)));
            return createPath(segments, true, arguments);
        }
    };
}});

var CompoundPath = PathItem.extend({
    _class: 'CompoundPath',
    _serializeFields: {
        children: []
    },

    initialize: function CompoundPath(arg) {
        this._children = [];
        this._namedChildren = {};
        if (!this._initialize(arg)) {
            if (typeof arg === 'string') {
                this.setPathData(arg);
            } else {
                this.addChildren(Array.isArray(arg) ? arg : arguments);
            }
        }
    },

    insertChildren: function insertChildren(index, items, _preserve) {
        items = insertChildren.base.call(this, index, items, _preserve, Path);
        for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
            var item = items[i];
            if (item._clockwise === undefined)
                item.setClockwise(item._index === 0);
        }
        return items;
    },

    reverse: function() {
        var children = this._children;
        for (var i = 0, l = children.length; i < l; i++)
            children[i].reverse();
    },

    smooth: function() {
        for (var i = 0, l = this._children.length; i < l; i++)
            this._children[i].smooth();
    },

    isClockwise: function() {
        var child = this.getFirstChild();
        return child && child.isClockwise();
    },

    setClockwise: function(clockwise) {
        if (this.isClockwise() !== !!clockwise)
            this.reverse();
    },

    getFirstSegment: function() {
        var first = this.getFirstChild();
        return first && first.getFirstSegment();
    },

    getLastSegment: function() {
        var last = this.getLastChild();
        return last && last.getLastSegment();
    },

    getCurves: function() {
        var children = this._children,
            curves = [];
        for (var i = 0, l = children.length; i < l; i++)
            curves.push.apply(curves, children[i].getCurves());
        return curves;
    },

    getFirstCurve: function() {
        var first = this.getFirstChild();
        return first && first.getFirstCurve();
    },

    getLastCurve: function() {
        var last = this.getLastChild();
        return last && last.getFirstCurve();
    },

    getArea: function() {
        var children = this._children,
            area = 0;
        for (var i = 0, l = children.length; i < l; i++)
            area += children[i].getArea();
        return area;
    }
}, {
    beans: true,

    getPathData: function(_matrix, _precision) {
        var children = this._children,
            paths = [];
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i],
                mx = child._matrix;
            paths.push(child.getPathData(_matrix && !mx.isIdentity()
                    ? _matrix.chain(mx) : mx, _precision));
        }
        return paths.join(' ');
    }
}, {
    _getChildHitTestOptions: function(options) {
        return options.class === Path || options.type === 'path'
                ? options
                : new Base(options, { fill: false });
    },

    _draw: function(ctx, param, strokeMatrix) {
        var children = this._children;
        if (children.length === 0)
            return;

        if (this._currentPath) {
            ctx.currentPath = this._currentPath;
        } else {
            param = param.extend({ dontStart: true, dontFinish: true });
            ctx.beginPath();
            for (var i = 0, l = children.length; i < l; i++)
                children[i].draw(ctx, param, strokeMatrix);
            this._currentPath = ctx.currentPath;
        }

        if (!param.clip) {
            this._setStyles(ctx);
            var style = this._style;
            if (style.hasFill()) {
                ctx.fill(style.getWindingRule());
                ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (style.hasStroke())
                ctx.stroke();
        }
    },

    _drawSelected: function(ctx, matrix, selectedItems) {
        var children = this._children;
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i],
                mx = child._matrix;
            if (!selectedItems[child._id])
                child._drawSelected(ctx, mx.isIdentity() ? matrix
                        : matrix.chain(mx));
        }
    }
}, new function() { 
    function getCurrentPath(that, check) {
        var children = that._children;
        if (check && children.length === 0)
            throw new Error('Use a moveTo() command first');
        return children[children.length - 1];
    }

    var fields = {
        moveTo: function() {
            var current = getCurrentPath(this),
                path = current && current.isEmpty() ? current : new Path();
            if (path !== current)
                this.addChild(path);
            path.moveTo.apply(path, arguments);
        },

        moveBy: function() {
            var current = getCurrentPath(this, true),
                last = current && current.getLastSegment(),
                point = Point.read(arguments);
            this.moveTo(last ? point.add(last._point) : point);
        },

        closePath: function(join) {
            getCurrentPath(this, true).closePath(join);
        }
    };

    Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
            'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
            function(key) {
                fields[key] = function() {
                    var path = getCurrentPath(this, true);
                    path[key].apply(path, arguments);
                };
            }
    );

    return fields;
});

PathItem.inject(new function() {
    function computeBoolean(path1, path2, operator, subtract) {
        function preparePath(path) {
            return path.clone(false).reduce().reorient().transform(null, true);
        }

        var _path1 = preparePath(path1),
            _path2 = path2 && path1 !== path2 && preparePath(path2);
        if (!_path1.isClockwise())
            _path1.reverse();
        if (_path2 && !(subtract ^ _path2.isClockwise()))
            _path2.reverse();
        splitPath(_path1.getIntersections(_path2, null, true));

        var chain = [],
            windings = [],
            lengths = [],
            segments = [],
            monoCurves = [];

        function collect(paths) {
            for (var i = 0, l = paths.length; i < l; i++) {
                var path = paths[i];
                segments.push.apply(segments, path._segments);
                monoCurves.push.apply(monoCurves, path._getMonoCurves());
            }
        }

        collect(_path1._children || [_path1]);
        if (_path2)
            collect(_path2._children || [_path2]);
        segments.sort(function(a, b) {
            var _a = a._intersection,
                _b = b._intersection;
            return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
        });
        for (var i = 0, l = segments.length; i < l; i++) {
            var segment = segments[i];
            if (segment._winding != null)
                continue;
            chain.length = windings.length = lengths.length = 0;
            var totalLength = 0,
                startSeg = segment;
            do {
                chain.push(segment);
                lengths.push(totalLength += segment.getCurve().getLength());
                segment = segment.getNext();
            } while (segment && !segment._intersection && segment !== startSeg);
            for (var j = 0; j < 3; j++) {
                var length = totalLength * Math.random(),
                    amount = lengths.length,
                    k = 0;
                do {
                    if (lengths[k] >= length) {
                        if (k > 0)
                            length -= lengths[k - 1];
                        break;
                    }
                } while (++k < amount);
                var curve = chain[k].getCurve(),
                    point = curve.getPointAt(length),
                    hor = curve.isHorizontal(),
                    path = curve._path;
                if (path._parent instanceof CompoundPath)
                    path = path._parent;
                windings[j] = subtract && _path2
                        && (path === _path1 && _path2._getWinding(point, hor)
                        || path === _path2 && !_path1._getWinding(point, hor))
                        ? 0
                        : getWinding(point, monoCurves, hor);
            }
            windings.sort();
            var winding = windings[1];
            for (var j = chain.length - 1; j >= 0; j--)
                chain[j]._winding = winding;
        }
        var result = new CompoundPath();
        result.addChildren(tracePaths(segments, operator), true);
        _path1.remove();
        if (_path2)
            _path2.remove();
        result = result.reduce();
        result.setStyle(path1._style);
        return result;
    }

    function splitPath(intersections) {
        var TOLERANCE = 0.00001,
            linearSegments;

        function resetLinear() {
            for (var i = 0, l = linearSegments.length; i < l; i++) {
                var segment = linearSegments[i];
                segment._handleOut.set(0, 0);
                segment._handleIn.set(0, 0);
            }
        }

        for (var i = intersections.length - 1, curve, prevLoc; i >= 0; i--) {
            var loc = intersections[i],
                t = loc._parameter;
            if (prevLoc && prevLoc._curve === loc._curve
                    && prevLoc._parameter > 0) {
                t /= prevLoc._parameter;
            } else {
                if (linearSegments)
                    resetLinear();
                curve = loc._curve;
                linearSegments = curve.isLinear() && [];
            }
            var newCurve,
                segment;
            if (newCurve = curve.divide(t, true, true)) {
                segment = newCurve._segment1;
                curve = newCurve.getPrevious();
            } else {
                segment = t < TOLERANCE
                    ? curve._segment1
                    : t > 1 - TOLERANCE
                        ? curve._segment2
                        : curve.getPartLength(0, t) < curve.getPartLength(t, 1)
                            ? curve._segment1
                            : curve._segment2;
            }
            segment._intersection = loc.getIntersection();
            loc._segment = segment;
            if (linearSegments)
                linearSegments.push(segment);
            prevLoc = loc;
        }
        if (linearSegments)
            resetLinear();
    }

    function getWinding(point, curves, horizontal, testContains) {
        var TOLERANCE = 0.00001,
            x = point.x,
            y = point.y,
            windLeft = 0,
            windRight = 0,
            roots = [],
            abs = Math.abs,
            MAX = 1 - TOLERANCE;
        if (horizontal) {
            var yTop = -Infinity,
                yBottom = Infinity,
                yBefore = y - TOLERANCE,
                yAfter = y + TOLERANCE;
            for (var i = 0, l = curves.length; i < l; i++) {
                var values = curves[i].values;
                if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0) {
                    for (var j = roots.length - 1; j >= 0; j--) {
                        var y0 = Curve.evaluate(values, roots[j], 0).y;
                        if (y0 < yBefore && y0 > yTop) {
                            yTop = y0;
                        } else if (y0 > yAfter && y0 < yBottom) {
                            yBottom = y0;
                        }
                    }
                }
            }
            yTop = (yTop + y) / 2;
            yBottom = (yBottom + y) / 2;
            if (yTop > -Infinity)
                windLeft = getWinding(new Point(x, yTop), curves);
            if (yBottom < Infinity)
                windRight = getWinding(new Point(x, yBottom), curves);
        } else {
            var xBefore = x - TOLERANCE,
                xAfter = x + TOLERANCE;
            for (var i = 0, l = curves.length; i < l; i++) {
                var curve = curves[i],
                    values = curve.values,
                    winding = curve.winding,
                    next = curve.next;
                if (winding && (winding === 1
                        && y >= values[1] && y <= values[7]
                        || y >= values[7] && y <= values[1])
                    && Curve.solveCubic(values, 1, y, roots, 0,
                        !next.winding && next.values[1] === y ? 1 : MAX) === 1){
                    var t = roots[0],
                        x0 = Curve.evaluate(values, t, 0).x,
                        slope = Curve.evaluate(values, t, 1).y;
                    if (abs(slope) < TOLERANCE && !Curve.isLinear(values)
                            || t < TOLERANCE && slope * Curve.evaluate(
                                curve.previous.values, t, 1).y < 0) {
                        if (testContains && x0 >= xBefore && x0 <= xAfter) {
                            ++windLeft;
                            ++windRight;
                        }
                    } else if (x0 <= xBefore) {
                        windLeft += winding;
                    } else if (x0 >= xAfter) {
                        windRight += winding;
                    }
                }
            }
        }
        return Math.max(abs(windLeft), abs(windRight));
    }

    function tracePaths(segments, operator, selfOp) {
        operator = operator || function() {
            return true;
        };
        var paths = [],
            ZERO = 1e-3,
            ONE = 1 - 1e-3;
        for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
            seg = startSeg = segments[i];
            if (seg._visited || !operator(seg._winding))
                continue;
            var path = new Path(Item.NO_INSERT),
                inter = seg._intersection,
                startInterSeg = inter && inter._segment,
                added = false, 
                dir = 1;
            do {
                var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
                    handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
                    interSeg;
                if (added && (!operator(seg._winding) || selfOp)
                        && (inter = seg._intersection)
                        && (interSeg = inter._segment)
                        && interSeg !== startSeg) {
                    if (selfOp) {
                        seg._visited = interSeg._visited;
                        seg = interSeg;
                        dir = 1;
                    } else {
                        var c1 = seg.getCurve();
                        if (dir > 0)
                            c1 = c1.getPrevious();
                        var t1 = c1.getTangentAt(dir < 1 ? ZERO : ONE, true),
                            c4 = interSeg.getCurve(),
                            c3 = c4.getPrevious(),
                            t3 = c3.getTangentAt(ONE, true),
                            t4 = c4.getTangentAt(ZERO, true),
                            w3 = t1.cross(t3),
                            w4 = t1.cross(t4);
                        if (w3 * w4 !== 0) {
                            var curve = w3 < w4 ? c3 : c4,
                                nextCurve = operator(curve._segment1._winding)
                                    ? curve
                                    : w3 < w4 ? c4 : c3,
                                nextSeg = nextCurve._segment1;
                            dir = nextCurve === c3 ? -1 : 1;
                            if (nextSeg._visited && seg._path !== nextSeg._path
                                        || !operator(nextSeg._winding)) {
                                dir = 1;
                            } else {
                                seg._visited = interSeg._visited;
                                seg = interSeg;
                                if (nextSeg._visited)
                                    dir = 1;
                            }
                        } else {
                            dir = 1;
                        }
                    }
                    handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
                }
                path.add(new Segment(seg._point, added && handleIn, handleOut));
                added = true;
                seg._visited = true;
                seg = dir > 0 ? seg.getNext() : seg. getPrevious();
            } while (seg && !seg._visited
                    && seg !== startSeg && seg !== startInterSeg
                    && (seg._intersection || operator(seg._winding)));
            if (seg && (seg === startSeg || seg === startInterSeg)) {
                path.firstSegment.setHandleIn((seg === startInterSeg
                        ? startInterSeg : seg)._handleIn);
                path.setClosed(true);
            } else {
                path.lastSegment._handleOut.set(0, 0);
            }
            if (path._segments.length >
                    (path._closed ? path.isPolygon() ? 2 : 0 : 1))
                paths.push(path);
        }
        return paths;
    }

    return {
        _getWinding: function(point, horizontal, testContains) {
            return getWinding(point, this._getMonoCurves(),
                    horizontal, testContains);
        },

        unite: function(path) {
            return computeBoolean(this, path, function(w) {
                return w === 1 || w === 0;
            }, false);
        },

        intersect: function(path) {
            return computeBoolean(this, path, function(w) {
                return w === 2;
            }, false);
        },

        subtract: function(path) {
            return computeBoolean(this, path, function(w) {
                return w === 1;
            }, true);
        },

        exclude: function(path) {
            return new Group([this.subtract(path), path.subtract(this)]);
        },

        divide: function(path) {
            return new Group([this.subtract(path), this.intersect(path)]);
        }
    };
});

Path.inject({
    _getMonoCurves: function() {
        var monoCurves = this._monoCurves,
            prevCurve;

        function insertCurve(v) {
            var y0 = v[1],
                y1 = v[7],
                curve = {
                    values: v,
                    winding: y0 === y1
                        ? 0 
                        : y0 > y1
                            ? -1 
                            : 1, 
                    previous: prevCurve,
                    next: null 
                };
            if (prevCurve)
                prevCurve.next = curve;
            monoCurves.push(curve);
            prevCurve = curve;
        }

        function handleCurve(v) {
            if (Curve.getLength(v) === 0)
                return;
            var y0 = v[1],
                y1 = v[3],
                y2 = v[5],
                y3 = v[7];
            if (Curve.isLinear(v)) {
                insertCurve(v);
            } else {
                var a = 3 * (y1 - y2) - y0 + y3,
                    b = 2 * (y0 + y2) - 4 * y1,
                    c = y1 - y0,
                    TOLERANCE = 0.00001,
                    roots = [];
                var count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE,
                        1 - TOLERANCE);
                if (count === 0) {
                    insertCurve(v);
                } else {
                    roots.sort();
                    var t = roots[0],
                        parts = Curve.subdivide(v, t);
                    insertCurve(parts[0]);
                    if (count > 1) {
                        t = (roots[1] - t) / (1 - t);
                        parts = Curve.subdivide(parts[1], t);
                        insertCurve(parts[0]);
                    }
                    insertCurve(parts[1]);
                }
            }
        }

        if (!monoCurves) {
            monoCurves = this._monoCurves = [];
            var curves = this.getCurves(),
                segments = this._segments;
            for (var i = 0, l = curves.length; i < l; i++)
                handleCurve(curves[i].getValues());
            if (!this._closed && segments.length > 1) {
                var p1 = segments[segments.length - 1]._point,
                    p2 = segments[0]._point,
                    p1x = p1._x, p1y = p1._y,
                    p2x = p2._x, p2y = p2._y;
                handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
            }
            if (monoCurves.length > 0) {
                var first = monoCurves[0],
                    last = monoCurves[monoCurves.length - 1];
                first.previous = last;
                last.next = first;
            }
        }
        return monoCurves;
    },

    getInteriorPoint: function() {
        var bounds = this.getBounds(),
            point = bounds.getCenter(true);
        if (!this.contains(point)) {
            var curves = this._getMonoCurves(),
                roots = [],
                y = point.y,
                xIntercepts = [];
            for (var i = 0, l = curves.length; i < l; i++) {
                var values = curves[i].values;
                if ((curves[i].winding === 1
                        && y >= values[1] && y <= values[7]
                        || y >= values[7] && y <= values[1])
                        && Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
                    for (var j = roots.length - 1; j >= 0; j--)
                        xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
                }
                if (xIntercepts.length > 1)
                    break;
            }
            point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
        }
        return point;
    },

    reorient: function() {
        this.setClockwise(true);
        return this;
    }
});

CompoundPath.inject({
    _getMonoCurves: function() {
        var children = this._children,
            monoCurves = [];
        for (var i = 0, l = children.length; i < l; i++)
            monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
        return monoCurves;
    },

    reorient: function() {
        var children = this.removeChildren().sort(function(a, b) {
            return b.getBounds().getArea() - a.getBounds().getArea();
        });
        this.addChildren(children);
        var clockwise = children[0].isClockwise();
        for (var i = 1, l = children.length; i < l; i++) { 
            var point = children[i].getInteriorPoint(),
                counters = 0;
            for (var j = i - 1; j >= 0; j--) {
                if (children[j].contains(point))
                    counters++;
            }
            children[i].setClockwise(counters % 2 === 0 && clockwise);
        }
        return this;
    }
});

var PathIterator = Base.extend({
    _class: 'PathIterator',

    initialize: function(path, maxRecursion, tolerance, matrix) {
        var curves = [], 
            parts = [], 
            length = 0, 
            minDifference = 1 / (maxRecursion || 32),
            segments = path._segments,
            segment1 = segments[0],
            segment2;

        function addCurve(segment1, segment2) {
            var curve = Curve.getValues(segment1, segment2, matrix);
            curves.push(curve);
            computeParts(curve, segment1._index, 0, 1);
        }

        function computeParts(curve, index, minT, maxT) {
            if ((maxT - minT) > minDifference
                    && !Curve.isFlatEnough(curve, tolerance || 0.25)) {
                var split = Curve.subdivide(curve),
                    halfT = (minT + maxT) / 2;
                computeParts(split[0], index, minT, halfT);
                computeParts(split[1], index, halfT, maxT);
            } else {
                var x = curve[6] - curve[0],
                    y = curve[7] - curve[1],
                    dist = Math.sqrt(x * x + y * y);
                if (dist > 0.00001) {
                    length += dist;
                    parts.push({
                        offset: length,
                        value: maxT,
                        index: index
                    });
                }
            }
        }

        for (var i = 1, l = segments.length; i < l; i++) {
            segment2 = segments[i];
            addCurve(segment1, segment2);
            segment1 = segment2;
        }
        if (path._closed)
            addCurve(segment2, segments[0]);

        this.curves = curves;
        this.parts = parts;
        this.length = length;
        this.index = 0;
    },

    getParameterAt: function(offset) {
        var i, j = this.index;
        for (;;) {
            i = j;
            if (j == 0 || this.parts[--j].offset < offset)
                break;
        }
        for (var l = this.parts.length; i < l; i++) {
            var part = this.parts[i];
            if (part.offset >= offset) {
                this.index = i;
                var prev = this.parts[i - 1];
                var prevVal = prev && prev.index == part.index ? prev.value : 0,
                    prevLen = prev ? prev.offset : 0;
                return {
                    value: prevVal + (part.value - prevVal)
                        * (offset - prevLen) / (part.offset - prevLen),
                    index: part.index
                };
            }
        }
        var part = this.parts[this.parts.length - 1];
        return {
            value: 1,
            index: part.index
        };
    },

    evaluate: function(offset, type) {
        var param = this.getParameterAt(offset);
        return Curve.evaluate(this.curves[param.index], param.value, type);
    },

    drawPart: function(ctx, from, to) {
        from = this.getParameterAt(from);
        to = this.getParameterAt(to);
        for (var i = from.index; i <= to.index; i++) {
            var curve = Curve.getPart(this.curves[i],
                    i == from.index ? from.value : 0,
                    i == to.index ? to.value : 1);
            if (i == from.index)
                ctx.moveTo(curve[0], curve[1]);
            ctx.bezierCurveTo.apply(ctx, curve.slice(2));
        }
    }
}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
    function(name, index) {
        this[name + 'At'] = function(offset) {
            return this.evaluate(offset, index);
        };
    }, {})
);

var PathFitter = Base.extend({
    initialize: function(path, error) {
        this.points = [];
        var segments = path._segments,
            prev;
        for (var i = 0, l = segments.length; i < l; i++) {
            var point = segments[i].point.clone();
            if (!prev || !prev.equals(point)) {
                this.points.push(point);
                prev = point;
            }
        }
        this.error = error;
    },

    fit: function() {
        var points = this.points,
            length = points.length;
        this.segments = length > 0 ? [new Segment(points[0])] : [];
        if (length > 1)
            this.fitCubic(0, length - 1,
                points[1].subtract(points[0]).normalize(),
                points[length - 2].subtract(points[length - 1]).normalize());
        return this.segments;
    },

    fitCubic: function(first, last, tan1, tan2) {
        if (last - first == 1) {
            var pt1 = this.points[first],
                pt2 = this.points[last],
                dist = pt1.getDistance(pt2) / 3;
            this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
                    pt2.add(tan2.normalize(dist)), pt2]);
            return;
        }
        var uPrime = this.chordLengthParameterize(first, last),
            maxError = Math.max(this.error, this.error * this.error),
            split;
        for (var i = 0; i <= 4; i++) {
            var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
            var max = this.findMaxError(first, last, curve, uPrime);
            if (max.error < this.error) {
                this.addCurve(curve);
                return;
            }
            split = max.index;
            if (max.error >= maxError)
                break;
            this.reparameterize(first, last, uPrime, curve);
            maxError = max.error;
        }
        var V1 = this.points[split - 1].subtract(this.points[split]),
            V2 = this.points[split].subtract(this.points[split + 1]),
            tanCenter = V1.add(V2).divide(2).normalize();
        this.fitCubic(first, split, tan1, tanCenter);
        this.fitCubic(split, last, tanCenter.negate(), tan2);
    },

    addCurve: function(curve) {
        var prev = this.segments[this.segments.length - 1];
        prev.setHandleOut(curve[1].subtract(curve[0]));
        this.segments.push(
                new Segment(curve[3], curve[2].subtract(curve[3])));
    },

    generateBezier: function(first, last, uPrime, tan1, tan2) {
        var epsilon = 1e-11,
            pt1 = this.points[first],
            pt2 = this.points[last],
            C = [[0, 0], [0, 0]],
            X = [0, 0];

        for (var i = 0, l = last - first + 1; i < l; i++) {
            var u = uPrime[i],
                t = 1 - u,
                b = 3 * u * t,
                b0 = t * t * t,
                b1 = b * t,
                b2 = b * u,
                b3 = u * u * u,
                a1 = tan1.normalize(b1),
                a2 = tan2.normalize(b2),
                tmp = this.points[first + i]
                    .subtract(pt1.multiply(b0 + b1))
                    .subtract(pt2.multiply(b2 + b3));
            C[0][0] += a1.dot(a1);
            C[0][1] += a1.dot(a2);
            C[1][0] = C[0][1];
            C[1][1] += a2.dot(a2);
            X[0] += a1.dot(tmp);
            X[1] += a2.dot(tmp);
        }

        var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
            alpha1, alpha2;
        if (Math.abs(detC0C1) > epsilon) {
            var detC0X  = C[0][0] * X[1]    - C[1][0] * X[0],
                detXC1  = X[0]    * C[1][1] - X[1]    * C[0][1];
            alpha1 = detXC1 / detC0C1;
            alpha2 = detC0X / detC0C1;
        } else {
            var c0 = C[0][0] + C[0][1],
                c1 = C[1][0] + C[1][1];
            if (Math.abs(c0) > epsilon) {
                alpha1 = alpha2 = X[0] / c0;
            } else if (Math.abs(c1) > epsilon) {
                alpha1 = alpha2 = X[1] / c1;
            } else {
                alpha1 = alpha2 = 0;
            }
        }

        var segLength = pt2.getDistance(pt1);
        epsilon *= segLength;
        if (alpha1 < epsilon || alpha2 < epsilon) {
            alpha1 = alpha2 = segLength / 3;
        }

        return [pt1, pt1.add(tan1.normalize(alpha1)),
                pt2.add(tan2.normalize(alpha2)), pt2];
    },

    reparameterize: function(first, last, u, curve) {
        for (var i = first; i <= last; i++) {
            u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
        }
    },

    findRoot: function(curve, point, u) {
        var curve1 = [],
            curve2 = [];
        for (var i = 0; i <= 2; i++) {
            curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
        }
        for (var i = 0; i <= 1; i++) {
            curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
        }
        var pt = this.evaluate(3, curve, u),
            pt1 = this.evaluate(2, curve1, u),
            pt2 = this.evaluate(1, curve2, u),
            diff = pt.subtract(point),
            df = pt1.dot(pt1) + diff.dot(pt2);
        if (Math.abs(df) < 0.00001)
            return u;
        return u - diff.dot(pt1) / df;
    },

    evaluate: function(degree, curve, t) {
        var tmp = curve.slice();
        for (var i = 1; i <= degree; i++) {
            for (var j = 0; j <= degree - i; j++) {
                tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
            }
        }
        return tmp[0];
    },

    chordLengthParameterize: function(first, last) {
        var u = [0];
        for (var i = first + 1; i <= last; i++) {
            u[i - first] = u[i - first - 1]
                    + this.points[i].getDistance(this.points[i - 1]);
        }
        for (var i = 1, m = last - first; i <= m; i++) {
            u[i] /= u[m];
        }
        return u;
    },

    findMaxError: function(first, last, curve, u) {
        var index = Math.floor((last - first + 1) / 2),
            maxDist = 0;
        for (var i = first + 1; i < last; i++) {
            var P = this.evaluate(3, curve, u[i - first]);
            var v = P.subtract(this.points[i]);
            var dist = v.x * v.x + v.y * v.y; 
            if (dist >= maxDist) {
                maxDist = dist;
                index = i;
            }
        }
        return {
            error: maxDist,
            index: index
        };
    }
});

var TextItem = Item.extend({
    _class: 'TextItem',
    _boundsSelected: true,
    _applyMatrix: false,
    _canApplyMatrix: false,
    _serializeFields: {
        content: null
    },
    _boundsGetter: 'getBounds',

    initialize: function TextItem(arg) {
        this._content = '';
        this._lines = [];
        var hasProps = arg && Base.isPlainObject(arg)
                && arg.x === undefined && arg.y === undefined;
        this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
    },

    _equals: function(item) {
        return this._content === item._content;
    },

    _clone: function _clone(copy) {
        copy.setContent(this._content);
        return _clone.base.call(this, copy);
    },

    getContent: function() {
        return this._content;
    },

    setContent: function(content) {
        this._content = '' + content;
        this._lines = this._content.split(/\r\n|\n|\r/mg);
        this._changed(265);
    },

    isEmpty: function() {
        return !this._content;
    },

    getCharacterStyle: '#getStyle',
    setCharacterStyle: '#setStyle',

    getParagraphStyle: '#getStyle',
    setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
    _class: 'PointText',

    initialize: function PointText() {
        TextItem.apply(this, arguments);
    },

    clone: function(insert) {
        return this._clone(new PointText(Item.NO_INSERT), insert);
    },

    getPoint: function() {
        var point = this._matrix.getTranslation();
        return new LinkedPoint(point.x, point.y, this, 'setPoint');
    },

    setPoint: function() {
        var point = Point.read(arguments);
        this.translate(point.subtract(this._matrix.getTranslation()));
    },

    _draw: function(ctx) {
        if (!this._content)
            return;
        this._setStyles(ctx);
        var style = this._style,
            lines = this._lines,
            leading = style.getLeading(),
            shadowColor = ctx.shadowColor;
        ctx.font = style.getFontStyle();
        ctx.textAlign = style.getJustification();
        for (var i = 0, l = lines.length; i < l; i++) {
            ctx.shadowColor = shadowColor;
            var line = lines[i];
            if (style.hasFill()) {
                ctx.fillText(line, 0, 0);
                ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (style.hasStroke())
                ctx.strokeText(line, 0, 0);
            ctx.translate(0, leading);
        }
    },

    _getBounds: function(getter, matrix) {
        var style = this._style,
            lines = this._lines,
            numLines = lines.length,
            justification = style.getJustification(),
            leading = style.getLeading(),
            width = this.getView().getTextWidth(style.getFontStyle(), lines),
            x = 0;
        if (justification !== 'left')
            x -= width / (justification === 'center' ? 2: 1);
        var bounds = new Rectangle(x,
                    numLines ? - 0.75 * leading : 0,
                    width, numLines * leading);
        return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
    }
});

var Color = Base.extend(new function() {
    var types = {
        gray: ['gray'],
        rgb: ['red', 'green', 'blue'],
        hsb: ['hue', 'saturation', 'brightness'],
        hsl: ['hue', 'saturation', 'lightness'],
        gradient: ['gradient', 'origin', 'destination', 'highlight']
    };

    var componentParsers = {},
        colorCache = {},
        colorCtx;

    function fromCSS(string) {
        var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
            components;
        if (match) {
            components = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
                var value = match[i + 1];
                components[i] = parseInt(value.length == 1
                        ? value + value : value, 16) / 255;
            }
        } else if (match = string.match(/^rgba?\((.*)\)$/)) {
            components = match[1].split(',');
            for (var i = 0, l = components.length; i < l; i++) {
                var value = +components[i];
                components[i] = i < 3 ? value / 255 : value;
            }
        } else {
            var cached = colorCache[string];
            if (!cached) {
                if (!colorCtx) {
                    colorCtx = CanvasProvider.getContext(1, 1);
                    colorCtx.globalCompositeOperation = 'copy';
                }
                colorCtx.fillStyle = 'rgba(0,0,0,0)';
                colorCtx.fillStyle = string;
                colorCtx.fillRect(0, 0, 1, 1);
                var data = colorCtx.getImageData(0, 0, 1, 1).data;
                cached = colorCache[string] = [
                    data[0] / 255,
                    data[1] / 255,
                    data[2] / 255
                ];
            }
            components = cached.slice();
        }
        return components;
    }

    var hsbIndices = [
        [0, 3, 1], 
        [2, 0, 1], 
        [1, 0, 3], 
        [1, 2, 0], 
        [3, 1, 0], 
        [0, 1, 2]  
    ];

    var converters = {
        'rgb-hsb': function(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                h = delta === 0 ? 0
                    :   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
                        : max == g ? (b - r) / delta + 2
                        :            (r - g) / delta + 4) * 60; 
            return [h, max === 0 ? 0 : delta / max, max];
        },

        'hsb-rgb': function(h, s, b) {
            h = (((h / 60) % 6) + 6) % 6;
            var i = Math.floor(h), 
                f = h - i,
                i = hsbIndices[i],
                v = [
                    b,                      
                    b * (1 - s),            
                    b * (1 - s * f),        
                    b * (1 - s * (1 - f))   
                ];
            return [v[i[0]], v[i[1]], v[i[2]]];
        },

        'rgb-hsl': function(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                achromatic = delta === 0,
                h = achromatic ? 0
                    :   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
                        : max == g ? (b - r) / delta + 2
                        :            (r - g) / delta + 4) * 60, 
                l = (max + min) / 2,
                s = achromatic ? 0 : l < 0.5
                        ? delta / (max + min)
                        : delta / (2 - max - min);
            return [h, s, l];
        },

        'hsl-rgb': function(h, s, l) {
            h = (((h / 360) % 1) + 1) % 1;
            if (s === 0)
                return [l, l, l];
            var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
                t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
                t1 = 2 * l - t2,
                c = [];
            for (var i = 0; i < 3; i++) {
                var t3 = t3s[i];
                if (t3 < 0) t3 += 1;
                if (t3 > 1) t3 -= 1;
                c[i] = 6 * t3 < 1
                    ? t1 + (t2 - t1) * 6 * t3
                    : 2 * t3 < 1
                        ? t2
                        : 3 * t3 < 2
                            ? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
                            : t1;
            }
            return c;
        },

        'rgb-gray': function(r, g, b) {
            return [r * 0.2989 + g * 0.587 + b * 0.114];
        },

        'gray-rgb': function(g) {
            return [g, g, g];
        },

        'gray-hsb': function(g) {
            return [0, 0, g];
        },

        'gray-hsl': function(g) {
            return [0, 0, g];
        },

        'gradient-rgb': function() {
            return [];
        },

        'rgb-gradient': function() {
            return [];
        }

    };

    return Base.each(types, function(properties, type) {
        componentParsers[type] = [];
        Base.each(properties, function(name, index) {
            var part = Base.capitalize(name),
                hasOverlap = /^(hue|saturation)$/.test(name),
                parser = componentParsers[type][index] = name === 'gradient'
                    ? function(value) {
                        var current = this._components[0];
                        value = Gradient.read(Array.isArray(value) ? value
                                : arguments, 0, { readNull: true });
                        if (current !== value) {
                            if (current)
                                current._removeOwner(this);
                            if (value)
                                value._addOwner(this);
                        }
                        return value;
                    }
                    : type === 'gradient'
                        ? function() {
                            return Point.read(arguments, 0, {
                                    readNull: name === 'highlight',
                                    clone: true
                            });
                        }
                        : function(value) {
                            return value == null || isNaN(value) ? 0 : value;
                        };

            this['get' + part] = function() {
                return this._type === type
                    || hasOverlap && /^hs[bl]$/.test(this._type)
                        ? this._components[index]
                        : this._convert(type)[index];
            };

            this['set' + part] = function(value) {
                if (this._type !== type
                        && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
                    this._components = this._convert(type);
                    this._properties = types[type];
                    this._type = type;
                }
                value = parser.call(this, value);
                if (value != null) {
                    this._components[index] = value;
                    this._changed();
                }
            };
        }, this);
    }, {
        _class: 'Color',
        _readIndex: true,

        initialize: function Color(arg) {
            var slice = Array.prototype.slice,
                args = arguments,
                read = 0,
                type,
                components,
                alpha,
                values;
            if (Array.isArray(arg)) {
                args = arg;
                arg = args[0];
            }
            var argType = arg != null && typeof arg;
            if (argType === 'string' && arg in types) {
                type = arg;
                arg = args[1];
                if (Array.isArray(arg)) {
                    components = arg;
                    alpha = args[2];
                } else {
                    if (this.__read)
                        read = 1; 
                    args = slice.call(args, 1);
                    argType = typeof arg;
                }
            }
            if (!components) {
                values = argType === 'number'
                        ? args
                        : argType === 'object' && arg.length != null
                            ? arg
                            : null;
                if (values) {
                    if (!type)
                        type = values.length >= 3
                                ? 'rgb'
                                : 'gray';
                    var length = types[type].length;
                    alpha = values[length];
                    if (this.__read)
                        read += values === arguments
                            ? length + (alpha != null ? 1 : 0)
                            : 1;
                    if (values.length > length)
                        values = slice.call(values, 0, length);
                } else if (argType === 'string') {
                    type = 'rgb';
                    components = fromCSS(arg);
                    if (components.length === 4) {
                        alpha = components[3];
                        components.length--;
                    }
                } else if (argType === 'object') {
                    if (arg.constructor === Color) {
                        type = arg._type;
                        components = arg._components.slice();
                        alpha = arg._alpha;
                        if (type === 'gradient') {
                            for (var i = 1, l = components.length; i < l; i++) {
                                var point = components[i];
                                if (point)
                                    components[i] = point.clone();
                            }
                        }
                    } else if (arg.constructor === Gradient) {
                        type = 'gradient';
                        values = args;
                    } else {
                        type = 'hue' in arg
                            ? 'lightness' in arg
                                ? 'hsl'
                                : 'hsb'
                            : 'gradient' in arg || 'stops' in arg
                                    || 'radial' in arg
                                ? 'gradient'
                                : 'gray' in arg
                                    ? 'gray'
                                    : 'rgb';
                        var properties = types[type];
                            parsers = componentParsers[type];
                        this._components = components = [];
                        for (var i = 0, l = properties.length; i < l; i++) {
                            var value = arg[properties[i]];
                            if (value == null && i === 0 && type === 'gradient'
                                    && 'stops' in arg) {
                                value = {
                                    stops: arg.stops,
                                    radial: arg.radial
                                };
                            }
                            value = parsers[i].call(this, value);
                            if (value != null)
                                components[i] = value;
                        }
                        alpha = arg.alpha;
                    }
                }
                if (this.__read && type)
                    read = 1;
            }
            this._type = type || 'rgb';
            if (type === 'gradient')
                this._id = Color._id = (Color._id || 0) + 1;
            if (!components) {
                this._components = components = [];
                var parsers = componentParsers[this._type];
                for (var i = 0, l = parsers.length; i < l; i++) {
                    var value = parsers[i].call(this, values && values[i]);
                    if (value != null)
                        components[i] = value;
                }
            }
            this._components = components;
            this._properties = types[this._type];
            this._alpha = alpha;
            if (this.__read)
                this.__read = read;
        },

        _serialize: function(options, dictionary) {
            var components = this.getComponents();
            return Base.serialize(
                    /^(gray|rgb)$/.test(this._type)
                        ? components
                        : [this._type].concat(components),
                    options, true, dictionary);
        },

        _changed: function() {
            this._canvasStyle = null;
            if (this._owner)
                this._owner._changed(65);
        },

        _convert: function(type) {
            var converter;
            return this._type === type
                    ? this._components.slice()
                    : (converter = converters[this._type + '-' + type])
                        ? converter.apply(this, this._components)
                        : converters['rgb-' + type].apply(this,
                            converters[this._type + '-rgb'].apply(this,
                                this._components));
        },

        convert: function(type) {
            return new Color(type, this._convert(type), this._alpha);
        },

        getType: function() {
            return this._type;
        },

        setType: function(type) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
        },

        getComponents: function() {
            var components = this._components.slice();
            if (this._alpha != null)
                components.push(this._alpha);
            return components;
        },

        getAlpha: function() {
            return this._alpha != null ? this._alpha : 1;
        },

        setAlpha: function(alpha) {
            this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
            this._changed();
        },

        hasAlpha: function() {
            return this._alpha != null;
        },

        equals: function(color) {
            var col = Base.isPlainValue(color, true)
                    ? Color.read(arguments)
                    : color;
            return col === this || col && this._class === col._class
                    && this._type === col._type
                    && this._alpha === col._alpha
                    && Base.equals(this._components, col._components)
                    || false;
        },

        toString: function() {
            var properties = this._properties,
                parts = [],
                isGradient = this._type === 'gradient',
                f = Formatter.instance;
            for (var i = 0, l = properties.length; i < l; i++) {
                var value = this._components[i];
                if (value != null)
                    parts.push(properties[i] + ': '
                            + (isGradient ? value : f.number(value)));
            }
            if (this._alpha != null)
                parts.push('alpha: ' + f.number(this._alpha));
            return '{ ' + parts.join(', ') + ' }';
        },

        toCSS: function(hex) {
            var components = this._convert('rgb'),
                alpha = hex || this._alpha == null ? 1 : this._alpha;
            function convert(val) {
                return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
            }
            components = [
                convert(components[0]),
                convert(components[1]),
                convert(components[2])
            ];
            if (alpha < 1)
                components.push(alpha < 0 ? 0 : alpha);
            return hex
                    ? '#' + ((1 << 24) + (components[0] << 16)
                        + (components[1] << 8)
                        + components[2]).toString(16).slice(1)
                    : (components.length == 4 ? 'rgba(' : 'rgb(')
                        + components.join(',') + ')';
        },

        toCanvasStyle: function(ctx) {
            if (this._canvasStyle)
                return this._canvasStyle;
            if (this._type !== 'gradient')
                return this._canvasStyle = this.toCSS();
            var components = this._components,
                gradient = components[0],
                stops = gradient._stops,
                origin = components[1],
                destination = components[2],
                canvasGradient;
            if (gradient._radial) {
                var radius = destination.getDistance(origin),
                    highlight = components[3];
                if (highlight) {
                    var vector = highlight.subtract(origin);
                    if (vector.getLength() > radius)
                        highlight = origin.add(vector.normalize(radius - 0.1));
                }
                var start = highlight || origin;
                canvasGradient = ctx.createRadialGradient(start.x, start.y,
                        0, origin.x, origin.y, radius);
            } else {
                canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
                        destination.x, destination.y);
            }
            for (var i = 0, l = stops.length; i < l; i++) {
                var stop = stops[i];
                canvasGradient.addColorStop(stop._rampPoint,
                        stop._color.toCanvasStyle());
            }
            return this._canvasStyle = canvasGradient;
        },

        transform: function(matrix) {
            if (this._type === 'gradient') {
                var components = this._components;
                for (var i = 1, l = components.length; i < l; i++) {
                    var point = components[i];
                    matrix._transformPoint(point, point, true);
                }
                this._changed();
            }
        },

        statics: {
            _types: types,

            random: function() {
                var random = Math.random;
                return new Color(random(), random(), random());
            }
        }
    });
}, new function() {
    var operators = {
        add: function(a, b) {
            return a + b;
        },

        subtract: function(a, b) {
            return a - b;
        },

        multiply: function(a, b) {
            return a * b;
        },

        divide: function(a, b) {
            return a / b;
        }
    };

    return Base.each(operators, function(operator, name) {
        this[name] = function(color) {
            color = Color.read(arguments);
            var type = this._type,
                components1 = this._components,
                components2 = color._convert(type);
            for (var i = 0, l = components1.length; i < l; i++)
                components2[i] = operator(components1[i], components2[i]);
            return new Color(type, components2,
                    this._alpha != null
                            ? operator(this._alpha, color.getAlpha())
                            : null);
        };
    }, {
    });
});

Base.each(Color._types, function(properties, type) {
    var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
            var argType = arg != null && typeof arg,
                components = argType === 'object' && arg.length != null
                    ? arg
                    : argType === 'string'
                        ? null
                        : arguments;
            return components
                    ? new Color(type, components)
                    : new Color(arg);
        };
    if (type.length == 3) {
        var acronym = type.toUpperCase();
        Color[acronym] = this[acronym + 'Color'] = ctor;
    }
}, Base.exports);

var Gradient = Base.extend({
    _class: 'Gradient',

    initialize: function Gradient(stops, radial) {
        this._id = Gradient._id = (Gradient._id || 0) + 1;
        if (stops && this._set(stops))
            stops = radial = null;
        if (!this._stops)
            this.setStops(stops || ['white', 'black']);
        if (this._radial == null)
            this.setRadial(typeof radial === 'string' && radial === 'radial'
                    || radial || false);
    },

    _serialize: function(options, dictionary) {
        return dictionary.add(this, function() {
            return Base.serialize([this._stops, this._radial],
                    options, true, dictionary);
        });
    },

    _changed: function() {
        for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
            this._owners[i]._changed();
    },

    _addOwner: function(color) {
        if (!this._owners)
            this._owners = [];
        this._owners.push(color);
    },

    _removeOwner: function(color) {
        var index = this._owners ? this._owners.indexOf(color) : -1;
        if (index != -1) {
            this._owners.splice(index, 1);
            if (this._owners.length === 0)
                this._owners = undefined;
        }
    },

    clone: function() {
        var stops = [];
        for (var i = 0, l = this._stops.length; i < l; i++)
            stops[i] = this._stops[i].clone();
        return new Gradient(stops);
    },

    getStops: function() {
        return this._stops;
    },

    setStops: function(stops) {
        if (this.stops) {
            for (var i = 0, l = this._stops.length; i < l; i++)
                this._stops[i]._owner = undefined;
        }
        if (stops.length < 2)
            throw new Error(
                    'Gradient stop list needs to contain at least two stops.');
        this._stops = GradientStop.readAll(stops, 0, { clone: true });
        for (var i = 0, l = this._stops.length; i < l; i++) {
            var stop = this._stops[i];
            stop._owner = this;
            if (stop._defaultRamp)
                stop.setRampPoint(i / (l - 1));
        }
        this._changed();
    },

    getRadial: function() {
        return this._radial;
    },

    setRadial: function(radial) {
        this._radial = radial;
        this._changed();
    },

    equals: function(gradient) {
        if (gradient === this)
            return true;
        if (gradient && this._class === gradient._class
                && this._stops.length === gradient._stops.length) {
            for (var i = 0, l = this._stops.length; i < l; i++) {
                if (!this._stops[i].equals(gradient._stops[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
});

var GradientStop = Base.extend({
    _class: 'GradientStop',

    initialize: function GradientStop(arg0, arg1) {
        if (arg0) {
            var color, rampPoint;
            if (arg1 === undefined && Array.isArray(arg0)) {
                color = arg0[0];
                rampPoint = arg0[1];
            } else if (arg0.color) {
                color = arg0.color;
                rampPoint = arg0.rampPoint;
            } else {
                color = arg0;
                rampPoint = arg1;
            }
            this.setColor(color);
            this.setRampPoint(rampPoint);
        }
    },

    clone: function() {
        return new GradientStop(this._color.clone(), this._rampPoint);
    },

    _serialize: function(options, dictionary) {
        return Base.serialize([this._color, this._rampPoint], options, true,
                dictionary);
    },

    _changed: function() {
        if (this._owner)
            this._owner._changed(65);
    },

    getRampPoint: function() {
        return this._rampPoint;
    },

    setRampPoint: function(rampPoint) {
        this._defaultRamp = rampPoint == null;
        this._rampPoint = rampPoint || 0;
        this._changed();
    },

    getColor: function() {
        return this._color;
    },

    setColor: function(color) {
        this._color = Color.read(arguments);
        if (this._color === color)
            this._color = color.clone();
        this._color._owner = this;
        this._changed();
    },

    equals: function(stop) {
        return stop === this || stop && this._class === stop._class
                && this._color.equals(stop._color)
                && this._rampPoint == stop._rampPoint
                || false;
    }
});

var Style = Base.extend(new function() {
    var defaults = {
        fillColor: undefined,
        strokeColor: undefined,
        strokeWidth: 1,
        strokeCap: 'butt',
        strokeJoin: 'miter',
        strokeScaling: true,
        miterLimit: 10,
        dashOffset: 0,
        dashArray: [],
        windingRule: 'nonzero',
        shadowColor: undefined,
        shadowBlur: 0,
        shadowOffset: new Point(),
        selectedColor: undefined,
        fontFamily: 'sans-serif',
        fontWeight: 'normal',
        fontSize: 12,
        font: 'sans-serif', 
        leading: null,
        justification: 'left'
    };

    var flags = {
        strokeWidth: 97,
        strokeCap: 97,
        strokeJoin: 97,
        strokeScaling: 105,
        miterLimit: 97,
        fontFamily: 9,
        fontWeight: 9,
        fontSize: 9,
        font: 9, 
        leading: 9,
        justification: 9
    };

    var item = { beans: true },
        fields = {
            _defaults: defaults,
            _textDefaults: new Base(defaults, {
                fillColor: new Color() 
            }),
            beans: true
        };

    Base.each(defaults, function(value, key) {
        var isColor = /Color$/.test(key),
            isPoint = key === 'shadowOffset',
            part = Base.capitalize(key),
            flag = flags[key],
            set = 'set' + part,
            get = 'get' + part;

        fields[set] = function(value) {
            var owner = this._owner,
                children = owner && owner._children;
            if (children && children.length > 0
                    && !(owner instanceof CompoundPath)) {
                for (var i = 0, l = children.length; i < l; i++)
                    children[i]._style[set](value);
            } else {
                var old = this._values[key];
                if (old != value) {
                    if (isColor) {
                        if (old)
                            old._owner = undefined;
                        if (value && value.constructor === Color) {
                            if (value._owner)
                                value = value.clone();
                            value._owner = owner;
                        }
                    }
                    this._values[key] = value;
                    if (owner)
                        owner._changed(flag || 65);
                }
            }
        };

        fields[get] = function(_dontMerge) {
            var owner = this._owner,
                children = owner && owner._children,
                value;
            if (!children || children.length === 0 || _dontMerge
                    || owner instanceof CompoundPath) {
                var value = this._values[key];
                if (value === undefined) {
                    value = this._defaults[key];
                    if (value && value.clone)
                        value = value.clone();
                    this._values[key] = value;
                } else {
                    var ctor = isColor ? Color : isPoint ? Point : null;
                    if (ctor && !(value && value.constructor === ctor)) {
                        this._values[key] = value = ctor.read([value], 0,
                                { readNull: true, clone: true });
                        if (value && isColor)
                            value._owner = owner;
                    }
                }
                return value;
            }
            for (var i = 0, l = children.length; i < l; i++) {
                var childValue = children[i]._style[get]();
                if (i === 0) {
                    value = childValue;
                } else if (!Base.equals(value, childValue)) {
                    return undefined;
                }
            }
            return value;
        };

        item[get] = function(_dontMerge) {
            return this._style[get](_dontMerge);
        };

        item[set] = function(value) {
            this._style[set](value);
        };
    });

    Item.inject(item);
    return fields;
}, {
    _class: 'Style',

    initialize: function Style(style, _owner, _project) {
        this._values = {};
        this._owner = _owner;
        this._project = _owner && _owner._project || _project || paper.project;
        if (_owner instanceof TextItem)
            this._defaults = this._textDefaults;
        if (style)
            this.set(style);
    },

    set: function(style) {
        var isStyle = style instanceof Style,
            values = isStyle ? style._values : style;
        if (values) {
            for (var key in values) {
                if (key in this._defaults) {
                    var value = values[key];
                    this[key] = value && isStyle && value.clone
                            ? value.clone() : value;
                }
            }
        }
    },

    equals: function(style) {
        return style === this || style && this._class === style._class
                && Base.equals(this._values, style._values)
                || false;
    },

    hasFill: function() {
        return !!this.getFillColor();
    },

    hasStroke: function() {
        return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
    },

    hasShadow: function() {
        return !!this.getShadowColor() && this.getShadowBlur() > 0;
    },

    getView: function() {
        return this._project.getView();
    },

    getFontStyle: function() {
        var fontSize = this.getFontSize();
        return this.getFontWeight()
                + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
                + this.getFontFamily();
    },

    getFont: '#getFontFamily',
    setFont: '#setFontFamily',

    getLeading: function getLeading() {
        var leading = getLeading.base.call(this),
            fontSize = this.getFontSize();
        if (/pt|em|%|px/.test(fontSize))
            fontSize = this.getView().getPixelSize(fontSize);
        return leading != null ? leading : fontSize * 1.2;
    }

});

var DomElement = new function() {
    function handlePrefix(el, name, set, value) {
        var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
            suffix = name[0].toUpperCase() + name.substring(1);
        for (var i = 0; i < 6; i++) {
            var prefix = prefixes[i],
                key = prefix ? prefix + suffix : name;
            if (key in el) {
                if (set) {
                    el[key] = value;
                } else {
                    return el[key];
                }
                break;
            }
        }
    }

    return {
        getStyles: function(el) {
            var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
                view = doc && doc.defaultView;
            return view && view.getComputedStyle(el, '');
        },

        getBounds: function(el, viewport) {
            var doc = el.ownerDocument,
                body = doc.body,
                html = doc.documentElement,
                rect;
            try {
                rect = el.getBoundingClientRect();
            } catch (e) {
                rect = { left: 0, top: 0, width: 0, height: 0 };
            }
            var x = rect.left - (html.clientLeft || body.clientLeft || 0),
                y = rect.top - (html.clientTop || body.clientTop || 0);
            if (!viewport) {
                var view = doc.defaultView;
                x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
                y += view.pageYOffset || html.scrollTop || body.scrollTop;
            }
            return new Rectangle(x, y, rect.width, rect.height);
        },

        getViewportBounds: function(el) {
            var doc = el.ownerDocument,
                view = doc.defaultView,
                html = doc.documentElement;
            return new Rectangle(0, 0,
                view.innerWidth || html.clientWidth,
                view.innerHeight || html.clientHeight
            );
        },

        getOffset: function(el, viewport) {
            return DomElement.getBounds(el, viewport).getPoint();
        },

        getSize: function(el) {
            return DomElement.getBounds(el, true).getSize();
        },

        isInvisible: function(el) {
            return DomElement.getSize(el).equals(new Size(0, 0));
        },

        isInView: function(el) {
            return !DomElement.isInvisible(el)
                    && DomElement.getViewportBounds(el).intersects(
                        DomElement.getBounds(el, true));
        },

        getPrefixed: function(el, name) {
            return handlePrefix(el, name);
        },

        setPrefixed: function(el, name, value) {
            if (typeof name === 'object') {
                for (var key in name)
                    handlePrefix(el, key, true, name[key]);
            } else {
                handlePrefix(el, name, true, value);
            }
        }
    };
};

var DomEvent = {
    add: function(el, events) {
        for (var type in events) {
            var func = events[type],
                parts = type.split(/[\s,]+/g);
            for (var i = 0, l = parts.length; i < l; i++)
                el.addEventListener(parts[i], func, false);
        }
    },

    remove: function(el, events) {
        for (var type in events) {
            var func = events[type],
                parts = type.split(/[\s,]+/g);
            for (var i = 0, l = parts.length; i < l; i++)
                el.removeEventListener(parts[i], func, false);
        }
    },

    getPoint: function(event) {
        var pos = event.targetTouches
                ? event.targetTouches.length
                    ? event.targetTouches[0]
                    : event.changedTouches[0]
                : event;
        return new Point(
            pos.pageX || pos.clientX + document.documentElement.scrollLeft,
            pos.pageY || pos.clientY + document.documentElement.scrollTop
        );
    },

    getTarget: function(event) {
        return event.target || event.srcElement;
    },

    getRelatedTarget: function(event) {
        return event.relatedTarget || event.toElement;
    },

    getOffset: function(event, target) {
        return DomEvent.getPoint(event).subtract(DomElement.getOffset(
                target || DomEvent.getTarget(event)));
    },

    stop: function(event) {
        event.stopPropagation();
        event.preventDefault();
    }
};

DomEvent.requestAnimationFrame = new function() {
    var nativeRequest = typeof window === 'object' &&
            DomElement.getPrefixed(window, 'requestAnimationFrame'),
        requested = false,
        callbacks = [],
        focused = true,
        timer;

    if ( typeof window === 'object' ) {
        DomEvent.add(window, {
            focus: function() {
                focused = true;
            },
            blur: function() {
                focused = false;
            }
        });
    }

    function handleCallbacks() {
        for (var i = callbacks.length - 1; i >= 0; i--) {
            var entry = callbacks[i],
                func = entry[0],
                el = entry[1];
            if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
                    || focused) && DomElement.isInView(el)) {
                callbacks.splice(i, 1);
                func();
            }
        }
        if (nativeRequest) {
            if (callbacks.length) {
                nativeRequest(handleCallbacks);
            } else {
                requested = false;
            }
        }
    }

    return function(callback, element) {
        callbacks.push([callback, element]);
        if (nativeRequest) {
            if (!requested) {
                nativeRequest(handleCallbacks);
                requested = true;
            }
        } else if (!timer) {
            timer = setInterval(handleCallbacks, 1000 / 60);
        }
    };
};

var View = Base.extend(Emitter, {
    _class: 'View',

    initialize: function View(project, element) {
        this._project = project;
        this._scope = project._scope;
        this._element = element;
        var size;
        if ( !noCanvas ) {
            if (!this._pixelRatio)
                this._pixelRatio = window.devicePixelRatio || 1;
            this._id = element.getAttribute('id');
            if (this._id == null)
                element.setAttribute('id', this._id = 'view-' + View._id++);
            DomEvent.add(element, this._viewEvents);
            var none = 'none';
            DomElement.setPrefixed(element.style, {
                userSelect: none,
                touchAction: none,
                touchCallout: none,
                contentZooming: none,
                userDrag: none,
                tapHighlightColor: 'rgba(0,0,0,0)'
            });
            if (PaperScope.hasAttribute(element, 'resize')) {
                var offset = DomElement.getOffset(element, true),
                    that = this;
                size = DomElement.getViewportBounds(element)
                        .getSize().subtract(offset);
                this._windowEvents = {
                    resize: function() {
                        if (!DomElement.isInvisible(element))
                            offset = DomElement.getOffset(element, true);
                        that.setViewSize(DomElement.getViewportBounds(element)
                                .getSize().subtract(offset));
                    }
                };
                DomEvent.add(window, this._windowEvents);
            } else {
                size = DomElement.getSize(element);
                if (size.isNaN() || size.isZero()) {
                    var getSize = function(name) {
                        return element[name]
                                || parseInt(element.getAttribute(name), 10);
                    };
                    size = new Size(getSize('width'), getSize('height'));
                }
            }
            this._setViewSize(size);
            if (PaperScope.hasAttribute(element, 'stats')
                    && typeof Stats !== 'undefined') {
                this._stats = new Stats();
                var stats = this._stats.domElement,
                    style = stats.style,
                    offset = DomElement.getOffset(element);
                style.position = 'absolute';
                style.left = offset.x + 'px';
                style.top = offset.y + 'px';
                document.body.appendChild(stats);
            }

        } else { 
            if (!this._pixelRatio)
                this._pixelRatio = 1;
            this._id = 'view-' + View._id++;
            size = new Size(element.width, element.height);
        }
        View._views.push(this);
        View._viewsById[this._id] = this;
        this._viewSize = size;
        (this._matrix = new Matrix())._owner = this;
        this._zoom = 1;
        if (!View._focused)
            View._focused = this;
        this._frameItems = {};
        this._frameItemCount = 0;
    },

    remove: function() {
        if (!this._project)
            return false;
        if (View._focused === this)
            View._focused = null;
        View._views.splice(View._views.indexOf(this), 1);
        delete View._viewsById[this._id];
        if (this._project._view === this)
            this._project._view = null;
        DomEvent.remove(this._element, this._viewEvents);
        DomEvent.remove(window, this._windowEvents);
        this._element = this._project = null;
        this.off('frame');
        this._animate = false;
        this._frameItems = {};
        return true;
    },

    _events: {
        onFrame: {
            install: function() {
                this.play();
            },

            uninstall: function() {
                this.pause();
            }
        },

        onResize: {}
    },

    _animate: false,
    _time: 0,
    _count: 0,

    _requestFrame: function() {
        var that = this;
        DomEvent.requestAnimationFrame(function() {
            that._requested = false;
            if (!that._animate)
                return;
            that._requestFrame();
            that._handleFrame();
        }, this._element);
        this._requested = true;
    },

    _handleFrame: function() {
        paper = this._scope;
        var now = Date.now() / 1000,
            delta = this._before ? now - this._before : 0;
        this._before = now;
        this._handlingFrame = true;
        this.emit('frame', new Base({
            delta: delta,
            time: this._time += delta,
            count: this._count++
        }));
        if (this._stats)
            this._stats.update();
        this._handlingFrame = false;
        this.update();
    },

    _animateItem: function(item, animate) {
        var items = this._frameItems;
        if (animate) {
            items[item._id] = {
                item: item,
                time: 0,
                count: 0
            };
            if (++this._frameItemCount === 1)
                this.on('frame', this._handleFrameItems);
        } else {
            delete items[item._id];
            if (--this._frameItemCount === 0) {
                this.off('frame', this._handleFrameItems);
            }
        }
    },

    _handleFrameItems: function(event) {
        for (var i in this._frameItems) {
            var entry = this._frameItems[i];
            entry.item.emit('frame', new Base(event, {
                time: entry.time += event.delta,
                count: entry.count++
            }));
        }
    },

    _update: function() {
        this._project._needsUpdate = true;
        if (this._handlingFrame)
            return;
        if (this._animate) {
            this._handleFrame();
        } else {
            this.update();
        }
    },

    _changed: function(flags) {
        if (flags & 1)
            this._project._needsUpdate = true;
    },

    _transform: function(matrix) {
        this._matrix.concatenate(matrix);
        this._bounds = null;
        this._update();
    },

    getElement: function() {
        return this._element;
    },

    getPixelRatio: function() {
        return this._pixelRatio;
    },

    getResolution: function() {
        return this._pixelRatio * 72;
    },

    getViewSize: function() {
        var size = this._viewSize;
        return new LinkedSize(size.width, size.height, this, 'setViewSize');
    },

    setViewSize: function() {
        var size = Size.read(arguments),
            delta = size.subtract(this._viewSize);
        if (delta.isZero())
            return;
        this._viewSize.set(size.width, size.height);
        this._setViewSize(size);
        this._bounds = null; 
        this.emit('resize', {
            size: size,
            delta: delta
        });
        this._update();
    },

    _setViewSize: function(size) {
        var element = this._element;
        element.width = size.width;
        element.height = size.height;
    },

    getBounds: function() {
        if (!this._bounds)
            this._bounds = this._matrix.inverted()._transformBounds(
                    new Rectangle(new Point(), this._viewSize));
        return this._bounds;
    },

    getSize: function() {
        return this.getBounds().getSize();
    },

    getCenter: function() {
        return this.getBounds().getCenter();
    },

    setCenter: function() {
        var center = Point.read(arguments);
        this.scrollBy(center.subtract(this.getCenter()));
    },

    getZoom: function() {
        return this._zoom;
    },

    setZoom: function(zoom) {
        this._transform(new Matrix().scale(zoom / this._zoom,
            this.getCenter()));
        this._zoom = zoom;
    },

    isVisible: function() {
        return DomElement.isInView(this._element);
    },

    scrollBy: function() {
        this._transform(new Matrix().translate(Point.read(arguments).negate()));
    },

    play: function() {
        this._animate = true;
        if (!this._requested)
            this._requestFrame();
    },

    pause: function() {
        this._animate = false;
    },

    draw: function() {
        this.update();
    },

    projectToView: function() {
        return this._matrix._transformPoint(Point.read(arguments));
    },

    viewToProject: function() {
        return this._matrix._inverseTransform(Point.read(arguments));
    }

}, {
    statics: {
        _views: [],
        _viewsById: {},
        _id: 0,

        create: function(project, element) {
            if (typeof element === 'string')
                element = document.getElementById(element);
            return new CanvasView(project, element);
        }
    }
}, new function() {
    if ( noCanvas ) {
        return;
    }

    var tool,
        prevFocus,
        tempFocus,
        dragging = false;

    function getView(event) {
        var target = DomEvent.getTarget(event);
        return target.getAttribute && View._viewsById[target.getAttribute('id')];
    }

    function viewToProject(view, event) {
        return view.viewToProject(DomEvent.getOffset(event, view._element));
    }

    function updateFocus() {
        if (!View._focused || !View._focused.isVisible()) {
            for (var i = 0, l = View._views.length; i < l; i++) {
                var view = View._views[i];
                if (view && view.isVisible()) {
                    View._focused = tempFocus = view;
                    break;
                }
            }
        }
    }

    function handleMouseMove(view, point, event) {
        view._handleEvent('mousemove', point, event);
        var tool = view._scope.tool;
        if (tool) {
            tool._handleEvent(dragging && tool.responds('mousedrag')
                    ? 'mousedrag' : 'mousemove', point, event);
        }
        view.update();
        return tool;
    }

    var navigator = window.navigator,
        mousedown, mousemove, mouseup;
    if (navigator.pointerEnabled || navigator.msPointerEnabled) {
        mousedown = 'pointerdown MSPointerDown';
        mousemove = 'pointermove MSPointerMove';
        mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
    } else {
        mousedown = 'touchstart';
        mousemove = 'touchmove';
        mouseup = 'touchend touchcancel';
        if (!('ontouchstart' in window && navigator.userAgent.match(
                /mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
            mousedown += ' mousedown';
            mousemove += ' mousemove';
            mouseup += ' mouseup';
        }
    }

    var viewEvents = {
        'selectstart dragstart': function(event) {
            if (dragging)
                event.preventDefault();
        }
    };

    var docEvents = {
        mouseout: function(event) {
            var view = View._focused,
                target = DomEvent.getRelatedTarget(event);
            if (view && (!target || target.nodeName === 'HTML'))
                handleMouseMove(view, viewToProject(view, event), event);
        },

        scroll: updateFocus
    };

    viewEvents[mousedown] = function(event) {
        var view = View._focused = getView(event),
            point = viewToProject(view, event);
        dragging = true;
        view._handleEvent('mousedown', point, event);
        if (tool = view._scope.tool)
            tool._handleEvent('mousedown', point, event);
        view.update();
    };

    docEvents[mousemove] = function(event) {
        var view = View._focused;
        if (!dragging) {
            var target = getView(event);
            if (target) {
                if (view !== target)
                    handleMouseMove(view, viewToProject(view, event), event);
                prevFocus = view;
                view = View._focused = tempFocus = target;
            } else if (tempFocus && tempFocus === view) {
                view = View._focused = prevFocus;
                updateFocus();
            }
        }
        if (view) {
            var point = viewToProject(view, event);
            if (dragging || view.getBounds().contains(point))
                tool = handleMouseMove(view, point, event);
        }
    };

    docEvents[mouseup] = function(event) {
        var view = View._focused;
        if (!view || !dragging)
            return;
        var point = viewToProject(view, event);
        dragging = false;
        view._handleEvent('mouseup', point, event);
        if (tool)
            tool._handleEvent('mouseup', point, event);
        view.update();
    };

    DomEvent.add(document, docEvents);

    DomEvent.add(window, {
        load: updateFocus
    });

    return {
        _viewEvents: viewEvents,

        _handleEvent: function() {},

        statics: {
            updateFocus: updateFocus
        }
    };
});

var CanvasView = View.extend({
    _class: 'CanvasView',

    initialize: function CanvasView(project, canvas) {
        if ( !noCanvas ) {
            if (!(canvas instanceof HTMLCanvasElement)) {
                var size = Size.read(arguments);
                if (size.isZero())
                    throw new Error(
                            'Cannot create CanvasView with the provided argument: '
                            + [].slice.call(arguments, 1));
                canvas = CanvasProvider.getCanvas(size);
            }
            this._context = canvas.getContext('2d');
        }
        this._eventCounters = {};
        this._pixelRatio = 1;
        if (!noCanvas && !/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
            var deviceRatio = window.devicePixelRatio || 1,
                backingStoreRatio = DomElement.getPrefixed(this._context,
                        'backingStorePixelRatio') || 1;
            this._pixelRatio = deviceRatio / backingStoreRatio;
        }
        View.call(this, project, canvas);
    },

    _setViewSize: function(size) {
        var width = size.width,
            height = size.height,
            pixelRatio = this._pixelRatio,
            element = this._element,
            style = element.style;
        element.width = width * pixelRatio;
        element.height = height * pixelRatio;
        if (pixelRatio !== 1) {
            style.width = width + 'px';
            style.height = height + 'px';
            this._context.scale(pixelRatio, pixelRatio);
        }
    },

    getPixelSize: function(size) {
        var ctx = this._context,
            prevFont = ctx.font;
        ctx.font = size + ' serif';
        size = parseFloat(ctx.font);
        ctx.font = prevFont;
        return size;
    },

    getTextWidth: function(font, lines) {
        var ctx = this._context,
            prevFont = ctx.font,
            width = 0;
        ctx.font = font;
        for (var i = 0, l = lines.length; i < l; i++)
            width = Math.max(width, ctx.measureText(lines[i]).width);
        ctx.font = prevFont;
        return width;
    },

    update: function() {
        var project = this._project;
        if (!project || !project._needsUpdate)
            return false;
        var ctx = this._context,
            size = this._viewSize;
        ctx.clearRect(0, 0, size.width + 1, size.height + 1);
        project.draw(ctx, this._matrix, this._pixelRatio);
        project._needsUpdate = false;
        return true;
    }
}, new function() { 

    var downPoint,
        lastPoint,
        overPoint,
        downItem,
        lastItem,
        overItem,
        dragItem,
        dblClick,
        clickTime;

    function callEvent(view, type, event, point, target, lastPoint) {
        var item = target,
            mouseEvent;

        function call(obj) {
            if (obj.responds(type)) {
                if (!mouseEvent) {
                    mouseEvent = new MouseEvent(type, event, point, target,
                            lastPoint ? point.subtract(lastPoint) : null);
                }
                if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
                    event.preventDefault();
                    return true;
                }
            }
        }

        while (item) {
            if (call(item))
                return true;
            item = item.getParent();
        }
        if (call(view))
            return true;
        return false;
    }

    return {
        _handleEvent: function(type, point, event) {
            if (!this._eventCounters[type])
                return;
            var project = this._project,
                hit = project.hitTest(point, {
                    tolerance: 0,
                    fill: true,
                    stroke: true
                }),
                item = hit && hit.item,
                stopped = false;
            switch (type) {
            case 'mousedown':
                stopped = callEvent(this, type, event, point, item);
                dblClick = lastItem == item && (Date.now() - clickTime < 300);
                downItem = lastItem = item;
                downPoint = lastPoint = overPoint = point;
                dragItem = !stopped && item;
                while (dragItem && !dragItem.responds('mousedrag'))
                    dragItem = dragItem._parent;
                break;
            case 'mouseup':
                stopped = callEvent(this, type, event, point, item, downPoint);
                if (dragItem) {
                    if (lastPoint && !lastPoint.equals(point))
                        callEvent(this, 'mousedrag', event, point, dragItem,
                                lastPoint);
                    if (item !== dragItem) {
                        overPoint = point;
                        callEvent(this, 'mousemove', event, point, item,
                                overPoint);
                    }
                }
                if (!stopped && item && item === downItem) {
                    clickTime = Date.now();
                    callEvent(this, dblClick && downItem.responds('doubleclick')
                            ? 'doubleclick' : 'click', event, downPoint, item);
                    dblClick = false;
                }
                downItem = dragItem = null;
                break;
            case 'mousemove':
                if (dragItem)
                    stopped = callEvent(this, 'mousedrag', event, point,
                            dragItem, lastPoint);
                if (!stopped) {
                    if (item !== overItem)
                        overPoint = point;
                    stopped = callEvent(this, type, event, point, item,
                            overPoint);
                }
                lastPoint = overPoint = point;
                if (item !== overItem) {
                    callEvent(this, 'mouseleave', event, point, overItem);
                    overItem = item;
                    callEvent(this, 'mouseenter', event, point, item);
                }
                break;
            }
            return stopped;
        }
    };
});

var Event = Base.extend({
    _class: 'Event',

    initialize: function Event(event) {
        this.event = event;
    },

    isPrevented: false,
    isStopped: false,

    preventDefault: function() {
        this.isPrevented = true;
        this.event.preventDefault();
    },

    stopPropagation: function() {
        this.isStopped = true;
        this.event.stopPropagation();
    },

    stop: function() {
        this.stopPropagation();
        this.preventDefault();
    },

    getModifiers: function() {
        return Key.modifiers;
    }
});

var KeyEvent = Event.extend({
    _class: 'KeyEvent',

    initialize: function KeyEvent(down, key, character, event) {
        Event.call(this, event);
        this.type = down ? 'keydown' : 'keyup';
        this.key = key;
        this.character = character;
    },

    toString: function() {
        return "{ type: '" + this.type
                + "', key: '" + this.key
                + "', character: '" + this.character
                + "', modifiers: " + this.getModifiers()
                + " }";
    }
});

var Key = new function() {
    if ( noCanvas ) {
        return;
    }

    var specialKeys = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'control',
        18: 'option',
        19: 'pause',
        20: 'caps-lock',
        27: 'escape',
        32: 'space',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        46: 'delete',
        91: 'command',
        93: 'command', 
        224: 'command' 
    },

    specialChars = {
        9: true, 
        13: true, 
        32: true 
    },

    modifiers = new Base({
        shift: false,
        control: false,
        option: false,
        command: false,
        capsLock: false,
        space: false
    }),

    charCodeMap = {}, 
    keyMap = {}, 
    downCode; 

    function handleKey(down, keyCode, charCode, event) {
        var character = charCode ? String.fromCharCode(charCode) : '',
            specialKey = specialKeys[keyCode],
            key = specialKey || character.toLowerCase(),
            type = down ? 'keydown' : 'keyup',
            view = View._focused,
            scope = view && view.isVisible() && view._scope,
            tool = scope && scope.tool,
            name;
        keyMap[key] = down;
        if (specialKey && (name = Base.camelize(specialKey)) in modifiers)
            modifiers[name] = down;
        if (down) {
            charCodeMap[keyCode] = charCode;
        } else {
            delete charCodeMap[keyCode];
        }
        if (tool && tool.responds(type)) {
            paper = scope;
            tool.emit(type, new KeyEvent(down, key, character, event));
            if (view)
                view.update();
        }
    }

    DomEvent.add(document, {
        keydown: function(event) {
            var code = event.which || event.keyCode;
            if (code in specialKeys || modifiers.command) {
                handleKey(true, code,
                        code in specialChars || modifiers.command ? code : 0,
                        event);
            } else {
                downCode = code;
            }
        },

        keypress: function(event) {
            if (downCode != null) {
                handleKey(true, downCode, event.which || event.keyCode, event);
                downCode = null;
            }
        },

        keyup: function(event) {
            var code = event.which || event.keyCode;
            if (code in charCodeMap)
                handleKey(false, code, charCodeMap[code], event);
        }
    });

    DomEvent.add(window, {
        blur: function(event) {
            for (var code in charCodeMap)
                handleKey(false, code, charCodeMap[code], event);
        }
    });

    return {
        modifiers: modifiers,

        isDown: function(key) {
            return !!keyMap[key];
        }
    };
};

var MouseEvent = Event.extend({
    _class: 'MouseEvent',

    initialize: function MouseEvent(type, event, point, target, delta) {
        Event.call(this, event);
        this.type = type;
        this.point = point;
        this.target = target;
        this.delta = delta;
    },

    toString: function() {
        return "{ type: '" + this.type
                + "', point: " + this.point
                + ', target: ' + this.target
                + (this.delta ? ', delta: ' + this.delta : '')
                + ', modifiers: ' + this.getModifiers()
                + ' }';
    }
});

var ToolEvent = Event.extend({
    _class: 'ToolEvent',
    _item: null,

    initialize: function ToolEvent(tool, type, event) {
        this.tool = tool;
        this.type = type;
        this.event = event;
    },

    _choosePoint: function(point, toolPoint) {
        return point ? point : toolPoint ? toolPoint.clone() : null;
    },

    getPoint: function() {
        return this._choosePoint(this._point, this.tool._point);
    },

    setPoint: function(point) {
        this._point = point;
    },

    getLastPoint: function() {
        return this._choosePoint(this._lastPoint, this.tool._lastPoint);
    },

    setLastPoint: function(lastPoint) {
        this._lastPoint = lastPoint;
    },

    getDownPoint: function() {
        return this._choosePoint(this._downPoint, this.tool._downPoint);
    },

    setDownPoint: function(downPoint) {
        this._downPoint = downPoint;
    },

    getMiddlePoint: function() {
        if (!this._middlePoint && this.tool._lastPoint) {
            return this.tool._point.add(this.tool._lastPoint).divide(2);
        }
        return this._middlePoint;
    },

    setMiddlePoint: function(middlePoint) {
        this._middlePoint = middlePoint;
    },

    getDelta: function() {
        return !this._delta && this.tool._lastPoint
                ? this.tool._point.subtract(this.tool._lastPoint)
                : this._delta;
    },

    setDelta: function(delta) {
        this._delta = delta;
    },

    getCount: function() {
        return /^mouse(down|up)$/.test(this.type)
                ? this.tool._downCount
                : this.tool._count;
    },

    setCount: function(count) {
        this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
            = count;
    },

    getItem: function() {
        if (!this._item) {
            var result = this.tool._scope.project.hitTest(this.getPoint());
            if (result) {
                var item = result.item,
                    parent = item._parent;
                while (/^(Group|CompoundPath)$/.test(parent._class)) {
                    item = parent;
                    parent = parent._parent;
                }
                this._item = item;
            }
        }
        return this._item;
    },

    setItem: function(item) {
        this._item = item;
    },

    toString: function() {
        return '{ type: ' + this.type
                + ', point: ' + this.getPoint()
                + ', count: ' + this.getCount()
                + ', modifiers: ' + this.getModifiers()
                + ' }';
    }
});

var Tool = PaperScopeItem.extend({
    _class: 'Tool',
    _list: 'tools',
    _reference: 'tool',
    _events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
            'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
            'onKeyDown', 'onKeyUp' ],

    initialize: function Tool(props) {
        PaperScopeItem.call(this);
        this._firstMove = true;
        this._count = 0;
        this._downCount = 0;
        this._set(props);
    },

    getMinDistance: function() {
        return this._minDistance;
    },

    setMinDistance: function(minDistance) {
        this._minDistance = minDistance;
        if (this._minDistance != null && this._maxDistance != null
                && this._minDistance > this._maxDistance) {
            this._maxDistance = this._minDistance;
        }
    },

    getMaxDistance: function() {
        return this._maxDistance;
    },

    setMaxDistance: function(maxDistance) {
        this._maxDistance = maxDistance;
        if (this._minDistance != null && this._maxDistance != null
                && this._maxDistance < this._minDistance) {
            this._minDistance = maxDistance;
        }
    },

    getFixedDistance: function() {
        return this._minDistance == this._maxDistance
            ? this._minDistance : null;
    },

    setFixedDistance: function(distance) {
        this._minDistance = distance;
        this._maxDistance = distance;
    },

    _updateEvent: function(type, point, minDistance, maxDistance, start,
            needsChange, matchMaxDistance) {
        if (!start) {
            if (minDistance != null || maxDistance != null) {
                var minDist = minDistance != null ? minDistance : 0,
                    vector = point.subtract(this._point),
                    distance = vector.getLength();
                if (distance < minDist)
                    return false;
                var maxDist = maxDistance != null ? maxDistance : 0;
                if (maxDist != 0) {
                    if (distance > maxDist) {
                        point = this._point.add(vector.normalize(maxDist));
                    } else if (matchMaxDistance) {
                        return false;
                    }
                }
            }
            if (needsChange && point.equals(this._point))
                return false;
        }
        this._lastPoint = start && type == 'mousemove' ? point : this._point;
        this._point = point;
        switch (type) {
        case 'mousedown':
            this._lastPoint = this._downPoint;
            this._downPoint = this._point;
            this._downCount++;
            break;
        case 'mouseup':
            this._lastPoint = this._downPoint;
            break;
        }
        this._count = start ? 0 : this._count + 1;
        return true;
    },

    _fireEvent: function(type, event) {
        var sets = paper.project._removeSets;
        if (sets) {
            if (type === 'mouseup')
                sets.mousedrag = null;
            var set = sets[type];
            if (set) {
                for (var id in set) {
                    var item = set[id];
                    for (var key in sets) {
                        var other = sets[key];
                        if (other && other != set)
                            delete other[item._id];
                    }
                    item.remove();
                }
                sets[type] = null;
            }
        }
        return this.responds(type)
                && this.emit(type, new ToolEvent(this, type, event));
    },

    _handleEvent: function(type, point, event) {
        paper = this._scope;
        var called = false;
        switch (type) {
        case 'mousedown':
            this._updateEvent(type, point, null, null, true, false, false);
            called = this._fireEvent(type, event);
            break;
        case 'mousedrag':
            var needsChange = false,
                matchMaxDistance = false;
            while (this._updateEvent(type, point, this.minDistance,
                    this.maxDistance, false, needsChange, matchMaxDistance)) {
                called = this._fireEvent(type, event) || called;
                needsChange = true;
                matchMaxDistance = true;
            }
            break;
        case 'mouseup':
            if (!point.equals(this._point)
                    && this._updateEvent('mousedrag', point, this.minDistance,
                            this.maxDistance, false, false, false)) {
                called = this._fireEvent('mousedrag', event);
            }
            this._updateEvent(type, point, null, this.maxDistance, false,
                    false, false);
            called = this._fireEvent(type, event) || called;
            this._updateEvent(type, point, null, null, true, false, false);
            this._firstMove = true;
            break;
        case 'mousemove':
            while (this._updateEvent(type, point, this.minDistance,
                    this.maxDistance, this._firstMove, true, false)) {
                called = this._fireEvent(type, event) || called;
                this._firstMove = false;
            }
            break;
        }
        if (called)
            event.preventDefault();
        return called;
    }

});

var Http = {
    request: function(method, url, callback) {
        var xhr = new (window.ActiveXObject || XMLHttpRequest)(
                    'Microsoft.XMLHTTP');
        xhr.open(method.toUpperCase(), url, true);
        if ('overrideMimeType' in xhr)
            xhr.overrideMimeType('text/plain');
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                var status = xhr.status;
                if (status === 0 || status === 200) {
                    callback.call(xhr, xhr.responseText);
                } else {
                    throw new Error('Could not load ' + url + ' (Error '
                            + status + ')');
                }
            }
        };
        return xhr.send(null);
    }
};

var CanvasProvider = {
    canvases: [],

    getCanvas: function(width, height) {
        var canvas,
            clear = true;
        if (typeof width === 'object') {
            height = width.height;
            width = width.width;
        }
        if ( noCanvas ) {
            return { getContext: function() {} };
        }
        if (this.canvases.length) {
            canvas = this.canvases.pop();
        } else {
            canvas = document.createElement('canvas');
        }
        var ctx = canvas.getContext('2d');
        if (canvas.width === width && canvas.height === height) {
            if (clear)
                ctx.clearRect(0, 0, width + 1, height + 1);
        } else {
            canvas.width = width;
            canvas.height = height;
        }
        ctx.save();
        return canvas;
    },

    getContext: function(width, height) {
        return this.getCanvas(width, height).getContext('2d');
    },

    release: function(obj) {
        var canvas = obj.canvas ? obj.canvas : obj;
        canvas.getContext('2d').restore();
        this.canvases.push(canvas);
    }
};

var BlendMode = new function() {console.log('there');
    if ( noCanvas ) {
        return;
    }

    var min = Math.min,
        max = Math.max,
        abs = Math.abs,
        sr, sg, sb, sa, 
        br, bg, bb, ba, 
        dr, dg, db;     

    function getLum(r, g, b) {
        return 0.2989 * r + 0.587 * g + 0.114 * b;
    }

    function setLum(r, g, b, l) {
        var d = l - getLum(r, g, b);
        dr = r + d;
        dg = g + d;
        db = b + d;
        var l = getLum(dr, dg, db),
            mn = min(dr, dg, db),
            mx = max(dr, dg, db);
        if (mn < 0) {
            var lmn = l - mn;
            dr = l + (dr - l) * l / lmn;
            dg = l + (dg - l) * l / lmn;
            db = l + (db - l) * l / lmn;
        }
        if (mx > 255) {
            var ln = 255 - l,
                mxl = mx - l;
            dr = l + (dr - l) * ln / mxl;
            dg = l + (dg - l) * ln / mxl;
            db = l + (db - l) * ln / mxl;
        }
    }

    function getSat(r, g, b) {
        return max(r, g, b) - min(r, g, b);
    }

    function setSat(r, g, b, s) {
        var col = [r, g, b],
            mx = max(r, g, b), 
            mn = min(r, g, b), 
            md; 
        mn = mn === r ? 0 : mn === g ? 1 : 2;
        mx = mx === r ? 0 : mx === g ? 1 : 2;
        md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
        if (col[mx] > col[mn]) {
            col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
            col[mx] = s;
        } else {
            col[md] = col[mx] = 0;
        }
        col[mn] = 0;
        dr = col[0];
        dg = col[1];
        db = col[2];
    }

    var modes = {
        multiply: function() {
            dr = br * sr / 255;
            dg = bg * sg / 255;
            db = bb * sb / 255;
        },

        screen: function() {
            dr = br + sr - (br * sr / 255);
            dg = bg + sg - (bg * sg / 255);
            db = bb + sb - (bb * sb / 255);
        },

        overlay: function() {
            dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
            dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
            db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
        },

        'soft-light': function() {
            var t = sr * br / 255;
            dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
            t = sg * bg / 255;
            dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
            t = sb * bb / 255;
            db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
        },

        'hard-light': function() {
            dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
            dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
            db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
        },

        'color-dodge': function() {
            dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
            dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
            db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
        },

        'color-burn': function() {
            dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
            dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
            db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
        },

        darken: function() {
            dr = br < sr ? br : sr;
            dg = bg < sg ? bg : sg;
            db = bb < sb ? bb : sb;
        },

        lighten: function() {
            dr = br > sr ? br : sr;
            dg = bg > sg ? bg : sg;
            db = bb > sb ? bb : sb;
        },

        difference: function() {
            dr = br - sr;
            if (dr < 0)
                dr = -dr;
            dg = bg - sg;
            if (dg < 0)
                dg = -dg;
            db = bb - sb;
            if (db < 0)
                db = -db;
        },

        exclusion: function() {
            dr = br + sr * (255 - br - br) / 255;
            dg = bg + sg * (255 - bg - bg) / 255;
            db = bb + sb * (255 - bb - bb) / 255;
        },

        hue: function() {
            setSat(sr, sg, sb, getSat(br, bg, bb));
            setLum(dr, dg, db, getLum(br, bg, bb));
        },

        saturation: function() {
            setSat(br, bg, bb, getSat(sr, sg, sb));
            setLum(dr, dg, db, getLum(br, bg, bb));
        },

        luminosity: function() {
            setLum(br, bg, bb, getLum(sr, sg, sb));
        },

        color: function() {
            setLum(sr, sg, sb, getLum(br, bg, bb));
        },

        add: function() {
            dr = min(br + sr, 255);
            dg = min(bg + sg, 255);
            db = min(bb + sb, 255);
        },

        subtract: function() {
            dr = max(br - sr, 0);
            dg = max(bg - sg, 0);
            db = max(bb - sb, 0);
        },

        average: function() {
            dr = (br + sr) / 2;
            dg = (bg + sg) / 2;
            db = (bb + sb) / 2;
        },

        negation: function() {
            dr = 255 - abs(255 - sr - br);
            dg = 255 - abs(255 - sg - bg);
            db = 255 - abs(255 - sb - bb);
        }
    };

    var nativeModes = this.nativeModes = Base.each([
        'source-over', 'source-in', 'source-out', 'source-atop',
        'destination-over', 'destination-in', 'destination-out',
        'destination-atop', 'lighter', 'darker', 'copy', 'xor'
    ], function(mode) {
        this[mode] = true;
    }, {});

    var ctx = CanvasProvider.getContext(1, 1);
    Base.each(modes, function(func, mode) {
        var darken = mode === 'darken',
            ok = false;
        ctx.save();
        try {
            ctx.fillStyle = darken ? '#300' : '#a00';
            ctx.fillRect(0, 0, 1, 1);
            ctx.globalCompositeOperation = mode;
            if (ctx.globalCompositeOperation === mode) {
                ctx.fillStyle = darken ? '#a00' : '#300';
                ctx.fillRect(0, 0, 1, 1);
                ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
            }
        } catch (e) {}
        ctx.restore();
        nativeModes[mode] = ok;
    });
    CanvasProvider.release(ctx);

    this.process = function(mode, srcContext, dstContext, alpha, offset) {
        var srcCanvas = srcContext.canvas,
            normal = mode === 'normal';
        if (normal || nativeModes[mode]) {
            dstContext.save();
            dstContext.setTransform(1, 0, 0, 1, 0, 0);
            dstContext.globalAlpha = alpha;
            if (!normal)
                dstContext.globalCompositeOperation = mode;
            dstContext.drawImage(srcCanvas, offset.x, offset.y);
            dstContext.restore();
        } else {
            var process = modes[mode];
            if (!process)
                return;
            var dstData = dstContext.getImageData(offset.x, offset.y,
                    srcCanvas.width, srcCanvas.height),
                dst = dstData.data,
                src = srcContext.getImageData(0, 0,
                    srcCanvas.width, srcCanvas.height).data;
            for (var i = 0, l = dst.length; i < l; i += 4) {
                sr = src[i];
                br = dst[i];
                sg = src[i + 1];
                bg = dst[i + 1];
                sb = src[i + 2];
                bb = dst[i + 2];
                sa = src[i + 3];
                ba = dst[i + 3];
                process();
                var a1 = sa * alpha / 255,
                    a2 = 1 - a1;
                dst[i] = a1 * dr + a2 * br;
                dst[i + 1] = a1 * dg + a2 * bg;
                dst[i + 2] = a1 * db + a2 * bb;
                dst[i + 3] = sa * alpha + a2 * ba;
            }
            dstContext.putImageData(dstData, offset.x, offset.y);
        }
    };
};

var SVGStyles = Base.each({
    fillColor: ['fill', 'color'],
    strokeColor: ['stroke', 'color'],
    strokeWidth: ['stroke-width', 'number'],
    strokeCap: ['stroke-linecap', 'string'],
    strokeJoin: ['stroke-linejoin', 'string'],
    strokeScaling: ['vector-effect', 'lookup', {
        true: 'none',
        false: 'non-scaling-stroke'
    }, function(item, value) {
        return !value 
                && (item instanceof PathItem
                    || item instanceof Shape
                    || item instanceof TextItem);
    }],
    miterLimit: ['stroke-miterlimit', 'number'],
    dashArray: ['stroke-dasharray', 'array'],
    dashOffset: ['stroke-dashoffset', 'number'],
    fontFamily: ['font-family', 'string'],
    fontWeight: ['font-weight', 'string'],
    fontSize: ['font-size', 'number'],
    justification: ['text-anchor', 'lookup', {
        left: 'start',
        center: 'middle',
        right: 'end'
    }],
    opacity: ['opacity', 'number'],
    blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
    var part = Base.capitalize(key),
        lookup = entry[2];
    this[key] = {
        type: entry[1],
        property: key,
        attribute: entry[0],
        toSVG: lookup,
        fromSVG: lookup && Base.each(lookup, function(value, name) {
            this[value] = name;
        }, {}),
        exportFilter: entry[3],
        get: 'get' + part,
        set: 'set' + part
    };
}, {});

var SVGNamespaces = {
    href: 'http://www.w3.org/1999/xlink',
    xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
    var formatter;

    function setAttributes(node, attrs) {
        for (var key in attrs) {
            var val = attrs[key],
                namespace = SVGNamespaces[key];
            if (typeof val === 'number')
                val = formatter.number(val);
            if (namespace) {
                node.setAttributeNS(namespace, key, val);
            } else {
                node.setAttribute(key, val);
            }
        }
        return node;
    }

    function createElement(tag, attrs) {
        return setAttributes(
            document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
    }

    function getTransform(matrix, coordinates, center) {
        var attrs = new Base(),
            trans = matrix.getTranslation();
        if (coordinates) {
            matrix = matrix.shiftless();
            var point = matrix._inverseTransform(trans);
            attrs[center ? 'cx' : 'x'] = point.x;
            attrs[center ? 'cy' : 'y'] = point.y;
            trans = null;
        }
        if (!matrix.isIdentity()) {
            var decomposed = matrix.decompose();
            if (decomposed && !decomposed.shearing) {
                var parts = [],
                    angle = decomposed.rotation,
                    scale = decomposed.scaling;
                if (trans && !trans.isZero())
                    parts.push('translate(' + formatter.point(trans) + ')');
                if (angle)
                    parts.push('rotate(' + formatter.number(angle) + ')');
                if (!Numerical.isZero(scale.x - 1)
                        || !Numerical.isZero(scale.y - 1))
                    parts.push('scale(' + formatter.point(scale) +')');
                attrs.transform = parts.join(' ');
            } else {
                attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
            }
        }
        return attrs;
    }

    function exportGroup(item, options) {
        var attrs = getTransform(item._matrix),
            children = item._children;
        var node = createElement('g', attrs);
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            var childNode = exportSVG(child, options);
            if (childNode) {
                if (child.isClipMask()) {
                    var clip = createElement('clipPath');
                    clip.appendChild(childNode);
                    setDefinition(child, clip, 'clip');
                    setAttributes(node, {
                        'clip-path': 'url(#' + clip.id + ')'
                    });
                } else {
                    node.appendChild(childNode);
                }
            }
        }
        return node;
    }

    function exportRaster(item) {
        var attrs = getTransform(item._matrix, true),
            size = item.getSize();
        attrs.x -= size.width / 2;
        attrs.y -= size.height / 2;
        attrs.width = size.width;
        attrs.height = size.height;
        attrs.href = item.toDataURL();
        return createElement('image', attrs);
    }

    function exportPath(item, options) {
        if (options.matchShapes) {
            var shape = item.toShape(false);
            if (shape)
                return exportShape(shape, options);
        }
        var segments = item._segments,
            type,
            attrs = getTransform(item._matrix);
        if (segments.length === 0)
            return null;
        if (item.isPolygon()) {
            if (segments.length >= 3) {
                type = item._closed ? 'polygon' : 'polyline';
                var parts = [];
                for(i = 0, l = segments.length; i < l; i++)
                    parts.push(formatter.point(segments[i]._point));
                attrs.points = parts.join(' ');
            } else {
                type = 'line';
                var first = segments[0]._point,
                    last = segments[segments.length - 1]._point;
                attrs.set({
                    x1: first.x,
                    y1: first.y,
                    x2: last.x,
                    y2: last.y
                });
            }
        } else {
            type = 'path';
            attrs.d = item.getPathData(null, options.precision);
        }
        return createElement(type, attrs);
    }

    function exportShape(item) {
        var type = item._type,
            radius = item._radius,
            attrs = getTransform(item._matrix, true, type !== 'rectangle');
        if (type === 'rectangle') {
            type = 'rect'; 
            var size = item._size,
                width = size.width,
                height = size.height;
            attrs.x -= width / 2;
            attrs.y -= height / 2;
            attrs.width = width;
            attrs.height = height;
            if (radius.isZero())
                radius = null;
        }
        if (radius) {
            if (type === 'circle') {
                attrs.r = radius;
            } else {
                attrs.rx = radius.width;
                attrs.ry = radius.height;
            }
        }
        return createElement(type, attrs);
    }

    function exportCompoundPath(item, options) {
        var attrs = getTransform(item._matrix);
        var data = item.getPathData(null, options.precision);
        if (data)
            attrs.d = data;
        return createElement('path', attrs);
    }

    function exportPlacedSymbol(item, options) {
        var attrs = getTransform(item._matrix, true),
            symbol = item.getSymbol(),
            symbolNode = getDefinition(symbol, 'symbol'),
            definition = symbol.getDefinition(),
            bounds = definition.getBounds();
        if (!symbolNode) {
            symbolNode = createElement('symbol', {
                viewBox: formatter.rectangle(bounds)
            });
            symbolNode.appendChild(exportSVG(definition, options));
            setDefinition(symbol, symbolNode, 'symbol');
        }
        attrs.href = '#' + symbolNode.id;
        attrs.x += bounds.x;
        attrs.y += bounds.y;
        attrs.width = formatter.number(bounds.width);
        attrs.height = formatter.number(bounds.height);
        return createElement('use', attrs);
    }

    function exportGradient(color) {
        var gradientNode = getDefinition(color, 'color');
        if (!gradientNode) {
            var gradient = color.getGradient(),
                radial = gradient._radial,
                origin = color.getOrigin().transform(),
                destination = color.getDestination().transform(),
                attrs;
            if (radial) {
                attrs = {
                    cx: origin.x,
                    cy: origin.y,
                    r: origin.getDistance(destination)
                };
                var highlight = color.getHighlight();
                if (highlight) {
                    highlight = highlight.transform();
                    attrs.fx = highlight.x;
                    attrs.fy = highlight.y;
                }
            } else {
                attrs = {
                    x1: origin.x,
                    y1: origin.y,
                    x2: destination.x,
                    y2: destination.y
                };
            }
            attrs.gradientUnits = 'userSpaceOnUse';
            gradientNode = createElement(
                    (radial ? 'radial' : 'linear') + 'Gradient', attrs);
            var stops = gradient._stops;
            for (var i = 0, l = stops.length; i < l; i++) {
                var stop = stops[i],
                    stopColor = stop._color,
                    alpha = stopColor.getAlpha();
                attrs = {
                    offset: stop._rampPoint,
                    'stop-color': stopColor.toCSS(true)
                };
                if (alpha < 1)
                    attrs['stop-opacity'] = alpha;
                gradientNode.appendChild(createElement('stop', attrs));
            }
            setDefinition(color, gradientNode, 'color');
        }
        return 'url(#' + gradientNode.id + ')';
    }

    function exportText(item) {
        var node = createElement('text', getTransform(item._matrix, true));
        node.textContent = item._content;
        return node;
    }

    var exporters = {
        Group: exportGroup,
        Layer: exportGroup,
        Raster: exportRaster,
        Path: exportPath,
        Shape: exportShape,
        CompoundPath: exportCompoundPath,
        PlacedSymbol: exportPlacedSymbol,
        PointText: exportText
    };

    function applyStyle(item, node, isRoot) {
        var attrs = {},
            parent = !isRoot && item.getParent();

        if (item._name != null)
            attrs.id = item._name;

        Base.each(SVGStyles, function(entry) {
            var get = entry.get,
                type = entry.type,
                value = item[get]();
            if (entry.exportFilter
                    ? entry.exportFilter(item, value)
                    : !parent || !Base.equals(parent[get](), value)) {
                if (type === 'color' && value != null) {
                    var alpha = value.getAlpha();
                    if (alpha < 1)
                        attrs[entry.attribute + '-opacity'] = alpha;
                }
                attrs[entry.attribute] = value == null
                    ? 'none'
                    : type === 'number'
                        ? formatter.number(value)
                        : type === 'color'
                            ? value.gradient
                                ? exportGradient(value, item)
                                : value.toCSS(true)
                            : type === 'array'
                                ? value.join(',')
                                : type === 'lookup'
                                    ? entry.toSVG[value]
                                    : value;
            }
        });

        if (attrs.opacity === 1)
            delete attrs.opacity;

        if (!item._visible)
            attrs.visibility = 'hidden';

        return setAttributes(node, attrs);
    }

    var definitions;
    function getDefinition(item, type) {
        if (!definitions)
            definitions = { ids: {}, svgs: {} };
        return item && definitions.svgs[type + '-' + item._id];
    }

    function setDefinition(item, node, type) {
        if (!definitions)
            getDefinition();
        var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
        node.id = type + '-' + id;
        definitions.svgs[type + '-' + item._id] = node;
    }

    function exportDefinitions(node, options) {
        var svg = node,
            defs = null;
        if (definitions) {
            svg = node.nodeName.toLowerCase() === 'svg' && node;
            for (var i in definitions.svgs) {
                if (!defs) {
                    if (!svg) {
                        svg = createElement('svg');
                        svg.appendChild(node);
                    }
                    defs = svg.insertBefore(createElement('defs'),
                            svg.firstChild);
                }
                defs.appendChild(definitions.svgs[i]);
            }
            definitions = null;
        }
        return options.asString
                ? new XMLSerializer().serializeToString(svg)
                : svg;
    }

    function exportSVG(item, options, isRoot) {
        var exporter = exporters[item._class],
            node = exporter && exporter(item, options);
        if (node) {
            var onExport = options.onExport;
            if (onExport)
                node = onExport(item, node, options) || node;
            var data = JSON.stringify(item._data);
            if (data && data  !== '{}')
                node.setAttribute('data-paper-data', data);
        }
        return node && applyStyle(item, node, isRoot);
    }

    function setOptions(options) {
        if (!options)
            options = {};
        formatter = new Formatter(options.precision);
        return options;
    }

    Item.inject({
        exportSVG: function(options) {
            options = setOptions(options);
            return exportDefinitions(exportSVG(this, options, true), options);
        }
    });

    Project.inject({
        exportSVG: function(options) {
            options = setOptions(options);
            var layers = this.layers,
                view = this.getView(),
                size = view.getViewSize(),
                node = createElement('svg', {
                    x: 0,
                    y: 0,
                    width: size.width,
                    height: size.height,
                    version: '1.1',
                    xmlns: 'http://www.w3.org/2000/svg',
                    'xmlns:xlink': 'http://www.w3.org/1999/xlink'
                }),
                parent = node,
                matrix = view._matrix;
            if (!matrix.isIdentity())
                parent = node.appendChild(
                        createElement('g', getTransform(matrix)));
            for (var i = 0, l = layers.length; i < l; i++)
                parent.appendChild(exportSVG(layers[i], options, true));
            return exportDefinitions(node, options);
        }
    });
};

new function() {

    function getValue(node, name, isString, allowNull) {
        var namespace = SVGNamespaces[name],
            value = namespace
                ? node.getAttributeNS(namespace, name)
                : node.getAttribute(name);
        if (value === 'null')
            value = null;
        return value == null
                ? allowNull
                    ? null
                    : isString
                        ? ''
                        : 0
                : isString
                    ? value
                    : parseFloat(value);
    }

    function getPoint(node, x, y, allowNull) {
        x = getValue(node, x, false, allowNull);
        y = getValue(node, y, false, allowNull);
        return allowNull && (x == null || y == null) ? null
                : new Point(x, y);
    }

    function getSize(node, w, h, allowNull) {
        w = getValue(node, w, false, allowNull);
        h = getValue(node, h, false, allowNull);
        return allowNull && (w == null || h == null) ? null
                : new Size(w, h);
    }

    function convertValue(value, type, lookup) {
        return value === 'none'
                ? null
                : type === 'number'
                    ? parseFloat(value)
                    : type === 'array'
                        ? value ? value.split(/[\s,]+/g).map(parseFloat) : []
                        : type === 'color'
                            ? getDefinition(value) || value
                            : type === 'lookup'
                                ? lookup[value]
                                : value;
    }

    function importGroup(node, type, options, isRoot) {
        var nodes = node.childNodes,
            isClip = type === 'clippath',
            item = new Group(),
            project = item._project,
            currentStyle = project._currentStyle,
            children = [];
        if (!isClip) {
            item = applyAttributes(item, node, isRoot);
            project._currentStyle = item._style.clone();
        }
        for (var i = 0, l = nodes.length; i < l; i++) {
            var childNode = nodes[i],
                child;
            if (childNode.nodeType === 1
                    && (child = importSVG(childNode, options, false))
                    && !(child instanceof Symbol))
                children.push(child);
        }
        item.addChildren(children);
        if (isClip)
            item = applyAttributes(item.reduce(), node, isRoot);
        project._currentStyle = currentStyle;
        if (isClip || type === 'defs') {
            item.remove();
            item = null;
        }
        return item;
    }

    function importPoly(node, type) {
        var coords = node.getAttribute('points').match(
                    /[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
            points = [];
        for (var i = 0, l = coords.length; i < l; i += 2)
            points.push(new Point(
                    parseFloat(coords[i]),
                    parseFloat(coords[i + 1])));
        var path = new Path(points);
        if (type === 'polygon')
            path.closePath();
        return path;
    }

    function importPath(node) {
        var data = node.getAttribute('d'),
            param = { pathData: data };
        return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
                ? new CompoundPath(param)
                : new Path(param);
    }

    function importGradient(node, type) {
        var id = (getValue(node, 'href', true) || '').substring(1),
            isRadial = type === 'radialgradient',
            gradient;
        if (id) {
            gradient = definitions[id].getGradient();
        } else {
            var nodes = node.childNodes,
                stops = [];
            for (var i = 0, l = nodes.length; i < l; i++) {
                var child = nodes[i];
                if (child.nodeType === 1)
                    stops.push(applyAttributes(new GradientStop(), child));
            }
            gradient = new Gradient(stops, isRadial);
        }
        var origin, destination, highlight;
        if (isRadial) {
            origin = getPoint(node, 'cx', 'cy');
            destination = origin.add(getValue(node, 'r'), 0);
            highlight = getPoint(node, 'fx', 'fy', true);
        } else {
            origin = getPoint(node, 'x1', 'y1');
            destination = getPoint(node, 'x2', 'y2');
        }
        applyAttributes(
            new Color(gradient, origin, destination, highlight), node);
        return null;
    }

    var importers = {
        '#document': function (node, type, options, isRoot) {
            var nodes = node.childNodes;
            for (var i = 0, l = nodes.length; i < l; i++) {
                var child = nodes[i];
                if (child.nodeType === 1) {
                    var next = child.nextSibling;
                    document.body.appendChild(child);
                    var item = importSVG(child, options, isRoot);
                    if (next) {
                        node.insertBefore(child, next);
                    } else {
                        node.appendChild(child);
                    }
                    return item;
                }
            }
        },
        g: importGroup,
        svg: importGroup,
        clippath: importGroup,
        polygon: importPoly,
        polyline: importPoly,
        path: importPath,
        lineargradient: importGradient,
        radialgradient: importGradient,

        image: function (node) {
            var raster = new Raster(getValue(node, 'href', true));
            raster.on('load', function() {
                var size = getSize(node, 'width', 'height');
                this.setSize(size);
                var center = this._matrix._transformPoint(
                        getPoint(node, 'x', 'y').add(size.divide(2)));
                this.translate(center);
            });
            return raster;
        },

        symbol: function(node, type, options, isRoot) {
            return new Symbol(importGroup(node, type, options, isRoot), true);
        },

        defs: importGroup,

        use: function(node) {
            var id = (getValue(node, 'href', true) || '').substring(1),
                definition = definitions[id],
                point = getPoint(node, 'x', 'y');
            return definition
                    ? definition instanceof Symbol
                        ? definition.place(point)
                        : definition.clone().translate(point)
                    : null;
        },

        circle: function(node) {
            return new Shape.Circle(getPoint(node, 'cx', 'cy'),
                    getValue(node, 'r'));
        },

        ellipse: function(node) {
            return new Shape.Ellipse({
                center: getPoint(node, 'cx', 'cy'),
                radius: getSize(node, 'rx', 'ry')
            });
        },

        rect: function(node) {
            var point = getPoint(node, 'x', 'y'),
                size = getSize(node, 'width', 'height'),
                radius = getSize(node, 'rx', 'ry');
            return new Shape.Rectangle(new Rectangle(point, size), radius);
        },

        line: function(node) {
            return new Path.Line(getPoint(node, 'x1', 'y1'),
                    getPoint(node, 'x2', 'y2'));
        },

        text: function(node) {
            var text = new PointText(getPoint(node, 'x', 'y')
                    .add(getPoint(node, 'dx', 'dy')));
            text.setContent(node.textContent.trim() || '');
            return text;
        }
    };

    function applyTransform(item, value, name, node) {
        var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
            matrix = new Matrix();
        for (var i = 0, l = transforms.length; i < l; i++) {
            var transform = transforms[i];
            if (!transform)
                break;
            var parts = transform.split(/\(\s*/),
                command = parts[0],
                v = parts[1].split(/[\s,]+/g);
            for (var j = 0, m = v.length; j < m; j++)
                v[j] = parseFloat(v[j]);
            switch (command) {
            case 'matrix':
                matrix.concatenate(
                        new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
                break;
            case 'rotate':
                matrix.rotate(v[0], v[1], v[2]);
                break;
            case 'translate':
                matrix.translate(v[0], v[1]);
                break;
            case 'scale':
                matrix.scale(v);
                break;
            case 'skewX':
                matrix.skew(v[0], 0);
                break;
            case 'skewY':
                matrix.skew(0, v[0]);
                break;
            }
        }
        item.transform(matrix);
    }

    function applyOpacity(item, value, name) {
        var color = item[name === 'fill-opacity' ? 'getFillColor'
                : 'getStrokeColor']();
        if (color)
            color.setAlpha(parseFloat(value));
    }

    var attributes = Base.each(SVGStyles, function(entry) {
        this[entry.attribute] = function(item, value) {
            item[entry.set](convertValue(value, entry.type, entry.fromSVG));
            if (entry.type === 'color' && item instanceof Shape) {
                var color = item[entry.get]();
                if (color)
                    color.transform(new Matrix().translate(
                            item.getPosition(true).negate()));
            }
        };
    }, {
        id: function(item, value) {
            definitions[value] = item;
            if (item.setName)
                item.setName(value);
        },

        'clip-path': function(item, value) {
            var clip = getDefinition(value);
            if (clip) {
                clip = clip.clone();
                clip.setClipMask(true);
                if (item instanceof Group) {
                    item.insertChild(0, clip);
                } else {
                    return new Group(clip, item);
                }
            }
        },

        gradientTransform: applyTransform,
        transform: applyTransform,

        'fill-opacity': applyOpacity,
        'stroke-opacity': applyOpacity,

        visibility: function(item, value) {
            item.setVisible(value === 'visible');
        },

        display: function(item, value) {
            item.setVisible(value !== null);
        },

        'stop-color': function(item, value) {
            if (item.setColor)
                item.setColor(value);
        },

        'stop-opacity': function(item, value) {
            if (item._color)
                item._color.setAlpha(parseFloat(value));
        },

        offset: function(item, value) {
            var percentage = value.match(/(.*)%$/);
            item.setRampPoint(percentage
                    ? percentage[1] / 100
                    : parseFloat(value));
        },

        viewBox: function(item, value, name, node, styles) {
            var rect = new Rectangle(convertValue(value, 'array')),
                size = getSize(node, 'width', 'height', true);
            if (item instanceof Group) {
                var scale = size ? rect.getSize().divide(size) : 1,
                    matrix = new Matrix().translate(rect.getPoint()).scale(scale);
                item.transform(matrix.inverted());
            } else if (item instanceof Symbol) {
                if (size)
                    rect.setSize(size);
                var clip = getAttribute(node, 'overflow', styles) != 'visible',
                    group = item._definition;
                if (clip && !rect.contains(group.getBounds())) {
                    clip = new Shape.Rectangle(rect).transform(group._matrix);
                    clip.setClipMask(true);
                    group.addChild(clip);
                }
            }
        }
    });

    function getAttribute(node, name, styles) {
        var attr = node.attributes[name],
            value = attr && attr.value;
        if (!value) {
            var style = Base.camelize(name);
            value = node.style[style];
            if (!value && styles.node[style] !== styles.parent[style])
                value = styles.node[style];
        }
        return !value
                ? undefined
                : value === 'none'
                    ? null
                    : value;
    }

    function applyAttributes(item, node, isRoot) {
        var styles = {
            node: DomElement.getStyles(node) || {},
            parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
        };
        Base.each(attributes, function(apply, name) {
            var value = getAttribute(node, name, styles);
            if (value !== undefined)
                item = Base.pick(apply(item, value, name, node, styles), item);
        });
        return item;
    }

    var definitions = {};
    function getDefinition(value) {
        var match = value && value.match(/\((?:#|)([^)']+)/);
        return match && definitions[match[1]];
    }

    function importSVG(source, options, isRoot) {
        if (!source)
            return null;
        if (!options) {
            options = {};
        } else if (typeof options === 'function') {
            options = { onLoad: options };
        }

        var node = source,
            scope = paper;

        function onLoadCallback(svg) {
            paper = scope;
            var item = importSVG(svg, options, isRoot),
                onLoad = options.onLoad,
                view = scope.project && scope.getView();
            if (onLoad)
                onLoad.call(this, item);
            view.update();
        }

        if (isRoot) {
            if (typeof source === 'string' && !/^.*</.test(source)) {
                node = document.getElementById(source);
                if (node) {
                    source = null;
                } else {
                    return Http.request('get', source, onLoadCallback);
                }
            } else if (typeof File !== 'undefined' && source instanceof File) {
                var reader = new FileReader();
                reader.onload = function() {
                    onLoadCallback(reader.result);
                };
                return reader.readAsText(source);
            }
        }

        if (typeof source === 'string')
            node = new DOMParser().parseFromString(source, 'image/svg+xml');
        if (!node.nodeName)
            throw new Error('Unsupported SVG source: ' + source);
        var type = node.nodeName.toLowerCase(),
            importer = importers[type],
            item,
            data = node.getAttribute && node.getAttribute('data-paper-data'),
            settings = scope.settings,
            prevApplyMatrix = settings.applyMatrix;
        settings.applyMatrix = false;
        item = importer && importer(node, type, options, isRoot) || null;
        settings.applyMatrix = prevApplyMatrix;
        if (item) {
            if (type !== '#document' && !(item instanceof Group))
                item = applyAttributes(item, node, isRoot);
            var onImport = options.onImport;
            if (onImport)
                item = onImport(node, item, options) || item;
            if (options.expandShapes && item instanceof Shape) {
                item.remove();
                item = item.toPath();
            }
            if (data)
                item._data = JSON.parse(data);
        }
        if (isRoot)
            definitions = {};
        return item;
    }

    Item.inject({
        importSVG: function(node, options) {
            return this.addChild(importSVG(node, options, true));
        }
    });

    Project.inject({
        importSVG: function(node, options) {
            this.activate();
            return importSVG(node, options, true);
        }
    });
};

paper = new (PaperScope.inject(Base.exports, {
    enumerable: true,
    Base: Base,
    Numerical: Numerical,
    Key: Key
}))();

if (typeof define === 'function' && define.amd) {
    define('paper', paper);
} else if (typeof module === 'object' && module) { 
    module.exports = paper;
}

return paper;
};

}).call(this,require('_process'))
},{"_process":"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js"}],"/home/louisremi/Workspace/plumin.js/src/Contour.js":[function(require,module,exports){
var paper = require('../node_modules/paper/dist/paper-core.js');

function Contour( args ) {
	paper.Path.prototype.constructor.call( this, args );

	this.nodes = this.segments;
}

Contour.prototype = Object.create(paper.Path.prototype);
Contour.prototype.constructor = Contour;

Contour.prototype.addNodes = paper.Path.prototype.addSegments;

Contour.prototype.prepareOT = function( path ) {
	path.commands.push({
		type: 'M',
		x: Math.round( this.firstSegment.point.x ) || 0,
		y: Math.round( this.firstSegment.point.y ) || 0
	});

	this.curves.forEach(function( curve ) {
		if ( curve.isLinear() ) {
			path.commands.push({
				type: 'L',
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});

		} else {
			path.commands.push({
				type: 'C',
				x1: Math.round( curve.point1.x + curve.handle1.x ) || 0,
				y1: Math.round( curve.point1.y + curve.handle1.y ) || 0,
				x2: Math.round( curve.point2.x + curve.handle2.x ) || 0,
				y2: Math.round( curve.point2.y + curve.handle2.y ) || 0,
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});
		}
	});

	return path;
};

module.exports = Contour;
},{"../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js"}],"/home/louisremi/Workspace/plumin.js/src/Font.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	Glyph = require('./Glyph.js');

function Font( args ) {
	if ( !args ) {
		args = {};
	}

	if ( !args.styleName ) {
		args.styleName = 'Regular';
	}

	if ( !args.unitsPerEm ) {
		args.unitsPerEm = 1024;
	}

	this.ot = new opentype.Font( args );

	this.glyphs = [];
	this.glyphMap = {};
	this.charMap = {};
	this.altMap = {};
	this._subset = false;

	this.addGlyph(new Glyph({
		name: '.notdef',
		unicode: 0
	}));
}

Font.prototype.addGlyph = function( glyph ) {
	this.glyphs.push( glyph );
	this.glyphMap[glyph.name] = glyph;

	// build the default cmap
	// if multiple glyphs share the same unicode, use the glyph where unicode and name are equal
	if ( !this.charMap[glyph.unicode] ||
			( glyph.name.length === 1 && glyph.name.charCodeAt(0) === glyph.unicode ) ) {

		this.charMap[glyph.unicode] = glyph;
	}

	// build the alternates map
	if ( !this.altMap[glyph.unicode] ) {
		this.altMap[glyph.unicode] = [];
	}
	this.altMap[glyph.unicode].push( glyph );

	return this;
};

Font.prototype.addGlyphs = function( glyphs ) {
	glyphs.forEach(function( glyph ) {
		this.addGlyph(glyph);

	}, this);

	return this;
};

Object.defineProperty( Font.prototype, 'subset', {
	get: function() {
		return this._subset;
	},
	set: function( set ) {
		if ( set === false ) {
			return ( this._subset = false );
		}

		return ( this._subset = (typeof set === 'string' ? set.split('') : set)
			.filter(function(e, i, arr) {
				return arr.lastIndexOf(e) === i;
			})
			.map(function(e) {
				return e.charCodeAt(0);
			})
			.sort()
		);
	}
});

Font.prototype.getGlyphSubset = function( set ) {
	if ( set !== undefined ) {
		this.subset = set;
	}

	// reuse last subset if possible
	if ( this._lastSubset && this._lastSubset[0] === ( this._subset || [] ).join() ) {
		return this._lastSubset[1];
	}

	// memoize last subset
	this._lastSubset = [
		( this._subset || [] ).join(),
		this.glyphs.filter(function( glyph ) {
			if ( this._subset === false && ( glyph.unicode !== false || glyph.unicodes.length ) ) {
				return true;
			}

			if ( this._subset.indexOf( glyph.unicode ) !== -1 ) {
				return true;
			}

			// TODO: handle multiple unicodes

			return false;
		}, this)
	];

	return this._lastSubset[1];
};

Font.prototype.prepareOT = function( set ) {
	this.ot.glyphs = this.getGlyphSubset( set ).map(function( glyph ) {
		return glyph.prepareOT();
	});

	return this;
};

if ( typeof window === 'object' && window.document ) {

	var _URL = window.URL || window.webkitURL,
		ruleIndex;
	Font.prototype.addToFonts = document.fonts ?
		// CSS font loading, lightning fast
		function( buffer ) {
			var fontface = new FontFace(
				this.ot.familyName,
				buffer || this.ot.toBuffer()
			);

			document.fonts.add( fontface );

			if ( this.lastFontFace ) {
				document.fonts.delete( this.lastFontFace );
			}

			this.lastFontFace = fontface;

			return this;
		}:
		function( buffer ) {
			var url = _URL.createObjectURL(
				new Blob(
					[ new DataView( buffer ||this.ot.toBuffer() ) ],
					{type: 'font/opentype'}
				)
			);

			if ( ruleIndex ) {
				document.styleSheets[0].deleteRule( ruleIndex );
			}

			ruleIndex = document.styleSheets[0].insertRule(
				'@font-face { font-family: "' + this.ot.familyName + '"; src: url(' + url + '); }',
				ruleIndex ||document.styleSheets[0].cssRules.length
			);

			return this;
		};

	Font.prototype.download = function( buffer ) {
		var reader = new FileReader();

		reader.onloadend = function() {
			window.location = reader.result;
		};

		reader.readAsDataURL(new Blob(
			[ new DataView( buffer || this.ot.toBuffer() ) ],
			{type: 'font/opentype'}
		));

		return this;
	};

}

module.exports = Font;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js"}],"/home/louisremi/Workspace/plumin.js/src/Glyph.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-core.js');

function Glyph( args ) {
	paper.Group.prototype.constructor.apply( this );

	if ( args.unicode === undefined ) {
		args.unicode = args.name.charCodeAt(0);
	}

	if ( typeof args.unicode === 'string' ) {
		args.unicode = args.unicode.charCodeAt(0);
	}

	this.name = args.name;
	this.unicode = args.unicode;

	this.ot = new opentype.Glyph( args );
	this.ot.path = new opentype.Path();

	this.contours = [];
	this.anchors = [];
	this.components = [];
	this.parentAnchors = [];
}

Glyph.prototype = Object.create(paper.Group.prototype);
Glyph.prototype.constructor = Glyph;

Glyph.prototype.addContour = function( item ) {
	this.addChild( item );
	this.contours.push( item );
	return this;
};

Glyph.prototype.addComponent = function( item ) {
	this.addChild( item );
	this.components.push( item );
	return this;
};

Glyph.prototype.addAnchor = function( item ) {
	this.anchors.push( item );
	return this;
};

Glyph.prototype.addParentAnchor = function( item ) {
	this.parentAnchors.push( item );
	return this;
};

Glyph.prototype.prepareOT = function( path ) {
	if ( !path ) {
		this.ot.path.commands = [];
		path = this.ot.path;
	}

	this.contours.forEach(function( contour ) {
		contour.prepareOT( this.ot.path );
	}, this);

	return this.ot;
};

module.exports = Glyph;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js"}],"/home/louisremi/Workspace/plumin.js/src/plumin.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-core.js'),
	Font = require('./Font.js'),
	Glyph = require('./Glyph.js'),
	Contour = require('./Contour.js');

function plumin() {}

plumin.opentype = opentype;
plumin.paper = paper;
plumin.Font = Font;
plumin.Glyph = Glyph;
plumin.Contour = Contour;
plumin.Node = paper.Segment;
plumin.Point = paper.Point;
plumin.Matrix = paper.Matrix;
plumin.setup = paper.setup.bind(paper);

module.exports = plumin;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-core.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-core.js","./Contour.js":"/home/louisremi/Workspace/plumin.js/src/Contour.js","./Font.js":"/home/louisremi/Workspace/plumin.js/src/Font.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js"}]},{},["/home/louisremi/Workspace/plumin.js/src/plumin.js"])("/home/louisremi/Workspace/plumin.js/src/plumin.js")
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9jaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZHJhdy5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2ZvbnQuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2dseXBoLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9vcGVudHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3BhdGguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvY2ZmLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvY21hcC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dseWYuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9ncG9zLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvaGVhZC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hoZWEuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9obXR4LmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMva2Vybi5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2xvY2EuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9tYXhwLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvbmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL29zMi5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL3Bvc3QuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9zZm50LmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMiLCJzcmMvQ29udG91ci5qcyIsInNyYy9Gb250LmpzIiwic3JjL0dseXBoLmpzIiwic3JjL3BsdW1pbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsellBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hcmd1bWVudCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5hcmd1bWVudDtcbiIsIi8vIERyYXdpbmcgdXRpbGl0eSBmdW5jdGlvbnMuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRHJhdyBhIGxpbmUgb24gdGhlIGdpdmVuIGNvbnRleHQgZnJvbSBwb2ludCBgeDEseTFgIHRvIHBvaW50IGB4Mix5MmAuXG5mdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5cbmV4cG9ydHMubGluZSA9IGxpbmU7XG4iLCIvLyBHbHlwaCBlbmNvZGluZ1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjZmZTdGFuZGFyZFN0cmluZ3MgPSBbXG4gICAgJy5ub3RkZWYnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJyxcbiAgICAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJywgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JyxcbiAgICAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdlbmRhc2gnLCAnZGFnZ2VyJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdwYXJhZ3JhcGgnLFxuICAgICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLCAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLFxuICAgICdxdWVzdGlvbmRvd24nLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJ3JpbmcnLFxuICAgICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLCAnZW1kYXNoJywgJ0FFJywgJ29yZGZlbWluaW5lJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLFxuICAgICdvcmRtYXNjdWxpbmUnLCAnYWUnLCAnZG90bGVzc2knLCAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJywgJ29uZXN1cGVyaW9yJywgJ2xvZ2ljYWxub3QnLCAnbXUnLFxuICAgICd0cmFkZW1hcmsnLCAnRXRoJywgJ29uZWhhbGYnLCAncGx1c21pbnVzJywgJ1Rob3JuJywgJ29uZXF1YXJ0ZXInLCAnZGl2aWRlJywgJ2Jyb2tlbmJhcicsICdkZWdyZWUnLCAndGhvcm4nLFxuICAgICd0aHJlZXF1YXJ0ZXJzJywgJ3R3b3N1cGVyaW9yJywgJ3JlZ2lzdGVyZWQnLCAnbWludXMnLCAnZXRoJywgJ211bHRpcGx5JywgJ3RocmVlc3VwZXJpb3InLCAnY29weXJpZ2h0JyxcbiAgICAnQWFjdXRlJywgJ0FjaXJjdW1mbGV4JywgJ0FkaWVyZXNpcycsICdBZ3JhdmUnLCAnQXJpbmcnLCAnQXRpbGRlJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdFY2lyY3VtZmxleCcsXG4gICAgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnTnRpbGRlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsXG4gICAgJ09kaWVyZXNpcycsICdPZ3JhdmUnLCAnT3RpbGRlJywgJ1NjYXJvbicsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLCAnVWRpZXJlc2lzJywgJ1VncmF2ZScsICdZYWN1dGUnLFxuICAgICdZZGllcmVzaXMnLCAnWmNhcm9uJywgJ2FhY3V0ZScsICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYWdyYXZlJywgJ2FyaW5nJywgJ2F0aWxkZScsICdjY2VkaWxsYScsICdlYWN1dGUnLFxuICAgICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLCAnZWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnaWdyYXZlJywgJ250aWxkZScsICdvYWN1dGUnLFxuICAgICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLCAnb2dyYXZlJywgJ290aWxkZScsICdzY2Fyb24nLCAndWFjdXRlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICd1Z3JhdmUnLFxuICAgICd5YWN1dGUnLCAneWRpZXJlc2lzJywgJ3pjYXJvbicsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJzI2NiBmZicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJywgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLFxuICAgICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsXG4gICAgJ3F1ZXN0aW9uc21hbGwnLCAnYXN1cGVyaW9yJywgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICdpc3VwZXJpb3InLCAnbHN1cGVyaW9yJyxcbiAgICAnbXN1cGVyaW9yJywgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnZmYnLCAnZmZpJywgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJ2V4Y2xhbWRvd25zbWFsbCcsXG4gICAgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJywgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsXG4gICAgJ0RvdGFjY2VudHNtYWxsJywgJ01hY3JvbnNtYWxsJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsXG4gICAgJ3plcm9zdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJywgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLFxuICAgICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLCAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJyxcbiAgICAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJywgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLFxuICAgICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJywgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLFxuICAgICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLCAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsXG4gICAgJ09hY3V0ZXNtYWxsJywgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsXG4gICAgJ1VhY3V0ZXNtYWxsJywgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCcsICcwMDEuMDAwJyxcbiAgICAnMDAxLjAwMScsICcwMDEuMDAyJywgJzAwMS4wMDMnLCAnQmxhY2snLCAnQm9sZCcsICdCb29rJywgJ0xpZ2h0JywgJ01lZGl1bScsICdSZWd1bGFyJywgJ1JvbWFuJywgJ1NlbWlib2xkJ107XG5cbnZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJyxcbiAgICAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICcnLCAnZW5kYXNoJywgJ2RhZ2dlcicsXG4gICAgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICcnLCAncGFyYWdyYXBoJywgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsXG4gICAgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJywgJycsICdxdWVzdGlvbmRvd24nLCAnJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLFxuICAgICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJycsICdyaW5nJywgJ2NlZGlsbGEnLCAnJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLFxuICAgICdlbWRhc2gnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ0FFJywgJycsICdvcmRmZW1pbmluZScsICcnLCAnJywgJycsXG4gICAgJycsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJywgJ29yZG1hc2N1bGluZScsICcnLCAnJywgJycsICcnLCAnJywgJ2FlJywgJycsICcnLCAnJywgJ2RvdGxlc3NpJywgJycsICcnLFxuICAgICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnXTtcblxudmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAndHdvZG90ZW5sZWFkZXInLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ2ZyYWN0aW9uJywgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsICdxdWVzdGlvbnNtYWxsJywgJycsICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnJywgJycsICdpc3VwZXJpb3InLCAnJywgJycsICdsc3VwZXJpb3InLCAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICcnLCAnJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJycsICdmZicsICdmaScsICdmbCcsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAnJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJywgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICcnLCAnJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLCAnJywgJ0RvdGFjY2VudHNtYWxsJywgJycsICcnLCAnTWFjcm9uc21hbGwnLCAnJywgJycsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnJywgJycsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJywgJycsICcnLCAnJywgJ29uZXF1YXJ0ZXInLCAnb25laGFsZicsICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJywgJycsXG4gICAgJycsICd6ZXJvc3VwZXJpb3InLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLCAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLCAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJywgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJywgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJ107XG5cbnZhciBzdGFuZGFyZE5hbWVzID0gW1xuICAgICcubm90ZGVmJywgJy5udWxsJywgJ25vbm1hcmtpbmdyZXR1cm4nLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLFxuICAgICdhbXBlcnNhbmQnLCAncXVvdGVzaW5nbGUnLCAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJyxcbiAgICAnemVybycsICdvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsXG4gICAgJ2VxdWFsJywgJ2dyZWF0ZXInLCAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLFxuICAgICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsXG4gICAgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLCAnZ3JhdmUnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLFxuICAgICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLFxuICAgICdBZGllcmVzaXMnLCAnQXJpbmcnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ050aWxkZScsICdPZGllcmVzaXMnLCAnVWRpZXJlc2lzJywgJ2FhY3V0ZScsICdhZ3JhdmUnLFxuICAgICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYXRpbGRlJywgJ2FyaW5nJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsICdlZ3JhdmUnLCAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJyxcbiAgICAnaWFjdXRlJywgJ2lncmF2ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnbnRpbGRlJywgJ29hY3V0ZScsICdvZ3JhdmUnLCAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJyxcbiAgICAnb3RpbGRlJywgJ3VhY3V0ZScsICd1Z3JhdmUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ2RhZ2dlcicsICdkZWdyZWUnLCAnY2VudCcsICdzdGVybGluZycsICdzZWN0aW9uJyxcbiAgICAnYnVsbGV0JywgJ3BhcmFncmFwaCcsICdnZXJtYW5kYmxzJywgJ3JlZ2lzdGVyZWQnLCAnY29weXJpZ2h0JywgJ3RyYWRlbWFyaycsICdhY3V0ZScsICdkaWVyZXNpcycsICdub3RlcXVhbCcsXG4gICAgJ0FFJywgJ09zbGFzaCcsICdpbmZpbml0eScsICdwbHVzbWludXMnLCAnbGVzc2VxdWFsJywgJ2dyZWF0ZXJlcXVhbCcsICd5ZW4nLCAnbXUnLCAncGFydGlhbGRpZmYnLCAnc3VtbWF0aW9uJyxcbiAgICAncHJvZHVjdCcsICdwaScsICdpbnRlZ3JhbCcsICdvcmRmZW1pbmluZScsICdvcmRtYXNjdWxpbmUnLCAnT21lZ2EnLCAnYWUnLCAnb3NsYXNoJywgJ3F1ZXN0aW9uZG93bicsXG4gICAgJ2V4Y2xhbWRvd24nLCAnbG9naWNhbG5vdCcsICdyYWRpY2FsJywgJ2Zsb3JpbicsICdhcHByb3hlcXVhbCcsICdEZWx0YScsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxsZW1vdHJpZ2h0JyxcbiAgICAnZWxsaXBzaXMnLCAnbm9uYnJlYWtpbmdzcGFjZScsICdBZ3JhdmUnLCAnQXRpbGRlJywgJ090aWxkZScsICdPRScsICdvZScsICdlbmRhc2gnLCAnZW1kYXNoJywgJ3F1b3RlZGJsbGVmdCcsXG4gICAgJ3F1b3RlZGJscmlnaHQnLCAncXVvdGVsZWZ0JywgJ3F1b3RlcmlnaHQnLCAnZGl2aWRlJywgJ2xvemVuZ2UnLCAneWRpZXJlc2lzJywgJ1lkaWVyZXNpcycsICdmcmFjdGlvbicsXG4gICAgJ2N1cnJlbmN5JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3F1b3Rlc2luZ2xiYXNlJyxcbiAgICAncXVvdGVkYmxiYXNlJywgJ3BlcnRob3VzYW5kJywgJ0FjaXJjdW1mbGV4JywgJ0VjaXJjdW1mbGV4JywgJ0FhY3V0ZScsICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsXG4gICAgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JywgJ2FwcGxlJywgJ09ncmF2ZScsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLFxuICAgICdVZ3JhdmUnLCAnZG90bGVzc2knLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ3JpbmcnLCAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLFxuICAgICdvZ29uZWsnLCAnY2Fyb24nLCAnTHNsYXNoJywgJ2xzbGFzaCcsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1pjYXJvbicsICd6Y2Fyb24nLCAnYnJva2VuYmFyJywgJ0V0aCcsICdldGgnLFxuICAgICdZYWN1dGUnLCAneWFjdXRlJywgJ1Rob3JuJywgJ3Rob3JuJywgJ21pbnVzJywgJ211bHRpcGx5JywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLFxuICAgICdvbmVoYWxmJywgJ29uZXF1YXJ0ZXInLCAndGhyZWVxdWFydGVycycsICdmcmFuYycsICdHYnJldmUnLCAnZ2JyZXZlJywgJ0lkb3RhY2NlbnQnLCAnU2NlZGlsbGEnLCAnc2NlZGlsbGEnLFxuICAgICdDYWN1dGUnLCAnY2FjdXRlJywgJ0NjYXJvbicsICdjY2Fyb24nLCAnZGNyb2F0J107XG5cbi8vIFRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgZm9yIGZvbnRzIGNyZWF0ZWQgZnJvbSBzY3JhdGNoLlxuLy8gSXQgbG9vcHMgdGhyb3VnaCBhbGwgZ2x5cGhzIGFuZCBmaW5kcyB0aGUgYXBwcm9wcmlhdGUgdW5pY29kZSB2YWx1ZS5cbi8vIFNpbmNlIGl0J3MgbGluZWFyIHRpbWUsIG90aGVyIGVuY29kaW5ncyB3aWxsIGJlIGZhc3Rlci5cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY29kZSwgZ2x5cGhzLCBpLCBnbHlwaCwgajtcbiAgICBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHM7XG4gICAgaWYgKGdseXBocykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY2hhckNvZGVBdCgwKV0gfHwgMDtcbn07XG5cbmZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG59XG5cbkNmZkVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgY29kZSwgY2hhck5hbWU7XG4gICAgY29kZSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICBjaGFyTmFtZSA9IHRoaXMuZW5jb2RpbmdbY29kZV07XG4gICAgcmV0dXJuIHRoaXMuY2hhcnNldC5pbmRleE9mKGNoYXJOYW1lKTtcbn07XG5cbmZ1bmN0aW9uIEdseXBoTmFtZXMocG9zdCkge1xuICAgIHZhciBpO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICB0aGlzLm5hbWVzID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPCBleHBvcnRzLnN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IGV4cG9ydHMuc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IHBvc3QubmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXSAtIGV4cG9ydHMuc3RhbmRhcmROYW1lcy5sZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgMi41OlxuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzW2kgKyBwb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xufTtcblxuR2x5cGhOYW1lcy5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uIChnaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xufTtcblxuZnVuY3Rpb24gYWRkR2x5cGhOYW1lcyhmb250KSB7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAsIGNoYXJDb2RlcywgaSwgYywgZ2x5cGhJbmRleCwgZ2x5cGg7XG4gICAgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICBjaGFyQ29kZXMgPSBPYmplY3Qua2V5cyhnbHlwaEluZGV4TWFwKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hhckNvZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2dseXBoSW5kZXhdO1xuICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHNbaV07XG4gICAgICAgIGlmIChmb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmNmZlN0YW5kYXJkU3RyaW5ncyA9IGNmZlN0YW5kYXJkU3RyaW5ncztcbmV4cG9ydHMuY2ZmU3RhbmRhcmRFbmNvZGluZyA9IGNmZlN0YW5kYXJkRW5jb2Rpbmc7XG5leHBvcnRzLmNmZkV4cGVydEVuY29kaW5nID0gY2ZmRXhwZXJ0RW5jb2Rpbmc7XG5leHBvcnRzLnN0YW5kYXJkTmFtZXMgPSBzdGFuZGFyZE5hbWVzO1xuZXhwb3J0cy5EZWZhdWx0RW5jb2RpbmcgPSBEZWZhdWx0RW5jb2Rpbmc7XG5leHBvcnRzLkNtYXBFbmNvZGluZyA9IENtYXBFbmNvZGluZztcbmV4cG9ydHMuQ2ZmRW5jb2RpbmcgPSBDZmZFbmNvZGluZztcbmV4cG9ydHMuR2x5cGhOYW1lcyA9IEdseXBoTmFtZXM7XG5leHBvcnRzLmFkZEdseXBoTmFtZXMgPSBhZGRHbHlwaE5hbWVzO1xuIiwiLy8gVGhlIEZvbnQgb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcbnZhciBzZm50ID0gcmVxdWlyZSgnLi90YWJsZXMvc2ZudCcpO1xudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xuXG4vLyBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4vLyBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuLy8gb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG5mdW5jdGlvbiBGb250KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBPUyBYIHdpbGwgY29tcGxhaW4gaWYgdGhlIG5hbWVzIGFyZSBlbXB0eSwgc28gd2UgcHV0IGEgc2luZ2xlIHNwYWNlIGV2ZXJ5d2hlcmUgYnkgZGVmYXVsdC5cbiAgICB0aGlzLmZhbWlseU5hbWUgPSBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnO1xuICAgIHRoaXMuc3R5bGVOYW1lID0gb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnO1xuICAgIHRoaXMuZGVzaWduZXIgPSBvcHRpb25zLmRlc2lnbmVyIHx8ICcgJztcbiAgICB0aGlzLmRlc2lnbmVyVVJMID0gb3B0aW9ucy5kZXNpZ25lclVSTCB8fCAnICc7XG4gICAgdGhpcy5tYW51ZmFjdHVyZXIgPSBvcHRpb25zLm1hbnVmYWN0dXJlciB8fCAnICc7XG4gICAgdGhpcy5tYW51ZmFjdHVyZXJVUkwgPSBvcHRpb25zLm1hbnVmYWN0dXJlclVSTCB8fCAnICc7XG4gICAgdGhpcy5saWNlbnNlID0gb3B0aW9ucy5saWNlbnNlIHx8ICcgJztcbiAgICB0aGlzLmxpY2Vuc2VVUkwgPSBvcHRpb25zLmxpY2Vuc2VVUkwgfHwgJyAnO1xuICAgIHRoaXMudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiB8fCAnVmVyc2lvbiAwLjEnO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uIHx8ICcgJztcbiAgICB0aGlzLmNvcHlyaWdodCA9IG9wdGlvbnMuY29weXJpZ2h0IHx8ICcgJztcbiAgICB0aGlzLnRyYWRlbWFyayA9IG9wdGlvbnMudHJhZGVtYXJrIHx8ICcgJztcbiAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcbiAgICB0aGlzLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgdGhpcy5nbHlwaHMgPSBvcHRpb25zLmdseXBocyB8fCBbXTtcbiAgICB0aGlzLmVuY29kaW5nID0gbmV3IGVuY29kaW5nLkRlZmF1bHRFbmNvZGluZyh0aGlzKTtcbiAgICB0aGlzLnRhYmxlcyA9IHt9O1xufVxuXG4vLyBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cbkZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4vLyBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuLy8gdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuLy8gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbi8vIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXggPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoYyk7XG4gICAgZ2x5cGggPSB0aGlzLmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHNbMF07IC8vIC5ub3RkZWZcbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbi8vIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbi8vIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG5Gb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGksIGMsIGdseXBocztcbiAgICBnbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gc1tpXTtcbiAgICAgICAgZ2x5cGhzLnB1c2godGhpcy5jaGFyVG9HbHlwaChjKSk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG59O1xuXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXggPSB0aGlzLm5hbWV0b0dseXBoSW5kZXgobmFtZSk7XG4gICAgZ2x5cGggPSB0aGlzLmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHNbMF07IC8vIC5ub3RkZWZcbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuRm9udC5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uIChnaWQpIHtcbiAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG59O1xuXG4vLyBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGtlcm5pbmcgcGFpciBiZXR3ZWVuIHRoZSBsZWZ0IGdseXBoIChvciBpdHMgaW5kZXgpXG4vLyBhbmQgdGhlIHJpZ2h0IGdseXBoIChvciBpdHMgaW5kZXgpLiBJZiBubyBrZXJuaW5nIHBhaXIgaXMgZm91bmQsIHJldHVybiAwLlxuLy8gVGhlIGtlcm5pbmcgdmFsdWUgZ2V0cyBhZGRlZCB0byB0aGUgYWR2YW5jZSB3aWR0aCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzcGFjaW5nXG4vLyBiZXR3ZWVuIGdseXBocy5cbkZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uIChsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuICAgIHJpZ2h0R2x5cGggPSByaWdodEdseXBoLmluZGV4IHx8IHJpZ2h0R2x5cGg7XG4gICAgdmFyIGdwb3NLZXJuaW5nID0gdGhpcy5nZXRHcG9zS2VybmluZ1ZhbHVlO1xuICAgIHJldHVybiBncG9zS2VybmluZyA/IGdwb3NLZXJuaW5nKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkgOlxuICAgICAgICAodGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMCk7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZWFjaCBnbHlwaCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbi8vIFRoZSBjYWxsYmFjayBnZXRzIGAoZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKWAuXG5Gb250LnByb3RvdHlwZS5mb3JFYWNoR2x5cGggPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGtlcm5pbmcsIGZvbnRTY2FsZSwgZ2x5cGhzLCBpLCBnbHlwaCwga2VybmluZ1ZhbHVlO1xuICAgIGlmICghdGhpcy5zdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAga2VybmluZyA9IG9wdGlvbnMua2VybmluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMua2VybmluZztcbiAgICBmb250U2NhbGUgPSAxIC8gdGhpcy51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjayhnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtlcm5pbmdWYWx1ZSA9IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuLy9cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuLy9cbi8vIFJldHVybnMgYSBQYXRoIG9iamVjdC5cbkZvbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBnbHlwaC5nZXRQYXRoKHgsIHksIGZvbnRTaXplKTtcbiAgICAgICAgZnVsbFBhdGguZXh0ZW5kKHBhdGgpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbn07XG5cbi8vIERyYXcgdGhlIHRleHQgb24gdGhlIGdpdmVuIGRyYXdpbmcgY29udGV4dC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLy8gRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbi8vIHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuIChkZWZhdWx0OiA3Milcbi8vIE9wdGlvbnMgaXMgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgY29udGFpbnM6XG4vLyAtIGtlcm5pbmcgLSBXaGV0aGVyIHRvIHRha2Uga2VybmluZyBpbmZvcm1hdGlvbiBpbnRvIGFjY291bnQuIChkZWZhdWx0OiB0cnVlKVxuRm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd1BvaW50cyhjdHgsIHgsIHksIGZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8vIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4vLyBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbi8vIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbi8vIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24gKGdseXBoLCB4LCB5LCBmb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3TWV0cmljcyhjdHgsIHgsIHksIGZvbnRTaXplKTtcbiAgICB9KTtcbn07XG5cbi8vIFZhbGlkYXRlXG5Gb250LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICB2YXIgZm9udCA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nQXR0cmlidXRlKGF0dHJOYW1lKSB7XG4gICAgICAgIGFzc2VydChmb250W2F0dHJOYW1lXSAmJiBmb250W2F0dHJOYW1lXS50cmltKCkubGVuZ3RoID4gMCwgJ05vICcgKyBhdHRyTmFtZSArICcgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdmYW1pbHlOYW1lJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCd3ZWlnaHROYW1lJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdtYW51ZmFjdHVyZXInKTtcbiAgICBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoJ2NvcHlyaWdodCcpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgndmVyc2lvbicpO1xuXG4gICAgLy8gRGltZW5zaW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0KHRoaXMudW5pdHNQZXJFbSA+IDAsICdObyB1bml0c1BlckVtIHNwZWNpZmllZC4nKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuRm9udC5wcm90b3R5cGUudG9UYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuXG5Gb250LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbml0aWF0ZSBhIGRvd25sb2FkIG9mIHRoZSBPcGVuVHlwZSBmb250LlxuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gdGhpcy5mYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyB0aGlzLnN0eWxlTmFtZSArICcub3RmJztcbiAgICB2YXIgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuXG4gICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0od2luZG93LlRFTVBPUkFSWSwgYnVmZmVyLmJ5dGVMZW5ndGgsIGZ1bmN0aW9uIChmcykge1xuICAgICAgICBmcy5yb290LmdldEZpbGUoZmlsZU5hbWUsIHtjcmVhdGU6IHRydWV9LCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uICh3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoYmxvYik7XG5cbiAgICAgICAgICAgICAgICAgd3JpdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dyaXRlZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW5nIHRvIHRoZSBmaWxlIHdpbGwgZG93bmxvYWQgaXQuXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufTtcblxuZXhwb3J0cy5Gb250ID0gRm9udDtcbiIsIi8vIFRoZSBHbHlwaCBvYmplY3RcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuL2NoZWNrJyk7XG52YXIgZHJhdyA9IHJlcXVpcmUoJy4vZHJhdycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG5mdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgdGhpcy5mb250ID0gb3B0aW9ucy5mb250IHx8IG51bGw7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnVuaWNvZGUgPSBvcHRpb25zLnVuaWNvZGUgfHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcbiAgICB0aGlzLnhNaW4gPSBvcHRpb25zLnhNaW4gfHwgMDtcbiAgICB0aGlzLnlNaW4gPSBvcHRpb25zLnlNaW4gfHwgMDtcbiAgICB0aGlzLnhNYXggPSBvcHRpb25zLnhNYXggfHwgMDtcbiAgICB0aGlzLnlNYXggPSBvcHRpb25zLnlNYXggfHwgMDtcbiAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8IG51bGw7XG59XG5cbkdseXBoLnByb3RvdHlwZS5hZGRVbmljb2RlID0gZnVuY3Rpb24gKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuLy9cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlLCBwLCBjb21tYW5kcywgY21kO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBwLmxpbmVUbyh4ICsgKGNtZC54ICogc2NhbGUpLCB5ICsgKC1jbWQueSAqIHNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogc2NhbGUpLCB5ICsgKC1jbWQueTEgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHAuY3VydmVUbyh4ICsgKGNtZC54MSAqIHNjYWxlKSwgeSArICgtY21kLnkxICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogc2NhbGUpLCB5ICsgKC1jbWQueTIgKiBzY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG59O1xuXG4vLyBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuLy8gcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbkdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnRvdXJzID0gW107XG4gICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vLyBDYWxjdWxhdGUgdGhlIHhNaW4veU1pbi94TWF4L3lNYXgvbHNiL3JzYiBmb3IgYSBHbHlwaC5cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICB2YXIgeENvb3JkcyA9IFtdO1xuICAgIHZhciB5Q29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSAhPT0gJ1onKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJyB8fCBjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngxKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiAwXG4gICAgfTtcbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vLyBEcmF3IHRoZSBnbHlwaCBvbiB0aGUgZ2l2ZW4gY29udGV4dC5cbi8vXG4vLyBjdHggLSBUaGUgZHJhd2luZyBjb250ZXh0LlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUsIGluIHBpeGVscyAoZGVmYXVsdDogNzIpLlxuR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSkuZHJhdyhjdHgpO1xufTtcblxuLy8gRHJhdyB0aGUgcG9pbnRzIG9mIHRoZSBnbHlwaC5cbi8vIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcblxuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIHZhciBqLCBQSV9TUSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgUElfU1EsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlLCBpLCBibHVlQ2lyY2xlcywgcmVkQ2lyY2xlcywgcGF0aCwgY21kO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgYmx1ZUNpcmNsZXMgPSBbXTtcbiAgICByZWRDaXJjbGVzID0gW107XG4gICAgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmx1ZUNpcmNsZXMucHVzaCh7eDogY21kLngsIHk6IC1jbWQueX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbWQueDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDEsIHk6IC1jbWQueTF9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8vIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMuXG4vLyBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbi8vIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbi8vIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbi8vXG4vLyBjdHggLSBUaGUgZHJhd2luZyBjb250ZXh0LlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUsIGluIHBpeGVscyAoZGVmYXVsdDogNzIpLlxuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB2YXIgc2NhbGU7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHNjYWxlID0gMSAvIHRoaXMuZm9udC51bml0c1BlckVtICogZm9udFNpemU7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgLy8gRHJhdyB0aGUgb3JpZ2luXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4LCAtMTAwMDAsIHgsIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHksIDEwMDAwLCB5KTtcbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLnhNaW4gKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHRoaXMueE1heCAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpLCAxMDAwMCwgeSArICgtdGhpcy55TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXRoaXMueU1heCAqIHNjYWxlKSk7XG4gICAgLy8gRHJhdyB0aGUgYWR2YW5jZSB3aWR0aFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLmFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHRoaXMuYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG59O1xuXG5leHBvcnRzLkdseXBoID0gR2x5cGg7XG4iLCIvLyBvcGVudHlwZS5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVib3gvb3BlbnR5cGUuanNcbi8vIChjKSAyMDE0IEZyZWRlcmlrIERlIEJsZXNlclxuLy8gb3BlbnR5cGUuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbi8qIGdsb2JhbCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFVpbnQ4QXJyYXksIFhNTEh0dHBSZXF1ZXN0ICAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKTtcbnZhciBfZm9udCA9IHJlcXVpcmUoJy4vZm9udCcpO1xudmFyIGdseXBoID0gcmVxdWlyZSgnLi9nbHlwaCcpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxudmFyIGNtYXAgPSByZXF1aXJlKCcuL3RhYmxlcy9jbWFwJyk7XG52YXIgY2ZmID0gcmVxdWlyZSgnLi90YWJsZXMvY2ZmJyk7XG52YXIgZ2x5ZiA9IHJlcXVpcmUoJy4vdGFibGVzL2dseWYnKTtcbnZhciBncG9zID0gcmVxdWlyZSgnLi90YWJsZXMvZ3BvcycpO1xudmFyIGhlYWQgPSByZXF1aXJlKCcuL3RhYmxlcy9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vdGFibGVzL2hoZWEnKTtcbnZhciBobXR4ID0gcmVxdWlyZSgnLi90YWJsZXMvaG10eCcpO1xudmFyIGtlcm4gPSByZXF1aXJlKCcuL3RhYmxlcy9rZXJuJyk7XG52YXIgbG9jYSA9IHJlcXVpcmUoJy4vdGFibGVzL2xvY2EnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi90YWJsZXMvbWF4cCcpO1xudmFyIF9uYW1lID0gcmVxdWlyZSgnLi90YWJsZXMvbmFtZScpO1xudmFyIG9zMiA9IHJlcXVpcmUoJy4vdGFibGVzL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3RhYmxlcy9wb3N0Jyk7XG5cbi8vIEZpbGUgbG9hZGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gQ29udmVydCBhIE5vZGUuanMgQnVmZmVyIHRvIGFuIEFycmF5QnVmZmVyXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBpLFxuICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKSxcbiAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YVtpXSA9IGJ1ZmZlcltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGxvYWRGcm9tRmlsZShwYXRoLCBjYWxsYmFjaykge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB0b0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBsb2FkRnJvbVVybCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ2dldCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4vLyBJZiB0aGUgZmlsZSBjb3VsZCBub3QgYmUgcGFyc2VkIChtb3N0IGxpa2VseSBiZWNhdXNlIGl0IGNvbnRhaW5zIFBvc3RzY3JpcHQgb3V0bGluZXMpXG4vLyB3ZSByZXR1cm4gYW4gZW1wdHkgRm9udCBvYmplY3Qgd2l0aCB0aGUgYHN1cHBvcnRlZGAgZmxhZyBzZXQgdG8gYGZhbHNlYC5cbmZ1bmN0aW9uIHBhcnNlQnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBmb250LCBkYXRhLCB2ZXJzaW9uLCBudW1UYWJsZXMsIGksIHAsIHRhZywgb2Zmc2V0LCBobXR4T2Zmc2V0LCBnbHlmT2Zmc2V0LCBsb2NhT2Zmc2V0LFxuICAgICAgICBjZmZPZmZzZXQsIGtlcm5PZmZzZXQsIGdwb3NPZmZzZXQsIGluZGV4VG9Mb2NGb3JtYXQsIG51bUdseXBocywgbG9jYVRhYmxlLFxuICAgICAgICBzaG9ydFZlcnNpb247XG4gICAgLy8gT3BlblR5cGUgZm9udHMgdXNlIGJpZyBlbmRpYW4gYnl0ZSBvcmRlcmluZy5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG4gICAgLy8gSW5zdGVhZCB3ZSB1c2UgRGF0YVZpZXdzIHdoZXJlIHdlIGNhbiBzcGVjaWZ5IGVuZGlhbm5lc3MuXG5cbiAgICBmb250ID0gbmV3IF9mb250LkZvbnQoKTtcbiAgICBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG5cbiAgICB2ZXJzaW9uID0gcGFyc2UuZ2V0Rml4ZWQoZGF0YSwgMCk7XG4gICAgaWYgKHZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB2ZXJzaW9uID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHZlcnNpb24gJyArIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuXG4gICAgLy8gT2Zmc2V0IGludG8gdGhlIHRhYmxlIHJlY29yZHMuXG4gICAgcCA9IDEyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAnY21hcCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5jbWFwID0gY21hcC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5DbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICBpZiAoIWZvbnQuZW5jb2RpbmcpIHtcbiAgICAgICAgICAgICAgICBmb250LnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgaG10eE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250Lm51bUdseXBocyA9IG51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmZhbWlseU5hbWUgPSBmb250LnRhYmxlcy5uYW1lLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBmb250LnN0eWxlTmFtZSA9IGZvbnQudGFibGVzLm5hbWUuZm9udFN1YmZhbWlseTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBlbmNvZGluZy5HbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgZ2x5Zk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgIGxvY2FPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ0ZGICc6XG4gICAgICAgICAgICBjZmZPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICBrZXJuT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgZ3Bvc09mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgaWYgKGdseWZPZmZzZXQgJiYgbG9jYU9mZnNldCkge1xuICAgICAgICBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuICAgICAgICBsb2NhVGFibGUgPSBsb2NhLnBhcnNlKGRhdGEsIGxvY2FPZmZzZXQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGRhdGEsIGdseWZPZmZzZXQsIGxvY2FUYWJsZSwgZm9udCk7XG4gICAgICAgIGhtdHgucGFyc2UoZGF0YSwgaG10eE9mZnNldCwgZm9udC5udW1iZXJPZkhNZXRyaWNzLCBmb250Lm51bUdseXBocywgZm9udC5nbHlwaHMpO1xuICAgICAgICBlbmNvZGluZy5hZGRHbHlwaE5hbWVzKGZvbnQpO1xuICAgIH0gZWxzZSBpZiAoY2ZmT2Zmc2V0KSB7XG4gICAgICAgIGNmZi5wYXJzZShkYXRhLCBjZmZPZmZzZXQsIGZvbnQpO1xuICAgICAgICBlbmNvZGluZy5hZGRHbHlwaE5hbWVzKGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvbnQuc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChrZXJuT2Zmc2V0KSB7XG4gICAgICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IGtlcm4ucGFyc2UoZGF0YSwga2Vybk9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChncG9zT2Zmc2V0KSB7XG4gICAgICAgICAgICBncG9zLnBhcnNlKGRhdGEsIGdwb3NPZmZzZXQsIGZvbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBhIGZpbGVzeXN0ZW0uIFdoZW4gZG9uZSwgY2FsbCB0aGUgY2FsbGJhY2tcbi8vIHdpdGggdHdvIGFyZ3VtZW50cyBgKGVyciwgZm9udClgLiBUaGUgYGVycmAgd2lsbCBiZSBudWxsIG9uIHN1Y2Nlc3MsXG4vLyB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG4vL1xuLy8gV2UgdXNlIHRoZSBub2RlLmpzIGNhbGxiYWNrIGNvbnZlbnRpb24gc28gdGhhdFxuLy8gb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cbmZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICB2YXIgbG9hZEZuID0gaXNOb2RlID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG4gICAgbG9hZEZuKHVybCwgZnVuY3Rpb24gKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIGlmICghZm9udC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnRm9udCBpcyBub3Qgc3VwcG9ydGVkIChpcyB0aGlzIGEgUG9zdHNjcmlwdCBmb250PyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuRm9udCA9IF9mb250LkZvbnQ7XG5leHBvcnRzLkdseXBoID0gZ2x5cGguR2x5cGg7XG5leHBvcnRzLlBhdGggPSBwYXRoLlBhdGg7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VCdWZmZXI7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuIiwiLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIGJ5dGUgZnJvbSB0aGUgRGF0YVZpZXcuXG5leHBvcnRzLmdldEJ5dGUgPSBmdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn07XG5cbmV4cG9ydHMuZ2V0Q2FyZDggPSBleHBvcnRzLmdldEJ5dGU7XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0VVNob3J0ID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufTtcblxuZXhwb3J0cy5nZXRDYXJkMTYgPSBleHBvcnRzLmdldFVTaG9ydDtcblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRTaG9ydCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xufTtcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMzItYml0IGxvbmcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFVMb25nID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufTtcblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRGaXhlZCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwsIGZyYWN0aW9uO1xuICAgIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG4gICAgcmV0dXJuIGRlY2ltYWwgKyBmcmFjdGlvbiAvIDY1NTM1O1xufTtcblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmV4cG9ydHMuZ2V0VGFnID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgdGFnID0gJycsIGk7XG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufTtcblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZXhwb3J0cy5nZXRPZmZzZXQgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCwgb2ZmU2l6ZSkge1xuICAgIHZhciBpLCB2O1xuICAgIHYgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG4vLyBSZXRyaWV2ZSBhIG51bWJlciBvZiBieXRlcyBmcm9tIHN0YXJ0IG9mZnNldCB0byB0aGUgZW5kIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbmV4cG9ydHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgYnl0ZXMsIGk7XG4gICAgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgdmFyIHMsIGk7XG4gICAgcyA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn07XG5cbnZhciB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkMTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNJRCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgZGF0YVZpZXcgPSB0aGlzLmRhdGEsXG4gICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGV4cG9ydHMuZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YSxcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0LFxuICAgICAgICBzdHJpbmcgPSAnJztcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHYgLyA2NTUzNjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ham9yID0gZXhwb3J0cy5nZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gVGhpcyByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGV4cG9ydHMuZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gMHgxMDAwIC8gMTA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAodHlwZSwgYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiIsIi8vIEdlb21ldHJpYyBvYmplY3RzXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQSBiw6l6aWVyIHBhdGggY29udGFpbmluZyBhIHNldCBvZiBwYXRoIGNvbW1hbmRzIHNpbWlsYXIgdG8gYSBTVkcgcGF0aC5cbi8vIFBhdGhzIGNhbiBiZSBkcmF3biBvbiBhIGNvbnRleHQgdXNpbmcgYGRyYXdgLlxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG59XG5cblBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdMJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnUScsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnWidcbiAgICB9KTtcbn07XG5cbi8vIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG5QYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLy8gRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBpLCBjbWQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuLy8gQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGRlY2ltYWxQbGFjZXM6IFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlcyAoZGVmYXVsdDogMilcblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgIGRlY2ltYWxQbGFjZXMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcblxuICAgIGZ1bmN0aW9uIGZsb2F0VG9TdHJpbmcodikge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgdmFyIGQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDtcbn07XG5cbi8vIENvbnZlcnQgdGhlIHBhdGggdG8gYSBTVkcgPHBhdGg+IGVsZW1lbnQsIGFzIGEgc3RyaW5nLlxuLy8gUGFyYW1ldGVyczpcbi8vIC0gZGVjaW1hbFBsYWNlczogVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzIChkZWZhdWx0OiAyKVxuUGF0aC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbiAoZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciBzdmcgPSAnPHBhdGggZD1cIic7XG4gICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBzdmcgKz0gJ1wiJztcbiAgICBpZiAodGhpcy5maWxsICYgdGhpcy5maWxsICE9PSAnYmxhY2snKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCJub25lXCInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIicgKyB0aGlzLmZpbGwgKyAnXCInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cbiAgICBzdmcgKz0gJy8+JztcbiAgICByZXR1cm4gc3ZnO1xufTtcblxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbiIsIi8vIFRhYmxlIG1ldGFkYXRhXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xudmFyIGVuY29kZSA9IHJlcXVpcmUoJy4vdHlwZXMnKS5lbmNvZGU7XG52YXIgc2l6ZU9mID0gcmVxdWlyZSgnLi90eXBlcycpLnNpemVPZjtcblxuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdiArPSB2YWx1ZS5zaXplT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCh0eXBlb2Ygc2l6ZU9mRnVuY3Rpb24gPT09ICdmdW5jdGlvbicsICdDb3VsZCBub3QgZmluZCBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkJyArIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgdiArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4iLCIvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4uL2VuY29kaW5nJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cywgb2JqZWN0cywgY291bnQsIGVuZE9mZnNldCwgb2Zmc2V0U2l6ZSwgb2JqZWN0T2Zmc2V0LCBwb3MsIGksIHZhbHVlO1xuICAgIG9mZnNldHMgPSBbXTtcbiAgICBvYmplY3RzID0gW107XG4gICAgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMsIGVvZiwgbG9va3VwLCBiLCBuMSwgbjI7XG4gICAgcyA9ICcnO1xuICAgIGVvZiA9IDE1O1xuICAgIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIG4xID0gYiA+PiA0O1xuICAgICAgICBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbywga2V5LCB2YWx1ZXMsIGksIHZhbHVlO1xuICAgIG8gPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICB2YXIgcGFyc2VyLCBlbnRyaWVzLCBvcGVyYW5kcywgb3A7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGVudHJpZXMgPSBbXTtcbiAgICBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIG0sIHZhbHVlLCBuZXdEaWN0O1xuICAgIG5ld0RpY3QgPSB7fTtcbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge25hbWU6ICdmb250TWF0cml4Jywgb3A6IDEyMDcsIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSwgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX1cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgcGFyc2VyLCBmb3JtYXQsIGNoYXJzZXQsIGksIHNpZCwgY291bnQ7XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgZW5jLCBwYXJzZXIsIGZvcm1hdCwgbkNvZGVzLCBpLCBjb2RlLCBuUmFuZ2VzLCBmaXJzdCwgbkxlZnQsIGo7XG4gICAgZW5jID0ge307XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblJhbmdlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhjb2RlLCBmb250LCBpbmRleCkge1xuICAgIHZhciBwLCBnbHlwaCwgc3RhY2ssIG5TdGVtcywgaGF2ZVdpZHRoLCB3aWR0aCwgeCwgeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB2O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgc3RhY2sgPSBbXTtcbiAgICBuU3RlbXMgPSAwO1xuICAgIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHdpZHRoID0gZm9udC5kZWZhdWx0V2lkdGhYO1xuICAgIHggPSB5ID0gMDtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgaSwgYjEsIGIyLCBiMywgYjQsIGNvZGVJbmRleCwgc3VickNvZGU7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5zdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAxMjogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLnBhdGggPSBwO1xuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBnbHlwaDtcbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIHZhciBoZWFkZXIsIG5hbWVJbmRleCwgdG9wRGljdEluZGV4LCBzdHJpbmdJbmRleCwgZ2xvYmFsU3VickluZGV4LCB0b3BEaWN0LCBwcml2YXRlRGljdE9mZnNldCwgcHJpdmF0ZURpY3QsXG4gICAgICAgIHN1YnJPZmZzZXQsIHN1YnJJbmRleCwgY2hhclN0cmluZywgY2hhclN0cmluZ3NJbmRleCwgY2hhcnNldCwgaTtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHRvcERpY3RJbmRleC5vYmplY3RzWzBdKS5idWZmZXIpO1xuICAgIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0Wydwcml2YXRlJ11bMV07XG4gICAgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0Wydwcml2YXRlJ11bMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG5cbiAgICBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7IC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jb2RpbmcuY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7IC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgZm9udC5nbHlwaHMucHVzaChwYXJzZUNGRkNoYXJzdHJpbmcoY2hhclN0cmluZywgZm9udCwgaSkpO1xuICAgIH1cbn1cblxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIHNpZDtcbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICBpID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnTmFtZSBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0Lm5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5uYW1lcy5wdXNoKHtuYW1lOiAnbmFtZV8nICsgaSwgdHlwZTogJ05BTUUnLCB2YWx1ZTogZm9udE5hbWVzW2ldfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge30sIGksIGVudHJ5LCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gYXR0cnNbZW50cnkubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTdHJpbmcodmFsdWUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIGRvbid0IHVzZSBzdWJyb3V0aW5lcy5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdLCBwYXRoID0gZ2x5cGgucGF0aCwgeCwgeSwgaSwgY21kLCBkeCwgZHksIGR4MSwgZHkxLCBkeDIsIGR5MjtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG4gICAgICAgICAgICB4ID0gY21kLng7XG4gICAgICAgICAgICB5ID0gY21kLnk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcbiAgICAgICAgICAgIHggPSBjbWQueDtcbiAgICAgICAgICAgIHkgPSBjbWQueTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogQWRkIHN1cHBvcnQgZm9yIHF1YWQgY3VydmVzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRpbmcgcXVhZCBjdXJ2ZXMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZHgxID0gY21kLngxIC0geDtcbiAgICAgICAgICAgIGR5MSA9IGNtZC55MSAtIHk7XG4gICAgICAgICAgICBkeDIgPSBjbWQueDIgLSBjbWQueDE7XG4gICAgICAgICAgICBkeTIgPSBjbWQueTIgLSBjbWQueTE7XG4gICAgICAgICAgICBkeCA9IGNtZC54IC0gY21kLngyO1xuICAgICAgICAgICAgZHkgPSBjbWQueSAtIGNtZC55MjtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuICAgICAgICAgICAgeCA9IGNtZC54O1xuICAgICAgICAgICAgeSA9IGNtZC55O1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHMucHVzaCh7bmFtZTogJ2VuZGNoYXInLCB0eXBlOiAnT1AnLCB2YWx1ZTogMTR9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnUHJpdmF0ZSBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdQcml2YXRlIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQucHJpdmF0ZURpY3RzID0gW3tuYW1lOiAncHJpdmF0ZURpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBwcml2YXRlRGljdH1dO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NGRiAnLCBbXG4gICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ31cbiAgICBdKTtcblxuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodDogb3B0aW9ucy53ZWlnaHROYW1lLFxuICAgICAgICBjaGFyc2V0OiA5OTksXG4gICAgICAgIGVuY29kaW5nOiAwLFxuICAgICAgICBjaGFyU3RyaW5nczogOTk5LFxuICAgICAgICBwcml2YXRlOiBbMCwgOTk5XVxuICAgIH07XG5cbiAgICB2YXIgcHJpdmF0ZUF0dHJzID0ge307XG5cbiAgICB2YXIgZ2x5cGhOYW1lcyA9IFtdO1xuICAgIC8vIFNraXAgZmlyc3QgZ2x5cGggKC5ub3RkZWYpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoc1tpXS5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG4gICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG4gICAgdC5uYW1lSW5kZXggPSBtYWtlTmFtZUluZGV4KFtvcHRpb25zLnBvc3RTY3JpcHROYW1lXSk7XG4gICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuICAgIHQuZ2xvYmFsU3VickluZGV4ID0gbWFrZUdsb2JhbFN1YnJJbmRleCgpO1xuICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG4gICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnByaXZhdGVEaWN0SW5kZXggPSBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCk7XG5cbiAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cbiAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdC5oZWFkZXIuc2l6ZU9mKCkgK1xuICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5zdHJpbmdJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcbiAgICBhdHRycy5lbmNvZGluZyA9IDA7IC8vIFdlIHVzZSB0aGUgQ0ZGIHN0YW5kYXJkIGVuY29kaW5nOyBwcm9wZXIgZW5jb2Rpbmcgd2lsbCBiZSBoYW5kbGVkIGluIGNtYXAuXG4gICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcbiAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cbiAgICAvLyBSZWNyZWF0ZSB0aGUgVG9wIERJQ1QgSU5ERVggd2l0aCB0aGUgY29ycmVjdCBvZmZzZXRzLlxuICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUNGRlRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUNGRlRhYmxlO1xuIiwiLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NtYXAuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0LlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHZlcnNpb24sIG51bVRhYmxlcywgb2Zmc2V0LCBwbGF0Zm9ybUlkLCBlbmNvZGluZ0lkLCBmb3JtYXQsIHNlZ0NvdW50LFxuICAgICAgICBlbmRDb3VudFBhcnNlciwgc3RhcnRDb3VudFBhcnNlciwgaWREZWx0YVBhcnNlciwgaWRSYW5nZU9mZnNldFBhcnNlciwgZ2x5cGhJbmRleE9mZnNldCxcbiAgICAgICAgZW5kQ291bnQsIHN0YXJ0Q291bnQsIGksIGMsIGlkRGVsdGEsIGlkUmFuZ2VPZmZzZXQsIHAsIGdseXBoSW5kZXg7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSB2ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudCh2ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtdGFibGVzID0gbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgb2Zmc2V0ID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuICAgICAgICBpZiAocGxhdGZvcm1JZCA9PT0gMyAmJiAoZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAwKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQsIHNvIHJldHVybiBudWxsLlxuICAgICAgICAvLyBUaGlzIGZvbnQgd2lsbCBiZSBtYXJrZWQgYXMgdW5zdXBwb3J0ZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBjbWFwLmZvcm1hdCA9IGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDQsICdPbmx5IGZvcm1hdCA0IGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyKTtcbiAgICBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0KTtcbiAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2KTtcbiAgICBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAoYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIHZhciBpLCBqLCBnbHlwaDtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxMn0sXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcblxuICAgIHQuc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdC5zZWdDb3VudFgyID0gc2VnQ291bnQgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHNlZ0NvdW50KSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXSxcbiAgICAgICAgc3RhcnRDb3VudHMgPSBbXSxcbiAgICAgICAgaWREZWx0YXMgPSBbXSxcbiAgICAgICAgaWRSYW5nZU9mZnNldHMgPSBbXSxcbiAgICAgICAgZ2x5cGhJZHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcbiAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGVuZENvdW50cyk7XG4gICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3Jlc2VydmVkUGFkJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoc3RhcnRDb3VudHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkRGVsdGFzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZFJhbmdlT2Zmc2V0cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZ2x5cGhJZHMpO1xuXG4gICAgdC5sZW5ndGggPSAxNCArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuICAgICAgICBzdGFydENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBnbHlwaElkcy5sZW5ndGggKiAyO1xuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VDbWFwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ21hcFRhYmxlO1xuIiwiLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9nbHlmLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZGF0YSwgc3RhcnQsIGluZGV4LCBmb250KSB7XG4gICAgdmFyIHAsIGdseXBoLCBmbGFnLCBpLCBqLCBmbGFncyxcbiAgICAgICAgZW5kUG9pbnRJbmRpY2VzLCBudW1iZXJPZkNvb3JkaW5hdGVzLCByZXBlYXRDb3VudCwgcG9pbnRzLCBwb2ludCwgcHgsIHB5LFxuICAgICAgICBjb21wb25lbnQsIG1vcmVDb21wb25lbnRzO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzLCBpLCBwdCwgbmV3UHQ7XG4gICAgbmV3UG9pbnRzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCwgY29udG91cnMsIGksIHJlYWxGaXJzdFBvaW50LCBqLCBjb250b3VyLCBwdCwgZmlyc3RQdCxcbiAgICAgICAgcHJldlB0LCBtaWRQdCwgY3VydmVQdCwgbGFzdFB0O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29udG91ciA9IGNvbnRvdXJzW2ldO1xuICAgICAgICBmaXJzdFB0ID0gY29udG91clswXTtcbiAgICAgICAgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gZmlyc3RQdDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCBpcyBzeW50aGVzaXplZCwgc28gZG9uJ3Qgc2tpcCB0aGUgcmVhbCBmaXJzdCBwb2ludC5cbiAgICAgICAgICAgIHJlYWxGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcC5tb3ZlVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuXG4gICAgICAgIGZvciAoaiA9IHJlYWxGaXJzdFBvaW50ID8gMSA6IDA7IGogPCBjb250b3VyLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICBwcmV2UHQgPSBqID09PSAwID8gZmlyc3RQdCA6IGNvbnRvdXJbaiAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2UHQub25DdXJ2ZSAmJiAhcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1pZFB0ID0geyB4OiAocHJldlB0LnggKyBwdC54KSAvIDIsIHk6IChwcmV2UHQueSArIHB0LnkpIC8gMiB9O1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhwcmV2UHQueCwgcHJldlB0LnksIG1pZFB0LngsIG1pZFB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91cyBwb2ludCBvZmYtY3VydmUsIHRoaXMgcG9pbnQgb24tY3VydmUuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFB0ICE9PSBsYXN0UHQpIHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGxhc3QgYW5kIGZpcnN0IHBvaW50c1xuICAgICAgICAgICAgaWYgKGN1cnZlUHQpIHtcbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC5saW5lVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMsIGksIGosIG9mZnNldCwgbmV4dE9mZnNldCwgZ2x5cGgsXG4gICAgICAgIGNvbXBvbmVudCwgY29tcG9uZW50R2x5cGgsIHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIGdseXBocyA9IFtdO1xuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChwYXJzZUdseXBoKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBpLCBmb250KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaX0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHbyBvdmVyIHRoZSBnbHlwaHMgYWdhaW4sIHJlc29sdmluZyB0aGUgY29tcG9zaXRlIGdseXBocy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRHbHlwaCA9IGdseXBoc1tjb21wb25lbnQuZ2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbHlwaC5wYXRoID0gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHbHlmVGFibGU7XG4iLCIvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBuID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIEZvcm1hdCAxIGlzIGEgc2ltcGxlIGxpc3Qgb2YgZ2x5cGggaWRzLFxuLy8gRm9ybWF0IDIgaXMgYSBsaXN0IG9mIHJhbmdlcy4gSXQgaXMgZXhwYW5kZWQgaW4gYSBsaXN0IG9mIGdseXBocywgbWF5YmUgbm90IHRoZSBiZXN0IGlkZWEuXG5mdW5jdGlvbiBwYXJzZUNvdmVyYWdlVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIGNvdW50ID0gIHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwLnBhcnNlVVNob3J0TGlzdChjb3VudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgaSwgYmVnaW4sIGVuZCwgaW5kZXgsIGNvdmVyYWdlID0gW107XG4gICAgICAgIGZvciAoOyBjb3VudC0tOykge1xuICAgICAgICAgICAgYmVnaW4gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBlbmQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBpbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3ZlcmFnZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBjbGFzcyB2YWx1ZSBmcm9tIGEgZ2x5cGggSUQuXG5mdW5jdGlvbiBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGb3JtYXQgMSBzcGVjaWZpZXMgYSByYW5nZSBvZiBjb25zZWN1dGl2ZSBnbHlwaCBpbmRpY2VzLCBvbmUgY2xhc3MgcGVyIGdseXBoIElELlxuICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGdseXBoQ291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzID0gcC5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihnbHlwaElEKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlc1tnbHlwaElEIC0gc3RhcnRHbHlwaF0gfHwgMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIEZvcm1hdCAyIGRlZmluZXMgbXVsdGlwbGUgZ3JvdXBzIG9mIGdseXBoIGluZGljZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgY2xhc3MuXG4gICAgICAgIHZhciByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgc3RhcnRHbHlwaHMgPSBbXSxcbiAgICAgICAgICAgIGVuZEdseXBocyA9IFtdLFxuICAgICAgICAgICAgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHZhciBsLCBjLCByO1xuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICByID0gc3RhcnRHbHlwaHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICAgICAgICAgIGMgPSAobCArIHIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaElEIDwgc3RhcnRHbHlwaHNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEdseXBoc1tsXSA8PSBnbHlwaElEICYmIGdseXBoSUQgPD0gZW5kR2x5cGhzW2xdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsdWVzW2xdIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgcGFpciBhZGp1c3RtZW50IHBvc2l0aW9uaW5nIHN1YnRhYmxlLCBmb3JtYXQgMSBvciBmb3JtYXQgMlxuLy8gVGhlIHN1YnRhYmxlIGlzIHJldHVybmVkIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwIGZ1bmN0aW9uLlxuZnVuY3Rpb24gcGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQsIGNvdmVyYWdlT2Zmc2V0LCBjb3ZlcmFnZSwgdmFsdWVGb3JtYXQxLCB2YWx1ZUZvcm1hdDIsXG4gICAgICAgIHNoYXJlZFBhaXJTZXRzLCBmaXJzdEdseXBoLCBzZWNvbmRHbHlwaCwgdmFsdWUxLCB2YWx1ZTI7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0K2NvdmVyYWdlT2Zmc2V0KTtcbiAgICAvLyB2YWx1ZUZvcm1hdCA0OiBYQWR2YW5jZSBvbmx5LCAxOiBYUGxhY2VtZW50IG9ubHksIDA6IG5vIFZhbHVlUmVjb3JkIGZvciBzZWNvbmQgZ2x5cGhcbiAgICAvLyBPbmx5IHZhbHVlRm9ybWF0MT00IGFuZCB2YWx1ZUZvcm1hdDI9MCBpcyBzdXBwb3J0ZWQuXG4gICAgdmFsdWVGb3JtYXQxID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhbHVlRm9ybWF0MiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAodmFsdWVGb3JtYXQxICE9PSA0IHx8IHZhbHVlRm9ybWF0MiAhPT0gMCkgcmV0dXJuO1xuICAgIHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIHZhciBwYWlyU2V0Q291bnQsIHBhaXJTZXRPZmZzZXRzLCBwYWlyU2V0T2Zmc2V0LCBzaGFyZWRQYWlyU2V0LCBwYWlyVmFsdWVDb3VudCwgcGFpclNldDtcbiAgICAgICAgcGFpclNldENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwYWlyU2V0ID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIG9mZnNldHMgdG8gUGFpclNldCB0YWJsZXMtZnJvbSBiZWdpbm5pbmcgb2YgUGFpclBvcyBzdWJ0YWJsZS1vcmRlcmVkIGJ5IENvdmVyYWdlIEluZGV4XG4gICAgICAgIHBhaXJTZXRPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChwYWlyU2V0Q291bnQpO1xuICAgICAgICBmb3IgKGZpcnN0R2x5cGggPSAwOyBmaXJzdEdseXBoIDwgcGFpclNldENvdW50OyBmaXJzdEdseXBoKyspIHtcbiAgICAgICAgICAgIHBhaXJTZXRPZmZzZXQgPSBwYWlyU2V0T2Zmc2V0c1tmaXJzdEdseXBoXTtcbiAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICBwYWlyVmFsdWVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgcGFpclZhbHVlQ291bnQtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDEpIHZhbHVlMSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHZhbHVlMSBpcyB0aGUgWEFkdmFuY2UgYW5kIHZhbHVlMiBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGFpclNldFtzZWNvbmRHbHlwaF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpclNldFtjb3ZlcmFnZVtmaXJzdEdseXBoXV0gPSBzaGFyZWRQYWlyU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlycyA9IHBhaXJTZXRbbGVmdEdseXBoXTtcbiAgICAgICAgICAgIGlmIChwYWlycykgcmV0dXJuIHBhaXJzW3JpZ2h0R2x5cGhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgLy8gUGFpciBQb3NpdGlvbmluZyBBZGp1c3RtZW50OiBGb3JtYXQgMlxuICAgICAgICB2YXIgY2xhc3NEZWYxT2Zmc2V0LCBjbGFzc0RlZjJPZmZzZXQsIGNsYXNzMUNvdW50LCBjbGFzczJDb3VudCwgaSwgaixcbiAgICAgICAgICAgIGdldENsYXNzMSwgZ2V0Q2xhc3MyLCBrZXJuaW5nTWF0cml4LCBrZXJuaW5nUm93LCBjb3ZlcmVkO1xuICAgICAgICBjbGFzc0RlZjFPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2xhc3MxQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzMkNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQrY2xhc3NEZWYxT2Zmc2V0KTtcbiAgICAgICAgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0K2NsYXNzRGVmMk9mZnNldCk7XG5cbiAgICAgICAgLy8gUGFyc2Uga2VybmluZyB2YWx1ZXMgYnkgY2xhc3MgcGFpci5cbiAgICAgICAga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3MxQ291bnQ7IGkrKykge1xuICAgICAgICAgICAga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIGNvdmVyZWQgPSB7fTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgY292ZXJhZ2UubGVuZ3RoOyBpKyspIGNvdmVyZWRbY292ZXJhZ2VbaV1dID0gMTtcblxuICAgICAgICAvLyBHZXQgdGhlIGtlcm5pbmcgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZ2x5cGggcGFpci5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkW2xlZnRHbHlwaF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpLFxuICAgICAgICAgICAgICAgIGNsYXNzMiA9IGdldENsYXNzMihyaWdodEdseXBoKSxcbiAgICAgICAgICAgICAgICBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtjbGFzczFdO1xuICAgICAgICAgICAgcmV0dXJuIGtlcm5pbmdSb3cgPyBrZXJuaW5nUm93W2NsYXNzMl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBMb29rdXBUYWJsZSAocHJlc2VudCBpbiBvZiBHUE9TLCBHU1VCLCBHREVGLCBCQVNFLCBKU1RGIHRhYmxlcykuXG5mdW5jdGlvbiBwYXJzZUxvb2t1cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGUsIGxvb2t1cFR5cGUsIGxvb2t1cEZsYWcsIHVzZU1hcmtGaWx0ZXJpbmdTZXQsIHN1YlRhYmxlQ291bnQsIHN1YlRhYmxlT2Zmc2V0cywgc3VidGFibGVzLCBpO1xuICAgIGxvb2t1cFR5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwRmxhZyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgc3ViVGFibGVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBzdWJUYWJsZU9mZnNldHMgPSBwLnBhcnNlT2Zmc2V0MTZMaXN0KHN1YlRhYmxlQ291bnQpO1xuICAgIHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgc3VidGFibGVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdWJUYWJsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKHBhcnNlUGFpclBvc1N1YlRhYmxlKGRhdGEsIHN0YXJ0ICsgc3ViVGFibGVPZmZzZXRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggZmluZHMgdGhlIGtlcm5pbmcgdmFsdWVzIGluIHRoZSBzdWJ0YWJsZXMuXG4gICAgICAgIHRhYmxlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnRhYmxlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdWJ0YWJsZXNbaV0obGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gUGFyc2UgdGhlIGBHUE9TYCB0YWJsZSB3aGljaCBjb250YWlucywgYW1vbmcgb3RoZXIgdGhpbmdzLCBrZXJuaW5nIHBhaXJzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICB2YXIgcCwgdGFibGVWZXJzaW9uLCBsb29rdXBMaXN0T2Zmc2V0LCBzY3JpcHRMaXN0LCBpLCBmZWF0dXJlTGlzdCwgbG9va3VwQ291bnQsXG4gICAgICAgIGxvb2t1cFRhYmxlT2Zmc2V0cywgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0LCB0YWJsZTtcblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB0YWJsZVZlcnNpb24gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24uJyk7XG5cbiAgICAvLyBTY3JpcHRMaXN0IGFuZCBGZWF0dXJlTGlzdCAtIGlnbm9yZWQgZm9yIG5vd1xuICAgIHNjcmlwdExpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuICAgIC8vICdrZXJuJyBpcyB0aGUgZmVhdHVyZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgZmVhdHVyZUxpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuXG4gICAgLy8gTG9va3VwTGlzdFxuICAgIGxvb2t1cExpc3RPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCA9IGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgbG9va3VwQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwVGFibGVPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChsb29rdXBDb3VudCk7XG4gICAgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ID0gc3RhcnQgKyBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb29rdXBDb3VudDsgaSsrKSB7XG4gICAgICAgIHRhYmxlID0gcGFyc2VMb29rdXBUYWJsZShkYXRhLCBsb29rdXBMaXN0QWJzb2x1dGVPZmZzZXQgKyBsb29rdXBUYWJsZU9mZnNldHNbaV0pO1xuICAgICAgICBpZiAodGFibGUubG9va3VwVHlwZSA9PT0gMiAmJiAhZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlKSBmb250LmdldEdwb3NLZXJuaW5nVmFsdWUgPSB0YWJsZS5nZXRLZXJuaW5nVmFsdWU7XG4gICAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHcG9zVGFibGU7XG4iLCIvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7ICAgICAvLyA1MFxuICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udERpcmVjdGlvbkhpbnQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGVhZFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhlYWRUYWJsZTtcbiIsIi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGhlYVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhoZWFUYWJsZTtcbiIsIi8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaG10eC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgcCwgaSwgZ2x5cGgsIGFkdmFuY2VXaWR0aCwgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHZhciBhZHZhbmNlV2lkdGggPSBnbHlwaC5hZHZhbmNlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIbXR4VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSG10eFRhYmxlO1xuXG5cblxuIiwiLy8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuLy8gTm90ZSB0aGF0IHNvbWUgZm9udHMgdXNlIHRoZSBHUE9TIE9wZW5UeXBlIGxheW91dCB0YWJsZSB0byBzcGVjaWZ5IGtlcm5pbmcuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2tlcm4uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBhaXJzLCBwLCB0YWJsZVZlcnNpb24sIHN1YlRhYmxlVmVyc2lvbiwgblBhaXJzLFxuICAgICAgICBpLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgsIHZhbHVlO1xuICAgIHBhaXJzID0ge307XG4gICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBuVGFibGVzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgc3ViVGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YlRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJUYWJsZUxlbmd0aCwgc3ViVGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUtlcm5UYWJsZTtcbiIsIi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbG9jYS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCwgcGFyc2VGbiwgZ2x5cGhPZmZzZXRzLCBnbHlwaE9mZnNldCwgaTtcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUxvY2FUYWJsZTtcbiIsIi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuLy8gV2UgbmVlZCBpdCBqdXN0IHRvIGdldCB0aGUgbnVtYmVyIG9mIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbWF4cC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4cDtcbn1cblxuZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdtYXhwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG4gICAgXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZU1heHBUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VNYXhwVGFibGU7XG4iLCIvLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbmFtZS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5lbmNvZGU7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gTmFtZUlEcyBmb3IgdGhlIG5hbWUgdGFibGUuXG52YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2VuY2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbmNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGVcbi8vIE9ubHkgV2luZG93cyBVbmljb2RlIEVuZ2xpc2ggbmFtZXMgYXJlIHN1cHBvcnRlZC5cbi8vIEZvcm1hdCAxIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBuYW1lID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBuYW1lLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIHByb3BlcnR5LCBieXRlTGVuZ3RoLFxuICAgICAgICBvZmZzZXQsIHN0ciwgaSwgaiwgY29kZVBvaW50cztcbiAgICB2YXIgdW5rbm93bkNvdW50ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGVuY29kaW5nSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lVGFibGVOYW1lc1tuYW1lSURdO1xuICAgICAgICBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIHBsYXRmb3JtSUQgLSBlbmNvZGluZ0lEIC0gbGFuZ3VhZ2VJRCBzdGFuZGFyZCBjb21iaW5hdGlvbnMgOlxuICAgICAgICAvLyAxIC0gMCAtIDAgOiBNYWNpbnRvc2gsIFJvbWFuLCBFbmdsaXNoXG4gICAgICAgIC8vIDMgLSAxIC0gMHg0MDkgOiBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBlbi1VU1xuICAgICAgICBpZiAocGxhdGZvcm1JRCA9PT0gMyAmJiBlbmNvZGluZ0lEID09PSAxICYmIGxhbmd1YWdlSUQgPT09IDB4NDA5KSB7XG4gICAgICAgICAgICBjb2RlUG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aC8yO1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50c1tqXSA9IHBhcnNlLmdldFNob3J0KGRhdGEsIHN0cmluZ09mZnNldCtvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG5hbWVbcHJvcGVydHldID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkNvdW50Kys7XG4gICAgICAgICAgICAgICAgbmFtZVsndW5rbm93bicrdW5rbm93bkNvdW50XSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmIChuYW1lLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICBuYW1lLmxhbmdUYWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lUmVjb3JkKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgbGVuZ3RoLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdOYW1lUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGVuY29kaW5nSUR9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1hY2ludG9zaE5hbWVSZWNvcmQodCwgcmVjb3JkSUQsIHMsIG9mZnNldCkge1xuICAgIC8vIE1hY2ludG9zaCwgUm9tYW4sIEVuZ2xpc2hcbiAgICB2YXIgc3RyaW5nQnl0ZXMgPSBlbmNvZGUuU1RSSU5HKHMpO1xuICAgIHQucmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKDEsIDAsIDAsIHJlY29yZElELCBzdHJpbmdCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHN0cmluZ0J5dGVzKTtcbiAgICBvZmZzZXQgKz0gc3RyaW5nQnl0ZXMubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGFkZFdpbmRvd3NOYW1lUmVjb3JkKHQsIHJlY29yZElELCBzLCBvZmZzZXQpIHtcbiAgICAvLyBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBVUyBFbmdsaXNoXG4gICAgdmFyIHV0ZjE2Qnl0ZXMgPSBlbmNvZGUuVVRGMTYocyk7XG4gICAgdC5yZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgMHgwNDA5LCByZWNvcmRJRCwgdXRmMTZCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHV0ZjE2Qnl0ZXMpO1xuICAgIG9mZnNldCArPSB1dGYxNkJ5dGVzLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgcztcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnbmFtZScsIFtcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgdC5yZWNvcmRzID0gW107XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgLy8gQWRkIE1hY2ludG9zaCByZWNvcmRzIGZpcnN0XG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRNYWNpbnRvc2hOYW1lUmVjb3JkKHQsIGksIHMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlbiBhZGQgV2luZG93cyByZWNvcmRzXG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRXaW5kb3dzTmFtZVJlY29yZCh0LCBpLCBzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdC5jb3VudCA9IHQucmVjb3Jkcy5sZW5ndGg7XG4gICAgdC5zdHJpbmdPZmZzZXQgPSA2ICsgdC5jb3VudCAqIDEyO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0LnJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHQucmVjb3Jkc1tpXX0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdC5zdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHQuc3RyaW5nc1tpXX0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlTmFtZVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZU5hbWVUYWJsZTtcbiIsIi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fSxcbiAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG4gICAgICAgIG9zMi5zeEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzQnJlYWtDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3MyO1xufVxuXG5mdW5jdGlvbiBtYWtlT1MyVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcbiAgICAgICAge25hbWU6ICd4QXZnQ2hhcldpZHRoJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZnNUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0U2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0UG9zaXRpb24nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JGYW1pbHlUeXBlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlByb3BvcnRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkFybVN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JYSGVpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcbiAgICAgICAge25hbWU6ICdmc1NlbGVjdGlvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0FzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkFzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0RlZmF1bHRDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VPUzJUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VPUzJUYWJsZTtcbiIsIi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCcuLi9lbmNvZGluZycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9LFxuICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCksXG4gICAgICAgIGksIG5hbWVMZW5ndGg7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgICAgcG9zdC5uYW1lcyA9IGVuY29kaW5nLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPj0gZW5jb2Rpbmcuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyLjU6XG4gICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldFtpXSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG5mdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDMwMDAwfSxcbiAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICBdKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlUG9zdFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZVBvc3RUYWJsZTtcbiIsIi8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG4vLyBJdCBpcyB0aGUgdG9wLWxldmVsIGRhdGEgc3RydWN0dXJlIGluIGEgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3RmZi5odG1cbi8vIFJlY29tbWVuZGF0aW9ucyBmb3IgY3JlYXRpbmcgT3BlblR5cGUgRm9udHM6XG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMxNDAvcmVjb20uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbnZhciBjbWFwID0gcmVxdWlyZSgnLi9jbWFwJyk7XG52YXIgY2ZmID0gcmVxdWlyZSgnLi9jZmYnKTtcbnZhciBoZWFkID0gcmVxdWlyZSgnLi9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vaGhlYScpO1xudmFyIGhtdHggPSByZXF1aXJlKCcuL2htdHgnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL25hbWUnKTtcbnZhciBvczIgPSByZXF1aXJlKCcuL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3Bvc3QnKTtcblxuZnVuY3Rpb24gbG9nMih2KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikgfCAwO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnVGFibGUgUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG9mZnNldCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0IDogMH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcbiAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG4gICAgc2ZudC5zZWFyY2hSYW5nZSA9IDE2ICogaGlnaGVzdFBvd2VyT2YyO1xuICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcbiAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuICAgIHZhciByZWNvcmRGaWVsZHMgPSBbXTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQodC50YWJsZU5hbWUubGVuZ3RoID09PSA0LCAnVGFibGUgbmFtZScgKyB0LnRhYmxlTmFtZSArICcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcbiAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogdC50YWJsZU5hbWUgKyAnIHRhYmxlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcbiAgICByZXR1cm4gc2ZudDtcbn1cblxuLy8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBtZXRyaWNzIGZvciB0aGUgZmlyc3QgYXZhaWxhYmxlIGNoYXJhY3Rlci5cbi8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBhbmQgbGFyZ2VzdCB1bmljb2RlIHZhbHVlcyBvZiB0aGUgY2hhcmFjdGVycyBpbiB0aGlzIGZvbnQuXG4vLyBGb3IgbW9zdCBmb250cyB0aGUgc21hbGxlc3QgdmFsdWUgd291bGQgYmUgMjAgKHNwYWNlKS5cbmZ1bmN0aW9uIGNoYXJDb2RlQm91bmRzKGdseXBocykge1xuICAgIHZhciBtaW5Db2RlLCBtYXhDb2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGdseXBoLnVuaWNvZGUgPj0gMjApIHtcbiAgICAgICAgICAgIGlmIChtaW5Db2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA8IG1pbkNvZGUpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA+IG1heENvZGUpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbkNvZGUsIG1heENvZGVdO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tpXTtcbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGdsb2JhbHMueU1heDtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGdsb2JhbHMueU1pbjtcblxuICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcbiAgICAgICAgeU1pbjogZ2xvYmFscy55TWluLFxuICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG4gICAgICAgIHlNYXg6IGdsb2JhbHMueU1heFxuICAgIH0pO1xuXG4gICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG4gICAgICAgIC8vIEFkZGluZyBhIGxpdHRsZSBoZXJlIG1ha2VzIE9TIFggUXVpY2sgTG9vayBoYXBweVxuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBjb2RlQm91bmRzID0gY2hhckNvZGVCb3VuZHMoZm9udC5nbHlwaHMpO1xuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKHtcbiAgICAgICAgeEF2Z0NoYXJXaWR0aDogTWF0aC5yb3VuZChnbG9iYWxzLmFkdmFuY2VXaWR0aEF2ZyksXG4gICAgICAgIHVzV2VpZ2h0Q2xhc3M6IDUwMCwgLy8gTWVkaXVtIEZJWE1FIE1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAgICAgdXNXaWR0aENsYXNzOiA1LCAvLyBNZWRpdW0gKG5vcm1hbCkgRklYTUUgTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBjb2RlQm91bmRzWzBdLFxuICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGNvZGVCb3VuZHNbMV0sXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMTogMHgwMDAwMDAwMSwgLy8gQmFzaWMgTGF0aW5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgdXNXaW5EZXNjZW50OiAtZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDB4MDAwMDAwMDEsIC8vIEJhc2ljIExhdGluXG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiAwfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICB9KTtcblxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IGhtdHgubWFrZShmb250LmdseXBocyk7XG4gICAgdmFyIGNtYXBUYWJsZSA9IGNtYXAubWFrZShmb250LmdseXBocyk7XG5cbiAgICB2YXIgZnVsbE5hbWUgPSBmb250LmZhbWlseU5hbWUgKyAnICcgKyBmb250LnN0eWxlTmFtZTtcbiAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGZvbnQuc3R5bGVOYW1lO1xuICAgIHZhciBuYW1lVGFibGUgPSBfbmFtZS5tYWtlKHtcbiAgICAgICAgY29weXJpZ2h0OiBmb250LmNvcHlyaWdodCxcbiAgICAgICAgZm9udEZhbWlseTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICBmb250U3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgdW5pcXVlSUQ6IGZvbnQubWFudWZhY3R1cmVyICsgJzonICsgZnVsbE5hbWUsXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgdmVyc2lvbjogZm9udC52ZXJzaW9uLFxuICAgICAgICBwb3N0U2NyaXB0TmFtZTogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgIHRyYWRlbWFyazogZm9udC50cmFkZW1hcmssXG4gICAgICAgIG1hbnVmYWN0dXJlcjogZm9udC5tYW51ZmFjdHVyZXIsXG4gICAgICAgIGRlc2lnbmVyOiBmb250LmRlc2lnbmVyLFxuICAgICAgICBkZXNjcmlwdGlvbjogZm9udC5kZXNjcmlwdGlvbixcbiAgICAgICAgbWFudWZhY3R1cmVyVVJMOiBmb250Lm1hbnVmYWN0dXJlclVSTCxcbiAgICAgICAgZGVzaWduZXJVUkw6IGZvbnQuZGVzaWduZXJVUkwsXG4gICAgICAgIGxpY2Vuc2U6IGZvbnQubGljZW5zZSxcbiAgICAgICAgbGljZW5zZVVSTDogZm9udC5saWNlbnNlVVJMLFxuICAgICAgICBwcmVmZXJyZWRGYW1pbHk6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgcHJlZmVycmVkU3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZVxuICAgIH0pO1xuICAgIHZhciBwb3N0VGFibGUgPSBwb3N0Lm1ha2UoKTtcbiAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuICAgICAgICB2ZXJzaW9uOiBmb250LnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHROYW1lOiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lXG4gICAgfSk7XG4gICAgLy8gT3JkZXIgdGhlIHRhYmxlcyBhY2NvcmRpbmcgdG8gdGhlIHRoZSBPcGVuVHlwZSBzcGVjaWZpY2F0aW9uIDEuNC5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKTtcbiAgICBoZWFkVGFibGUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuXG4gICAgLy8gQnVpbGQgdGhlIGZvbnQgYWdhaW4sIG5vdyB3aXRoIHRoZSBwcm9wZXIgY2hlY2tTdW0uXG4gICAgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxuZXhwb3J0cy5jb21wdXRlQ2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW07XG5leHBvcnRzLm1ha2UgPSBtYWtlU2ZudFRhYmxlO1xuZXhwb3J0cy5mb250VG9UYWJsZSA9IGZvbnRUb1NmbnRUYWJsZTtcbiIsIi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG4vKiBnbG9iYWwgV2Vha01hcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbnZhciBkZWNvZGUgPSB7fTtcbnZhciBlbmNvZGUgPSB7fTtcbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24gKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcbiAgICByZXR1cm4gW3ZdO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYi5wdXNoKHYuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblxuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMTYpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLy8gQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5MT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMzIpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuXG4vLyBGSVhNRSBJbXBsZW1lbnQgTE9OR0RBVEVUSU1FXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59O1xuXG5zaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cbi8vIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlRBRyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbnNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuLy8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW5jb2RlLkNhcmQ4ID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuQ2FyZDE2ID0gc2l6ZU9mLlVTSE9SVDtcblxuZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5TSUQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEgKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbnNpemVPZi5OVU1CRVIgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuLy8gVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMik7XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZm91ci1ieXRlIHZhbHVlLlxuLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuLy8gYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8vIENvbnZlcnQgYSBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIFVURjE2IGJ5dGVzLlxuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiLnB1c2goMCk7XG4gICAgICAgIGIucHVzaCh2LmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn07XG5cbnNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIG9mZlNpemUsIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgICAgIGRhdGFTaXplLCBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZmV0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICBvZmZzZXRzID0gW29mZnNldF07XG4gICAgZGF0YSA9IFtdO1xuICAgIGRhdGFTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIGRhdGFTaXplICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhkYXRhU2l6ZSkvTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbi8vIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIGQgPSBbXSxcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG0pLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIHZhciB2ID0gbVtrXTtcbiAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQVRPUihrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIGVuY29kZS5ESUNUKG0pLmxlbmd0aDtcbn07XG5cbmVuY29kZS5PUEVSQVRPUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24gKHYsIHR5cGUpIHtcbiAgICB2YXIgZCwgaTtcbiAgICBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG4gICAgICAgICAgICAvLyA0IGJ5dGVzLiBUaGlzIG1ha2VzIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgdGhlIHRvcCBkaWN0IGVhc2llci5cbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbnZhciB3bW0gPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuLy8gQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgaWYgKCB3bW0gJiYgd21tLmhhcyggb3BzICkgKSB7XG4gICAgICAgIHJldHVybiB3bW0uZ2V0KCBvcHMgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdLFxuICAgICAgICBsZW5ndGggPSBvcHMubGVuZ3RoLFxuICAgICAgICBvcCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvcCA9IG9wc1tpXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KCBlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpICk7XG4gICAgfVxuXG4gICAgaWYgKCB3bW0gKSB7XG4gICAgICAgIHdtbS5zZXQoIG9wcywgZCApO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuc2l6ZU9mLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8vIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4vLyBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuLy8gVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgIHZhciBkID0gW10sXG4gICAgICAgIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGgsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RpbmdGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xufTtcblxuLy8gTWVyZ2UgaW4gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuc2l6ZU9mID0gc2l6ZU9mO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qIVxuICogUGFwZXIuanMgdjAuOS4yMSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxNCwgSnVlcmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vICYgaHR0cDovL2pvbmF0aGFucHVja2V5LmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBUdWUgRGVjIDIgMTQ6NDE6NDAgMjAxNCArMDEwMFxuICpcbiAqKipcbiAqXG4gKiBTdHJhcHMuanMgLSBDbGFzcyBpbmhlcml0YW5jZSBsaWJyYXJ5IHdpdGggc3VwcG9ydCBmb3IgYmVhbi1zdHlsZSBhY2Nlc3NvcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgLSAyMDEzIEp1ZXJnIExlaG5pXG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKioqXG4gKlxuICogQWNvcm4uanNcbiAqIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYWNvcm4vXG4gKlxuICogQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCxcbiAqIGNyZWF0ZWQgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gKlxuICovXG5cbnZhciBwYXBlciA9IG5ldyBmdW5jdGlvbih1bmRlZmluZWQpIHtcblxuICAgICAgICAgIHZhciBub0NhbnZhcyA9XG4gICAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAoIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICk7XG5cbnZhciBCYXNlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuXG5cdFx0Zm9yRWFjaCA9IFtdLmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRmb3JJbiA9IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcylcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRyZXR1cm4geyBfX3Byb3RvX186IHByb3RvIH07XG5cdFx0fSxcblxuXHRcdGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRcdHZhciBnZXQgPSBvYmouX19sb29rdXBHZXR0ZXJfXyAmJiBvYmouX19sb29rdXBHZXR0ZXJfXyhuYW1lKTtcblx0XHRcdHJldHVybiBnZXRcblx0XHRcdFx0XHQ/IHsgZ2V0OiBnZXQsIHNldDogb2JqLl9fbG9va3VwU2V0dGVyX18obmFtZSksXG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuXHRcdFx0XHRcdDogb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG5cdFx0XHRcdFx0XHQ/IHsgdmFsdWU6IG9ialtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdF9kZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRpZiAoKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSAmJiBvYmouX19kZWZpbmVHZXR0ZXJfXykge1xuXHRcdFx0XHRpZiAoZGVzYy5nZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lR2V0dGVyX18obmFtZSwgZGVzYy5nZXQpO1xuXHRcdFx0XHRpZiAoZGVzYy5zZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lU2V0dGVyX18obmFtZSwgZGVzYy5zZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqW25hbWVdID0gZGVzYy52YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0ZGVsZXRlIG9ialtuYW1lXTtcblx0XHRcdHJldHVybiBfZGVmaW5lKG9iaiwgbmFtZSwgZGVzYyk7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmNcblx0XHRcdFx0XHRcdD8gKHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSlcblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0YmVhbjtcblx0XHRcdGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBwcmV2KVxuXHRcdFx0XHRcdHZhbC5iYXNlID0gcHJldjtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpXG5cdFx0XHRcdFx0YmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cdFx0XHRcdGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0fHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKVxuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0aWYgKChkZXNjcmliZShkZXN0LCBuYW1lKVxuXHRcdFx0XHRcdFx0fHwgeyBjb25maWd1cmFibGU6IHRydWUgfSkuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0cmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3JjKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuXHRcdFx0XHR2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG5cdFx0XHRcdFx0c2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuXHRcdFx0XHRcdGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG5cdFx0XHRcdGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUsIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBiaW5kKSB7XG5cdFx0aWYgKG9iailcblx0XHRcdCgnbGVuZ3RoJyBpbiBvYmogJiYgIW9iai5nZXRMZW5ndGhcblx0XHRcdFx0XHQmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHRcdFx0PyBmb3JFYWNoXG5cdFx0XHRcdDogZm9ySW4pLmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdHJldHVybiBiaW5kO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG9iaiwgcHJvcHMsIGV4Y2x1ZGUpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG5cdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoIWV4Y2x1ZGUgfHwgIWV4Y2x1ZGVba2V5XSkpXG5cdFx0XHRcdG9ialtrZXldID0gcHJvcHNba2V5XTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0cmV0dXJuIGluamVjdChmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNldCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuXHR9LCB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbihzcmMpIHtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0dmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuXHRcdFx0XHRcdGJlYW5zID0gc3JjLmJlYW5zLFxuXHRcdFx0XHRcdHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuXHRcdFx0XHRpZiAoc3RhdGljcyAhPT0gc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdFx0aW5qZWN0KHRoaXMsIHN0YXRpY3MsIHRydWUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYXNlID0gdGhpcyxcblx0XHRcdFx0Y3Rvcjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKGN0b3IgPSBhcmd1bWVudHNbaV0uaW5pdGlhbGl6ZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdGRlZmluZShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpIDogY3Rvcjtcblx0XHR9XG5cdH0sIHRydWUpLmluamVjdCh7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0XHRyZXR1cm4gc2V0KHRoaXMsIHByb3BzKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRlYWNoOiBlYWNoLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0XHRkZWZpbmU6IGRlZmluZSxcblx0XHRcdGRlc2NyaWJlOiBkZXNjcmliZSxcblx0XHRcdHNldDogc2V0LFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2Vcblx0XHRcdFx0XHRcdHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbn1cblxuaWYgKCFub0NhbnZhcyAmJiAhZG9jdW1lbnQuaGVhZCkge1xuICAgIGRvY3VtZW50LmhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xufVxuXG5CYXNlLmluamVjdCh7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQgIT0gbnVsbFxuICAgICAgICAgICAgPyAgKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lXG4gICAgICAgICAgICAgICAgPyBcIiAnXCIgKyB0aGlzLl9uYW1lICsgXCInXCJcbiAgICAgICAgICAgICAgICA6ICcgQCcgKyB0aGlzLl9pZClcbiAgICAgICAgICAgIDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGtleSArICc6ICcgKyAodHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW10pLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG5cbiAgICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG4gICAgfSxcblxuICAgIGV4cG9ydEpTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMpO1xuICAgIH0sXG5cbiAgICBfc2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSwgZG9udENoZWNrKSB7XG4gICAgICAgIGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG4gICAgICAgICAgICB2YXIgb3JpZyA9IHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3JpZykge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnLmhhc093blByb3BlcnR5KGtleSkgJiYgIShleGNsdWRlICYmIGV4Y2x1ZGVba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG5cbiAgICAgICAgZXhwb3J0czoge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSBcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIG5hbWUgPSByZXMucHJvdG90eXBlLl9jbGFzcztcbiAgICAgICAgICAgIGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgQmFzZS5leHBvcnRzW25hbWVdID0gcmVzO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcblxuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrS2V5cyhvMSwgbzIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG8xKVxuICAgICAgICAgICAgICAgICAgICBpZiAobzEuaGFzT3duUHJvcGVydHkoaSkgJiYgIW8yLmhhc093blByb3BlcnR5KGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAob2JqMSAmJiBvYmoxLmVxdWFscylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG4gICAgICAgICAgICBpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqMi5lcXVhbHMob2JqMSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSAmJiBBcnJheS5pc0FycmF5KG9iajIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iajEubGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqMS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCYXNlLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqMSAmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgJiYgb2JqMiAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrS2V5cyhvYmoxLCBvYmoyKSB8fCAhY2hlY2tLZXlzKG9iajIsIG9iajEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmoxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIUJhc2UuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gQmFzZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGVlayhsaXN0LCBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGlzdC5fX2luZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAgcmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMDtcbiAgICAgICAgICAgIGlmICghbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxpc3QubGVuZ3RoIC0gaW5kZXg7XG4gICAgICAgICAgICB2YXIgb2JqID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuICAgICAgICAgICAgICAgIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBsZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWFkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuX19pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gQmFzZS5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKHJlYWRJbmRleClcbiAgICAgICAgICAgICAgICBvYmouX19yZWFkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgaW5kZXggPiAwIHx8IGxlbmd0aCA8IGxpc3QubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpbmRleCwgaW5kZXggKyBsZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBsaXN0KSB8fCBvYmo7XG4gICAgICAgICAgICBpZiAocmVhZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5fX2luZGV4ID0gaW5kZXggKyBvYmouX19yZWFkO1xuICAgICAgICAgICAgICAgIG9iai5fX3JlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWRBbGw6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICAgICAgZW50cnk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lLCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuICAgICAgICAgICAgICAgIGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaGFzT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLl9maWx0ZXJpbmcgPSBsaXN0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoaGFzT2JqZWN0ID8gW3ZhbHVlXSA6IGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gbGlzdFswXTtcbiAgICAgICAgICAgIGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBsaXN0Ll9oYXNPYmplY3QgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKTtcbiAgICAgICAgICAgIGlmIChsaXN0Ll9oYXNPYmplY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPyBhcmdbbmFtZV0gOiBsaXN0Ll9maWx0ZXJlZCB8fCBhcmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQbGFpblZhbHVlOiBmdW5jdGlvbihvYmosIGFzU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG4gICAgICAgICAgICAgICAgICAgIHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIHJvb3QgPSAhZGljdGlvbmFyeSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgZGljdGlvbmFyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uczoge30sXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpdGVtLl9jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy51bnNoaWZ0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gb2JqLl9zZXJpYWxpemUob3B0aW9ucywgZGljdGlvbmFyeSk7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmICFjb21wYWN0ICYmICFyZXMuX2NvbXBhY3QgJiYgcmVzWzBdICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXMudW5zaGlmdChuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGljdGlvbmFyeSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QpXG4gICAgICAgICAgICAgICAgICAgIHJlcy5fY29tcGFjdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAgICAgICAgICAgcmVzID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpY3Rpb25hcnkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG4gICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0ganNvbjtcbiAgICAgICAgICAgIF9kYXRhID0gX2RhdGEgfHwge307XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0ganNvblswXSxcbiAgICAgICAgICAgICAgICAgICAgaXNEaWN0aW9uYXJ5ID0gdHlwZSA9PT0gJ2RpY3Rpb25hcnknO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGF0YS5kaWN0aW9uYXJ5ICYmIGpzb24ubGVuZ3RoID09IDEgJiYgL14jLy50ZXN0KHR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kYXRhLmRpY3Rpb25hcnlbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGljdGlvbmFyeSkge1xuICAgICAgICAgICAgICAgICAgICBfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHR5cGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbilcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgPyBqc29uXG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gQmFzZS5kZXNlcmlhbGl6ZShcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVGFyZ2V0ID0gb2JqID09PSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgb2JqIGluc3RhbmNlb2YgSXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoaXNUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcuaW5zZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gbGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcbiAgICAgICAgICAgIGlmIChhcHBlbmQpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zKVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZW1vdmVkLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV0uX2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbWVsaXplOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihhbGwsIGNocikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGh5cGhlbmF0ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIEVtaXR0ZXIgPSB7XG4gICAgb246IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgQmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHsgXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pbnN0YWxsICYmIGhhbmRsZXJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb2ZmOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmIChlbnRyeSAmJiBoYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudW5pbnN0YWxsKVxuICAgICAgICAgICAgICAgICAgICBlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgZnVuYyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoIWhhbmRsZXJzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgJiYgZXZlbnQgJiYgZXZlbnQuc3RvcCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcmVzcG9uZHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0pO1xuICAgIH0sXG5cbiAgICBhdHRhY2g6ICcjb24nLFxuICAgIGRldGFjaDogJyNvZmYnLFxuICAgIGZpcmU6ICcjZW1pdCcsXG5cbiAgICBfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24oaW5zdGFsbCkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MsXG4gICAgICAgICAgICBrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1t0eXBlXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZnVuYyA9IGVudHJ5W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KHNyYykge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlcyA9IHt9O1xuICAgICAgICAgICAgICAgIEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlc1t0eXBlXSA9IGlzU3RyaW5nID8ge30gOiBlbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdfJyArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZih0eXBlLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub24odHlwZSwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZnVuYztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGFwZXJTY29wZScsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge2NvbnNvbGUubG9nKCdoZXJlJyk7XG4gICAgICAgIHBhcGVyID0gdGhpcztcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBCYXNlKHtcbiAgICAgICAgICAgIGFwcGx5TWF0cml4OiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlU2l6ZTogNCxcbiAgICAgICAgICAgIGhpdFRvbGVyYW5jZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9qZWN0cyA9IFtdO1xuICAgICAgICB0aGlzLnRvb2xzID0gW107XG4gICAgICAgIHRoaXMucGFsZXR0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faWQgPSBQYXBlclNjb3BlLl9pZCsrO1xuICAgICAgICBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcbiAgICAgICAgdmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG4gICAgICAgIGlmICggbm9DYW52YXMgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnQpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuICAgICAgICAgICAgcHJvdG8uc3VwcG9ydCA9IHtcbiAgICAgICAgICAgICAgICBuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUJsZW5kTW9kZXM6IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5icm93c2VyKSB7XG4gICAgICAgICAgICB2YXIgYnJvd3NlciA9IHByb3RvLmJyb3dzZXIgPSB7fTtcbiAgICAgICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnQpXFwvP1xccyooWy5cXGRdKykoPzouKnZlcnNpb25cXC8oWy5cXGRdKykpPyg/Oi4qcnZcXDooWy5cXGRdKykpPy9nLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGFsbCwgbiwgdjEsIHYyLCBydikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJyb3dzZXIuY2hyb21lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IG4gPT09ICdvcGVyYScgPyB2MiA6IHYxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09ICd0cmlkZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBydjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gJ21zaWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfcKgXG4gICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIubmFtZSA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyW25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIGJyb3dzZXIud2Via2l0O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZlcnNpb246ICcwLjkuMjEnLFxuXG4gICAgZ2V0VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3QgJiYgdGhpcy5wcm9qZWN0LmdldFZpZXcoKTtcbiAgICB9LFxuXG4gICAgZ2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY29kZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgVmlldy51cGRhdGVGb2N1cygpO1xuICAgIH0sXG5cbiAgICBpbnN0YWxsOiBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgQmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpXG4gICAgICAgICAgICBpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcbiAgICAgICAgICAgICAgICBzY29wZVtrZXldID0gdGhpc1trZXldO1xuICAgIH0sXG5cbiAgICBzZXR1cDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBwYXBlciA9IHRoaXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXBlciA9IHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnByb2plY3RzW2ldLnJlbW92ZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBhbGV0dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgdGhpcy5wYWxldHRlc1tpXS5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcbiAgICB9LFxuXG4gICAgc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICAgICAgbmFtZSArPSAnQXR0cmlidXRlJztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9zY29wZXM6IHt9LFxuICAgICAgICAgICAgX2lkOiAwLFxuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcbiAgICAgICAgICAgIGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhY3RpdmF0ZSkge1xuICAgICAgICB0aGlzLl9zY29wZSA9IHBhcGVyO1xuICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuICAgICAgICBpZiAoYWN0aXZhdGUgfHwgIXRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0pXG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfSxcblxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY29wZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdO1xuICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuICAgICAgICAgICAgcHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG4gICAgICAgIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2YXRlJywgcHJldik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09PSB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgQmFzZS5zcGxpY2UodGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcbiAgICAgICAgaWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCA1O1xuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgdGhpcy5wcmVjaXNpb24pO1xuICAgIH0sXG5cbiAgICBudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyO1xuICAgIH0sXG5cbiAgICBwYWlyOiBmdW5jdGlvbih2YWwxLCB2YWwyLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG4gICAgfSxcblxuICAgIHBvaW50OiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXIodmFsLngpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsLnkpO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKVxuICAgICAgICAgICAgICAgICsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG4gICAgfSxcblxuICAgIHJlY3RhbmdsZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnQodmFsLCBzZXBhcmF0b3IpICsgKHNlcGFyYXRvciB8fCAnLCcpXG4gICAgICAgICAgICAgICAgKyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuICAgIH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYWJzY2lzc2FzID0gW1xuICAgICAgICBbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuICAgICAgICBbMCwwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLFxuICAgICAgICBbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcbiAgICAgICAgWzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG4gICAgICAgIFsgIDAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSxcbiAgICAgICAgWzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxuICAgICAgICBbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuICAgICAgICBbMCwwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLFxuICAgICAgICBbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcbiAgICAgICAgWzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG4gICAgICAgIFsgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSxcbiAgICAgICAgWzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxuICAgICAgICBbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuICAgICAgICBbMCwwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLFxuICAgICAgICBbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxuICAgIF07XG5cbiAgICB2YXIgd2VpZ2h0cyA9IFtcbiAgICAgICAgWzFdLFxuICAgICAgICBbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sXG4gICAgICAgIFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcbiAgICAgICAgWzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSxcbiAgICAgICAgWzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSxcbiAgICAgICAgWzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG4gICAgICAgIFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLFxuICAgICAgICBbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sXG4gICAgICAgIFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcbiAgICAgICAgWzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSxcbiAgICAgICAgWzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSxcbiAgICAgICAgWzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG4gICAgICAgIFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLFxuICAgICAgICBbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sXG4gICAgICAgIFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuICAgIF07XG5cbiAgICB2YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgUEkgPSBNYXRoLlBJLFxuICAgICAgICBUT0xFUkFOQ0UgPSAxMGUtNixcbiAgICAgICAgRVBTSUxPTiA9IDEwZS0xMjtcblxuICAgIGZ1bmN0aW9uIHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciB1bmJvdW5kID0gbWluID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBtaW5FID0gbWluIC0gRVBTSUxPTixcbiAgICAgICAgICAgIG1heEUgPSBtYXggKyBFUFNJTE9OLFxuICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICAgICAgaWYgKHVuYm91bmQgfHwgcm9vdCA+IG1pbkUgJiYgcm9vdCA8IG1heEUpXG4gICAgICAgICAgICAgICAgcm9vdHNbY291bnQrK10gPSByb290IDwgbWluID8gbWluIDogcm9vdCA+IG1heCA/IG1heCA6IHJvb3Q7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgVE9MRVJBTkNFOiBUT0xFUkFOQ0UsXG4gICAgICAgIEVQU0lMT046IEVQU0lMT04sXG4gICAgICAgIEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cbiAgICAgICAgaXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnModmFsKSA8PSBFUFNJTE9OO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xuICAgICAgICAgICAgdmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuICAgICAgICAgICAgICAgIHcgPSB3ZWlnaHRzW24gLSAyXSxcbiAgICAgICAgICAgICAgICBBID0gKGIgLSBhKSAqIDAuNSxcbiAgICAgICAgICAgICAgICBCID0gQSArIGEsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbSA9IChuICsgMSkgPj4gMSxcbiAgICAgICAgICAgICAgICBzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwOyBcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbSkge1xuICAgICAgICAgICAgICAgIHZhciBBeCA9IEEgKiB4W2ldO1xuICAgICAgICAgICAgICAgIHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBICogc3VtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmeCA9IGYoeCksXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gZnggLyBkZih4KSxcbiAgICAgICAgICAgICAgICAgICAgbnggPSB4IC0gZHg7XG4gICAgICAgICAgICAgICAgaWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBueDtcbiAgICAgICAgICAgICAgICBpZiAoZnggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGIgPSB4O1xuICAgICAgICAgICAgICAgICAgICB4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhID0geDtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuICAgICAgICAgICAgdmFyIGFkZCA9IHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KTtcblxuICAgICAgICAgICAgaWYgKGFicyhhKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpID49IEVQU0lMT04pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGQoLWMgLyBiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IGIgLyAoMiAqIGEpO1xuICAgICAgICAgICAgdmFyIHEgPSBjIC8gYTtcbiAgICAgICAgICAgIHZhciBwMiA9IHAgKiBwO1xuICAgICAgICAgICAgaWYgKHAyIDwgcSAtIEVQU0lMT04pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgcyA9IHAyID4gcSA/IHNxcnQocDIgLSBxKSA6IDAsXG4gICAgICAgICAgICAgICAgY291bnQgPSBhZGQocyAtIHApO1xuICAgICAgICAgICAgaWYgKHMgPiAwKVxuICAgICAgICAgICAgICAgIGNvdW50ID0gYWRkKC1zIC0gcCk7XG4gICAgICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29sdmVDdWJpYzogZnVuY3Rpb24oYSwgYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgRVBTSUxPTilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCk7XG5cbiAgICAgICAgICAgIGIgLz0gYTtcbiAgICAgICAgICAgIGMgLz0gYTtcbiAgICAgICAgICAgIGQgLz0gYTtcbiAgICAgICAgICAgIHZhciBhZGQgPSBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCksXG4gICAgICAgICAgICAgICAgYmIgPSBiICogYixcbiAgICAgICAgICAgICAgICBwID0gKGJiIC0gMyAqIGMpIC8gOSxcbiAgICAgICAgICAgICAgICBxID0gKDIgKiBiYiAqIGIgLSA5ICogYiAqIGMgKyAyNyAqIGQpIC8gNTQsXG4gICAgICAgICAgICAgICAgcHBwID0gcCAqIHAgKiBwLFxuICAgICAgICAgICAgICAgIEQgPSBxICogcSAtIHBwcDtcbiAgICAgICAgICAgIGIgLz0gMztcbiAgICAgICAgICAgIGlmIChhYnMoRCkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFicyhxKSA8IEVQU0lMT04pIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkKC1iKTtcbiAgICAgICAgICAgICAgICB2YXIgc3FwID0gc3FydChwKSxcbiAgICAgICAgICAgICAgICAgICAgc25xID0gcSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgYWRkKC1zbnEgKiAyICogc3FwIC0gYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZChzbnEgKiBzcXAgLSBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChEIDwgMCkgeyBcbiAgICAgICAgICAgICAgICB2YXIgc3FwID0gc3FydChwKSxcbiAgICAgICAgICAgICAgICAgICAgcGhpID0gTWF0aC5hY29zKHEgLyAoc3FwICogc3FwICogc3FwKSkgLyAzLFxuICAgICAgICAgICAgICAgICAgICB0ID0gLTIgKiBzcXAsXG4gICAgICAgICAgICAgICAgICAgIG8gPSAyICogUEkgLyAzO1xuICAgICAgICAgICAgICAgIGFkZCh0ICogY29zKHBoaSkgLSBiKTtcbiAgICAgICAgICAgICAgICBhZGQodCAqIGNvcyhwaGkgKyBvKSAtIGIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGQodCAqIGNvcyhwaGkgLSBvKSAtIGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEEgPSAocSA+IDAgPyAtMSA6IDEpICogcG93KGFicyhxKSArIHNxcnQoRCksIDEgLyAzKTtcbiAgICAgICAgICAgIHJldHVybiBhZGQoQSArIHAgLyBBIC0gYik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BvaW50JyxcbiAgICBfcmVhZEluZGV4OiB0cnVlLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBoYXNZID0gdHlwZW9mIGFyZzEgPT09ICdudW1iZXInO1xuICAgICAgICAgICAgdGhpcy54ID0gYXJnMDtcbiAgICAgICAgICAgIHRoaXMueSA9IGhhc1kgPyBhcmcxIDogYXJnMDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fcmVhZClcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVhZCA9IGhhc1kgPyAyIDogMTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBhcmcwWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZzAueDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBhcmcwLnk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZzAud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gYXJnMC5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAuYW5nbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZzAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbmdsZShhcmcwLmFuZ2xlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy55ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3JlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWFkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9fcmVhZClcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVhZCA9IDE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuICAgICAgICAgICAgICAgICYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG4gICAgICAgICAgICAgICAgICAgIHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG4gICAgICAgICAgICAgICAgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KSArICcsIHk6ICcgKyBmLm51bWJlcih0aGlzLnkpICsgJyB9JztcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gW2YubnVtYmVyKHRoaXMueCksIGYubnVtYmVyKHRoaXMueSldO1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcblxuICAgIHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5zZXQoXG4gICAgICAgICAgICAgICAgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGxlbmd0aCAvIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAoTnVtZXJpY2FsLmlzWmVybyhzY2FsZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBbmdsZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXQoXG4gICAgICAgICAgICAgICAgdGhpcy54ICogc2NhbGUsXG4gICAgICAgICAgICAgICAgdGhpcy55ICogc2NhbGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGVJblJhZGlhbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgfSxcblxuICAgIHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICB0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICB9LFxuXG4gICAgZ2V0QW5nbGVJbkRlZ3JlZXM6ICcjZ2V0QW5nbGUnLFxuICAgIHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuICAgIGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1plcm8oKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX2FuZ2xlIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QW5nbGVJblJhZGlhbnM6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHRoaXMuX2FuZ2xlID0gYW5nbGU7XG4gICAgICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgICAgICAgICB0aGlzLnNldChcbiAgICAgICAgICAgICAgICBNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCA+PSAwID8gdGhpcy55ID49IDAgPyAxIDogNCA6IHRoaXMueSA+PSAwID8gMiA6IDM7XG4gICAgfVxufSwge1xuICAgIGJlYW5zOiBmYWxzZSxcblxuICAgIGdldERpcmVjdGVkQW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcbiAgICB9LFxuXG4gICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICB4ID0gcG9pbnQueCAtIHRoaXMueCxcbiAgICAgICAgICAgIHkgPSBwb2ludC55IC0gdGhpcy55LFxuICAgICAgICAgICAgZCA9IHggKiB4ICsgeSAqIHksXG4gICAgICAgICAgICBzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcbiAgICB9LFxuXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuICAgICAgICAgICAgc2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG4gICAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuICAgICAgICBpZiAoc2NhbGUgPj0gMClcbiAgICAgICAgICAgIHBvaW50Ll9hbmdsZSA9IHRoaXMuX2FuZ2xlO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuICAgICAgICBpZiAoYW5nbGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgICBhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcbiAgICAgICAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBwb2ludCA9IG5ldyBQb2ludChcbiAgICAgICAgICAgIHBvaW50LnggKiBjIC0gcG9pbnQueSAqIHMsXG4gICAgICAgICAgICBwb2ludC54ICogcyArIHBvaW50LnkgKiBjXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcbiAgICB9LFxuXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG4gICAgfSxcblxuICAgIG1vZHVsbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcbiAgICB9LFxuXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgtdGhpcy54LCAtdGhpcy55KTtcbiAgICB9LFxuXG4gICAgaXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcbiAgICB9LFxuXG4gICAgaXNDbG9zZTogZnVuY3Rpb24ocG9pbnQsIHRvbGVyYW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPCB0b2xlcmFuY2U7XG4gICAgfSxcblxuICAgIGlzQ29saW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmNyb3NzKHBvaW50KSkgPCAwLjAwMDAxO1xuICAgIH0sXG5cbiAgICBpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmRvdChwb2ludCkpIDwgMC4wMDAwMTtcbiAgICB9LFxuXG4gICAgaXNaZXJvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG4gICAgfSxcblxuICAgIGlzTmFOOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHRoaXMueCkgfHwgaXNOYU4odGhpcy55KTtcbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy54ICogcG9pbnQueCArIHRoaXMueSAqIHBvaW50Lnk7XG4gICAgfSxcblxuICAgIGNyb3NzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy54ICogcG9pbnQueSAtIHRoaXMueSAqIHBvaW50Lng7XG4gICAgfSxcblxuICAgIHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChwb2ludC5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHBvaW50LnggKiBzY2FsZSxcbiAgICAgICAgICAgICAgICBwb2ludC55ICogc2NhbGVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBtaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksXG4gICAgICAgICAgICAgICAgTWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICByYW5kb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIEJhc2UuZWFjaChbJ3JvdW5kJywgJ2NlaWwnLCAnZmxvb3InLCAnYWJzJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgb3AgPSBNYXRoW25hbWVdO1xuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcbiAgICB9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludCh4LCB5LCBvd25lciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHgsIHksIF9kb250Tm90aWZ5KSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgaWYgKCFfZG9udE5vdGlmeSlcbiAgICAgICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRYOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfSxcblxuICAgIGdldFk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuXG4gICAgc2V0WTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgdGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcbiAgICB9XG59KTtcblxudmFyIFNpemUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnU2l6ZScsXG4gICAgX3JlYWRJbmRleDogdHJ1ZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUoYXJnMCwgYXJnMSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gYXJnMDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzA7XG4gICAgICAgICAgICBpZiAodGhpcy5fX3JlYWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gYXJnMFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwLndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gYXJnMC53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBhcmcwLng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBhcmcwLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVhZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fX3JlYWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlYWQgPSAxO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZS5oZWlnaHRcbiAgICAgICAgICAgICAgICB8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF1cbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5oZWlnaHQgPT09IHNpemVbMV0pIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG4gICAgICAgICAgICAgICAgKyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuICAgIH0sXG5cbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG4gICAgICAgICAgICAgICAgZi5udW1iZXIodGhpcy5oZWlnaHQpXTtcbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCArIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAtIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICogc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKiBzaXplLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGRpdmlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC8gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLyBzaXplLmhlaWdodCk7XG4gICAgfSxcblxuICAgIG1vZHVsbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICUgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgJSBzaXplLmhlaWdodCk7XG4gICAgfSxcblxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgaXNaZXJvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGlzTmFOOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHRoaXMud2lkdGgpIHx8IGlzTmFOKHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXplKFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXplKFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoc2l6ZTEuaGVpZ2h0LCBzaXplMi5oZWlnaHQpKTtcbiAgICAgICAgfSxcblxuICAgICAgICByYW5kb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB9XG4gICAgfVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBvcCA9IE1hdGhbbmFtZV07XG4gICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG4gICAgfTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRTaXplID0gU2l6ZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IHNldHRlcjtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmICghX2RvbnROb3RpZnkpXG4gICAgICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfSxcblxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH0sXG5cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgfVxufSk7XG5cbnZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUmVjdGFuZ2xlJyxcbiAgICBfcmVhZEluZGV4OiB0cnVlLFxuICAgIGJlYW5zOiB0cnVlLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcbiAgICAgICAgICAgIHJlYWQgPSAwO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IGFyZzA7XG4gICAgICAgICAgICB0aGlzLnkgPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGFyZzI7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGFyZzM7XG4gICAgICAgICAgICByZWFkID0gNDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZzBbMF07XG4gICAgICAgICAgICAgICAgdGhpcy55ID0gYXJnMFsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gYXJnMFsyXTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGFyZzBbM107XG4gICAgICAgICAgICAgICAgcmVhZCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAueCAhPT0gdW5kZWZpbmVkIHx8IGFyZzAud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IGFyZzAueCB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IGFyZzAueSB8fCAwO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBhcmcwLndpZHRoIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodCB8fCAwO1xuICAgICAgICAgICAgICAgIHJlYWQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChhcmcwKTtcbiAgICAgICAgICAgICAgICByZWFkID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWQpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG4gICAgICAgICAgICAgICAgbmV4dCA9IEJhc2UucGVlayhhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy54ID0gcG9pbnQueDtcbiAgICAgICAgICAgIHRoaXMueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZCB8fCBCYXNlLmhhc05hbWVkKGFyZ3VtZW50cywgJ3RvJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gdG8ueCAtIHBvaW50Lng7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0by55IC0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy53aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gdG8ueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IC10aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IHRvLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gLXRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZCA9IGFyZ3VtZW50cy5fX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcmVhZClcbiAgICAgICAgICAgIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuICAgICAgICAgICAgICAgID8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIDogcmVjdDtcbiAgICAgICAgcmV0dXJuIHJ0ID09PSB0aGlzXG4gICAgICAgICAgICAgICAgfHwgcnQgJiYgdGhpcy54ID09PSBydC54ICYmIHRoaXMueSA9PT0gcnQueVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiAneyB4OiAnICsgZi5udW1iZXIodGhpcy54KVxuICAgICAgICAgICAgICAgICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcbiAgICAgICAgICAgICAgICArICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcbiAgICAgICAgICAgICAgICArICcsIGhlaWdodDogJyArIGYubnVtYmVyKHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICsgJyB9JztcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG4gICAgICAgICAgICAgICAgZi5udW1iZXIodGhpcy55KSxcbiAgICAgICAgICAgICAgICBmLm51bWJlcih0aGlzLndpZHRoKSxcbiAgICAgICAgICAgICAgICBmLm51bWJlcih0aGlzLmhlaWdodCldO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG4gICAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcbiAgICB9LFxuXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMueCA9IHBvaW50Lng7XG4gICAgICAgIHRoaXMueSA9IHBvaW50Lnk7XG4gICAgfSxcblxuICAgIGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuICAgICAgICB2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuICAgICAgICByZXR1cm4gbmV3IGN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG4gICAgfSxcblxuICAgIHNldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5fZml4WClcbiAgICAgICAgICAgIHRoaXMueCArPSAodGhpcy53aWR0aCAtIHNpemUud2lkdGgpICogdGhpcy5fZml4WDtcbiAgICAgICAgaWYgKHRoaXMuX2ZpeFkpXG4gICAgICAgICAgICB0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2ZpeFcgPSAxO1xuICAgICAgICB0aGlzLl9maXhIID0gMTtcbiAgICB9LFxuXG4gICAgZ2V0TGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLng7XG4gICAgfSxcblxuICAgIHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXhXKVxuICAgICAgICAgICAgdGhpcy53aWR0aCAtPSBsZWZ0IC0gdGhpcy54O1xuICAgICAgICB0aGlzLnggPSBsZWZ0O1xuICAgICAgICB0aGlzLl9maXhYID0gMDtcbiAgICB9LFxuXG4gICAgZ2V0VG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9LFxuXG4gICAgc2V0VG9wOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXhIKVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgLT0gdG9wIC0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0b3A7XG4gICAgICAgIHRoaXMuX2ZpeFkgPSAwO1xuICAgIH0sXG5cbiAgICBnZXRSaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICBzZXRSaWdodDogZnVuY3Rpb24ocmlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpeFggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maXhYICE9PSAxKVxuICAgICAgICAgICAgdGhpcy5fZml4VyA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9maXhXKVxuICAgICAgICAgICAgdGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gcmlnaHQgLSB0aGlzLng7XG4gICAgICAgIHRoaXMuX2ZpeFggPSAxO1xuICAgIH0sXG5cbiAgICBnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIHNldEJvdHRvbTogZnVuY3Rpb24oYm90dG9tKSB7XG4gICAgICAgIGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcbiAgICAgICAgICAgIHRoaXMuX2ZpeEggPSAwO1xuICAgICAgICBpZiAodGhpcy5fZml4SClcbiAgICAgICAgICAgIHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGJvdHRvbSAtIHRoaXMueTtcbiAgICAgICAgdGhpcy5fZml4WSA9IDE7XG4gICAgfSxcblxuICAgIGdldENlbnRlclg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9LFxuXG4gICAgc2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgICAgdGhpcy5fZml4WCA9IDAuNTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAqIDAuNTtcbiAgICB9LFxuXG4gICAgc2V0Q2VudGVyWTogZnVuY3Rpb24oeSkge1xuICAgICAgICB0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG4gICAgICAgIHRoaXMuX2ZpeFkgPSAwLjU7XG4gICAgfSxcblxuICAgIGdldENlbnRlcjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG4gICAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuICAgIH0sXG5cbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJZKHBvaW50LnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcbiAgICB9LFxuXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfHwgKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cykubGVuZ3RoID09IDRcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG4gICAgICAgICAgICAgICAgJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG4gICAgICAgICAgICAgICAgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgX2NvbnRhaW5zUmVjdGFuZ2xlOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHZhciB4ID0gcmVjdC54LFxuICAgICAgICAgICAgeSA9IHJlY3QueTtcbiAgICAgICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG4gICAgICAgICAgICAgICAgJiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuICAgICAgICAgICAgICAgICYmIHkgKyByZWN0LmhlaWdodCA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPiB0aGlzLnhcbiAgICAgICAgICAgICAgICAmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueVxuICAgICAgICAgICAgICAgICYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICAmJiByZWN0LnkgPCB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgdG91Y2hlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGggPj0gdGhpcy54XG4gICAgICAgICAgICAgICAgJiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0gdGhpcy55XG4gICAgICAgICAgICAgICAgJiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcbiAgICAgICAgICAgICAgICAmJiByZWN0LnkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuICAgICAgICAgICAgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG4gICAgICAgICAgICB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICB1bml0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG4gICAgICAgICAgICB4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgeTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgeTEgPSBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpLFxuICAgICAgICAgICAgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC54KSxcbiAgICAgICAgICAgIHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHBvaW50LnkpO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICBleHBhbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW1vdW50ID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBob3IgPSBhbW91bnQud2lkdGgsXG4gICAgICAgICAgICB2ZXIgPSBhbW91bnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKyBob3IsIHRoaXMuaGVpZ2h0ICsgdmVyKTtcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG4gICAgfVxufSwgQmFzZS5lYWNoKFtcbiAgICAgICAgWydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuICAgICAgICBbJ0JvdHRvbScsICdMZWZ0J10sIFsnQm90dG9tJywgJ1JpZ2h0J10sXG4gICAgICAgIFsnTGVmdCcsICdDZW50ZXInXSwgWydUb3AnLCAnQ2VudGVyJ10sXG4gICAgICAgIFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG4gICAgXSxcbiAgICBmdW5jdGlvbihwYXJ0cywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgdmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcbiAgICAgICAgaWYgKGluZGV4ID49IDQpXG4gICAgICAgICAgICBwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG4gICAgICAgIHZhciB4ID0gcGFydHNbeEZpcnN0ID8gMCA6IDFdLFxuICAgICAgICAgICAgeSA9IHBhcnRzW3hGaXJzdCA/IDEgOiAwXSxcbiAgICAgICAgICAgIGdldFggPSAnZ2V0JyArIHgsXG4gICAgICAgICAgICBnZXRZID0gJ2dldCcgKyB5LFxuICAgICAgICAgICAgc2V0WCA9ICdzZXQnICsgeCxcbiAgICAgICAgICAgIHNldFkgPSAnc2V0JyArIHksXG4gICAgICAgICAgICBnZXQgPSAnZ2V0JyArIHBhcnQsXG4gICAgICAgICAgICBzZXQgPSAnc2V0JyArIHBhcnQ7XG4gICAgICAgIHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuICAgICAgICAgICAgdmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXNbc2V0WF0ocG9pbnQueCk7XG4gICAgICAgICAgICB0aGlzW3NldFldKHBvaW50LnkpO1xuICAgICAgICB9O1xuICAgIH0sIHtcbiAgICAgICAgYmVhbnM6IHRydWVcbiAgICB9XG4pKTtcblxudmFyIExpbmtlZFJlY3RhbmdsZSA9IFJlY3RhbmdsZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmICghX2RvbnROb3RpZnkpXG4gICAgICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuICAgIHJldHVybiBCYXNlLmVhY2goWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSAnXycgKyBrZXk7XG4gICAgICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb250Tm90aWZ5KVxuICAgICAgICAgICAgICAgIHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG4gICAgICAgIH07XG4gICAgfSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuICAgICAgICAgICAgJ0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuICAgICAgICAgICAgJ1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG4gICAgICAgICAgICAnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG4gICAgICAgIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSAnc2V0JyArIGtleTtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuICAgICAgICAgICAgICAgIGlmIChvd25lci5zZXRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBvd25lci5fYm91bmRzU2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICk7XG59KTtcblxudmFyIE1hdHJpeCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdNYXRyaXgnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuICAgICAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICBpZiAoY291bnQgPT09IDYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChhcmcuX2EsIGFyZy5fYywgYXJnLl9iLCBhcmcuX2QsIGFyZy5fdHgsIGFyZy5fdHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldC5hcHBseSh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oYSwgYywgYiwgZCwgdHgsIHR5LCBfZG9udE5vdGlmeSkge1xuICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgdGhpcy5fYyA9IGM7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9kID0gZDtcbiAgICAgICAgdGhpcy5fdHggPSB0eDtcbiAgICAgICAgdGhpcy5fdHkgPSB0eTtcbiAgICAgICAgaWYgKCFfZG9udE5vdGlmeSlcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuICAgICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgICAgIGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG93bmVyLl9jaGFuZ2VkKDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCxcbiAgICAgICAgICAgICAgICB0aGlzLl90eCwgdGhpcy5fdHkpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKG14KSB7XG4gICAgICAgIHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYlxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG4gICAgICAgICAgICAgICAgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9iKSxcbiAgICAgICAgICAgICAgICAgICAgZi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG4gICAgICAgICAgICAgICAgKyBbZi5udW1iZXIodGhpcy5fYyksIGYubnVtYmVyKHRoaXMuX2QpLFxuICAgICAgICAgICAgICAgICAgICBmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oX2RvbnROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuICAgICAgICB0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuICAgICAgICBpZiAoIV9kb250Tm90aWZ5KVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcbiAgICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgICAgICBvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICB4ID0gcG9pbnQueCxcbiAgICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgICB0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iO1xuICAgICAgICB0aGlzLl90eSArPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuICAgICAgICBpZiAoY2VudGVyKVxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoY2VudGVyKTtcbiAgICAgICAgdGhpcy5fYSAqPSBzY2FsZS54O1xuICAgICAgICB0aGlzLl9jICo9IHNjYWxlLng7XG4gICAgICAgIHRoaXMuX2IgKj0gc2NhbGUueTtcbiAgICAgICAgdGhpcy5fZCAqPSBzY2FsZS55O1xuICAgICAgICBpZiAoY2VudGVyKVxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcbiAgICAgICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgIHggPSBjZW50ZXIueCxcbiAgICAgICAgICAgIHkgPSBjZW50ZXIueSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuICAgICAgICAgICAgdHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG4gICAgICAgICAgICBhID0gdGhpcy5fYSxcbiAgICAgICAgICAgIGIgPSB0aGlzLl9iLFxuICAgICAgICAgICAgYyA9IHRoaXMuX2MsXG4gICAgICAgICAgICBkID0gdGhpcy5fZDtcbiAgICAgICAgdGhpcy5fYSA9IGNvcyAqIGEgKyBzaW4gKiBiO1xuICAgICAgICB0aGlzLl9iID0gLXNpbiAqIGEgKyBjb3MgKiBiO1xuICAgICAgICB0aGlzLl9jID0gY29zICogYyArIHNpbiAqIGQ7XG4gICAgICAgIHRoaXMuX2QgPSAtc2luICogYyArIGNvcyAqIGQ7XG4gICAgICAgIHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYjtcbiAgICAgICAgdGhpcy5fdHkgKz0gdHggKiBjICsgdHkgKiBkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaGVhciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuICAgICAgICBpZiAoY2VudGVyKVxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoY2VudGVyKTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLl9hLFxuICAgICAgICAgICAgYyA9IHRoaXMuX2M7XG4gICAgICAgIHRoaXMuX2EgKz0gc2hlYXIueSAqIHRoaXMuX2I7XG4gICAgICAgIHRoaXMuX2MgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG4gICAgICAgIHRoaXMuX2IgKz0gc2hlYXIueCAqIGE7XG4gICAgICAgIHRoaXMuX2QgKz0gc2hlYXIueCAqIGM7XG4gICAgICAgIGlmIChjZW50ZXIpXG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBza2V3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcbiAgICAgICAgICAgIHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgICAgICBzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuICAgICAgICAgICAgICAgIE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuICAgICAgICByZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcbiAgICB9LFxuXG4gICAgY29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuX2EsXG4gICAgICAgICAgICBiMSA9IHRoaXMuX2IsXG4gICAgICAgICAgICBjMSA9IHRoaXMuX2MsXG4gICAgICAgICAgICBkMSA9IHRoaXMuX2QsXG4gICAgICAgICAgICBhMiA9IG14Ll9hLFxuICAgICAgICAgICAgYjIgPSBteC5fYixcbiAgICAgICAgICAgIGMyID0gbXguX2MsXG4gICAgICAgICAgICBkMiA9IG14Ll9kLFxuICAgICAgICAgICAgdHgyID0gbXguX3R4LFxuICAgICAgICAgICAgdHkyID0gbXguX3R5O1xuICAgICAgICB0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYjE7XG4gICAgICAgIHRoaXMuX2IgPSBiMiAqIGExICsgZDIgKiBiMTtcbiAgICAgICAgdGhpcy5fYyA9IGEyICogYzEgKyBjMiAqIGQxO1xuICAgICAgICB0aGlzLl9kID0gYjIgKiBjMSArIGQyICogZDE7XG4gICAgICAgIHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYjE7XG4gICAgICAgIHRoaXMuX3R5ICs9IHR4MiAqIGMxICsgdHkyICogZDE7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHByZUNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLl9hLFxuICAgICAgICAgICAgYjEgPSB0aGlzLl9iLFxuICAgICAgICAgICAgYzEgPSB0aGlzLl9jLFxuICAgICAgICAgICAgZDEgPSB0aGlzLl9kLFxuICAgICAgICAgICAgdHgxID0gdGhpcy5fdHgsXG4gICAgICAgICAgICB0eTEgPSB0aGlzLl90eSxcbiAgICAgICAgICAgIGEyID0gbXguX2EsXG4gICAgICAgICAgICBiMiA9IG14Ll9iLFxuICAgICAgICAgICAgYzIgPSBteC5fYyxcbiAgICAgICAgICAgIGQyID0gbXguX2QsXG4gICAgICAgICAgICB0eDIgPSBteC5fdHgsXG4gICAgICAgICAgICB0eTIgPSBteC5fdHk7XG4gICAgICAgIHRoaXMuX2EgPSBhMiAqIGExICsgYjIgKiBjMTtcbiAgICAgICAgdGhpcy5fYiA9IGEyICogYjEgKyBiMiAqIGQxO1xuICAgICAgICB0aGlzLl9jID0gYzIgKiBhMSArIGQyICogYzE7XG4gICAgICAgIHRoaXMuX2QgPSBjMiAqIGIxICsgZDIgKiBkMTtcbiAgICAgICAgdGhpcy5fdHggPSBhMiAqIHR4MSArIGIyICogdHkxICsgdHgyO1xuICAgICAgICB0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNoYWluOiBmdW5jdGlvbihteCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLl9hLFxuICAgICAgICAgICAgYjEgPSB0aGlzLl9iLFxuICAgICAgICAgICAgYzEgPSB0aGlzLl9jLFxuICAgICAgICAgICAgZDEgPSB0aGlzLl9kLFxuICAgICAgICAgICAgdHgxID0gdGhpcy5fdHgsXG4gICAgICAgICAgICB0eTEgPSB0aGlzLl90eSxcbiAgICAgICAgICAgIGEyID0gbXguX2EsXG4gICAgICAgICAgICBiMiA9IG14Ll9iLFxuICAgICAgICAgICAgYzIgPSBteC5fYyxcbiAgICAgICAgICAgIGQyID0gbXguX2QsXG4gICAgICAgICAgICB0eDIgPSBteC5fdHgsXG4gICAgICAgICAgICB0eTIgPSBteC5fdHk7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KFxuICAgICAgICAgICAgICAgIGEyICogYTEgKyBjMiAqIGIxLFxuICAgICAgICAgICAgICAgIGEyICogYzEgKyBjMiAqIGQxLFxuICAgICAgICAgICAgICAgIGIyICogYTEgKyBkMiAqIGIxLFxuICAgICAgICAgICAgICAgIGIyICogYzEgKyBkMiAqIGQxLFxuICAgICAgICAgICAgICAgIHR4MSArIHR4MiAqIGExICsgdHkyICogYjEsXG4gICAgICAgICAgICAgICAgdHkxICsgdHgyICogYzEgKyB0eTIgKiBkMSk7XG4gICAgfSxcblxuICAgIGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9jID09PSAwICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fZCA9PT0gMVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuICAgIH0sXG5cbiAgICBvck51bGxJZklkZW50aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpID8gbnVsbCA6IHRoaXM7XG4gICAgfSxcblxuICAgIGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2dldERldGVybWluYW50KCk7XG4gICAgfSxcblxuICAgIGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2dldERldGVybWluYW50KCk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oIHNyYywgZHN0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcbiAgICAgICAgICAgID8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuICAgICAgICAgICAgOiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgICAgaWYgKCFkZXN0KVxuICAgICAgICAgICAgZGVzdCA9IG5ldyBQb2ludCgpO1xuICAgICAgICByZXR1cm4gZGVzdC5zZXQoXG4gICAgICAgICAgICB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG4gICAgICAgICAgICB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG4gICAgICAgICAgICBfZG9udE5vdGlmeVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHNyYywgZHN0LCBjb3VudCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIG1heCA9IDIgKiBjb3VudDtcbiAgICAgICAgd2hpbGUgKGkgPCBtYXgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc3JjW2krK10sXG4gICAgICAgICAgICAgICAgeSA9IHNyY1tpKytdO1xuICAgICAgICAgICAgZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG4gICAgICAgICAgICBkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgeDEgPSByZWN0LngsXG4gICAgICAgICAgICB5MSA9IHJlY3QueSxcbiAgICAgICAgICAgIHgyID0geDEgKyByZWN0LndpZHRoLFxuICAgICAgICAgICAgeTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgY29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCA0KTtcbiAgICB9LFxuXG4gICAgX3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuICAgICAgICAgICAgbWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuICAgICAgICAgICAgbWF4ID0gY29vcmRzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gY29vcmRzW2ldLFxuICAgICAgICAgICAgICAgIGogPSBpICYgMTtcbiAgICAgICAgICAgIGlmICh2YWwgPCBtaW5bal0pXG4gICAgICAgICAgICAgICAgbWluW2pdID0gdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuICAgICAgICAgICAgICAgIG1heFtqXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlc3QpXG4gICAgICAgICAgICBkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgICAgICByZXR1cm4gZGVzdC5zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuICAgICAgICAgICAgICAgIF9kb250Tm90aWZ5KTtcbiAgICB9LFxuXG4gICAgaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIF9nZXREZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXQgPSB0aGlzLl9hICogdGhpcy5fZCAtIHRoaXMuX2IgKiB0aGlzLl9jO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG4gICAgICAgICAgICAgICAgJiYgaXNGaW5pdGUodGhpcy5fdHgpICYmIGlzRmluaXRlKHRoaXMuX3R5KVxuICAgICAgICAgICAgICAgID8gZGV0IDogbnVsbDtcbiAgICB9LFxuXG4gICAgX2ludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuICAgICAgICB2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcbiAgICAgICAgaWYgKCFkZXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHggPSBwb2ludC54IC0gdGhpcy5fdHgsXG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuICAgICAgICBpZiAoIWRlc3QpXG4gICAgICAgICAgICBkZXN0ID0gbmV3IFBvaW50KCk7XG4gICAgICAgIHJldHVybiBkZXN0LnNldChcbiAgICAgICAgICAgICh4ICogdGhpcy5fZCAtIHkgKiB0aGlzLl9iKSAvIGRldCxcbiAgICAgICAgICAgICh5ICogdGhpcy5fYSAtIHggKiB0aGlzLl9jKSAvIGRldCxcbiAgICAgICAgICAgIF9kb250Tm90aWZ5XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5fYSwgYiA9IHRoaXMuX2IsIGMgPSB0aGlzLl9jLCBkID0gdGhpcy5fZDtcbiAgICAgICAgaWYgKE51bWVyaWNhbC5pc1plcm8oYSAqIGQgLSBiICogYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgICBhIC89IHNjYWxlWDtcbiAgICAgICAgYiAvPSBzY2FsZVg7XG5cbiAgICAgICAgdmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcbiAgICAgICAgYyAtPSBhICogc2hlYXI7XG4gICAgICAgIGQgLT0gYiAqIHNoZWFyO1xuXG4gICAgICAgIHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG4gICAgICAgIGMgLz0gc2NhbGVZO1xuICAgICAgICBkIC89IHNjYWxlWTtcbiAgICAgICAgc2hlYXIgLz0gc2NhbGVZO1xuXG4gICAgICAgIGlmIChhICogZCA8IGIgKiBjKSB7XG4gICAgICAgICAgICBhID0gLWE7XG4gICAgICAgICAgICBiID0gLWI7XG4gICAgICAgICAgICBzaGVhciA9IC1zaGVhcjtcbiAgICAgICAgICAgIHNjYWxlWCA9IC1zY2FsZVg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG4gICAgICAgICAgICBzaGVhcmluZzogc2hlYXJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG4gICAgfSxcblxuICAgIGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl90eCwgdGhpcy5fdHkpO1xuICAgIH0sXG5cbiAgICBnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5zY2FsaW5nO1xuICAgIH0sXG5cbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG4gICAgfSxcblxuICAgIGludmVydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG4gICAgICAgIHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcbiAgICAgICAgICAgICAgICB0aGlzLl9kIC8gZGV0LFxuICAgICAgICAgICAgICAgIC10aGlzLl9jIC8gZGV0LFxuICAgICAgICAgICAgICAgIC10aGlzLl9iIC8gZGV0LFxuICAgICAgICAgICAgICAgIHRoaXMuX2EgLyBkZXQsXG4gICAgICAgICAgICAgICAgKHRoaXMuX2IgKiB0aGlzLl90eSAtIHRoaXMuX2QgKiB0aGlzLl90eCkgLyBkZXQsXG4gICAgICAgICAgICAgICAgKHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuICAgIH0sXG5cbiAgICBzaGlmdGxlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG4gICAgfVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG4gICAgICAgIHByb3AgPSAnXycgKyBuYW1lO1xuICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1twcm9wXTtcbiAgICB9O1xuICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH07XG59LCB7fSkpO1xuXG52YXIgTGluZSA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdMaW5lJyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgICB2YXIgYXNWZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgdGhpcy5fcHggPSBhcmcwO1xuICAgICAgICAgICAgdGhpcy5fcHkgPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy5fdnggPSBhcmcyO1xuICAgICAgICAgICAgdGhpcy5fdnkgPSBhcmczO1xuICAgICAgICAgICAgYXNWZWN0b3IgPSBhcmc0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHggPSBhcmcwLng7XG4gICAgICAgICAgICB0aGlzLl9weSA9IGFyZzAueTtcbiAgICAgICAgICAgIHRoaXMuX3Z4ID0gYXJnMS54O1xuICAgICAgICAgICAgdGhpcy5fdnkgPSBhcmcxLnk7XG4gICAgICAgICAgICBhc1ZlY3RvciA9IGFyZzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fdnggLT0gdGhpcy5fcHg7XG4gICAgICAgICAgICB0aGlzLl92eSAtPSB0aGlzLl9weTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5fcHgsIHRoaXMuX3B5KTtcbiAgICB9LFxuXG4gICAgZ2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBMaW5lLmludGVyc2VjdChcbiAgICAgICAgICAgICAgICB0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcbiAgICAgICAgICAgICAgICBsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcbiAgICAgICAgICAgICAgICB0cnVlLCBpc0luZmluaXRlKTtcbiAgICB9LFxuXG4gICAgZ2V0U2lkZTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIExpbmUuZ2V0U2lkZShcbiAgICAgICAgICAgICAgICB0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcbiAgICAgICAgICAgICAgICBwb2ludC54LCBwb2ludC55LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhMaW5lLmdldFNpZ25lZERpc3RhbmNlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuICAgICAgICAgICAgICAgIHBvaW50LngsIHBvaW50LnksIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKGFweCwgYXB5LCBhdngsIGF2eSwgYnB4LCBicHksIGJ2eCwgYnZ5LCBhc1ZlY3RvcixcbiAgICAgICAgICAgICAgICBpc0luZmluaXRlKSB7XG4gICAgICAgICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgYXZ4IC09IGFweDtcbiAgICAgICAgICAgICAgICBhdnkgLT0gYXB5O1xuICAgICAgICAgICAgICAgIGJ2eCAtPSBicHg7XG4gICAgICAgICAgICAgICAgYnZ5IC09IGJweTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcm9zcyA9IGF2eCAqIGJ2eSAtIGF2eSAqIGJ2eDtcbiAgICAgICAgICAgIGlmICghTnVtZXJpY2FsLmlzWmVybyhjcm9zcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBhcHggLSBicHgsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gYXB5IC0gYnB5LFxuICAgICAgICAgICAgICAgICAgICB0YSA9IChidnggKiBkeSAtIGJ2eSAqIGR4KSAvIGNyb3NzLFxuICAgICAgICAgICAgICAgICAgICB0YiA9IChhdnggKiBkeSAtIGF2eSAqIGR4KSAvIGNyb3NzO1xuICAgICAgICAgICAgICAgIGlmIChpc0luZmluaXRlIHx8IDAgPD0gdGEgJiYgdGEgPD0gMSAmJiAwIDw9IHRiICYmIHRiIDw9IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFweCArIHRhICogYXZ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHkgKyB0YSAqIGF2eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIWFzVmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdnggLT0gcHg7XG4gICAgICAgICAgICAgICAgdnkgLT0gcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjJ4ID0geCAtIHB4LFxuICAgICAgICAgICAgICAgIHYyeSA9IHkgLSBweSxcbiAgICAgICAgICAgICAgICBjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4OyBcbiAgICAgICAgICAgIGlmIChjY3cgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5OyBcbiAgICAgICAgICAgICAgICBpZiAoY2N3ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2MnggLT0gdng7XG4gICAgICAgICAgICAgICAgICAgIHYyeSAtPSB2eTtcbiAgICAgICAgICAgICAgICAgICAgY2N3ID0gdjJ4ICogdnggKyB2MnkgKiB2eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjdyA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjY3cgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFhc1ZlY3Rvcikge1xuICAgICAgICAgICAgICAgIHZ4IC09IHB4O1xuICAgICAgICAgICAgICAgIHZ5IC09IHB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE51bWVyaWNhbC5pc1plcm8odngpKVxuICAgICAgICAgICAgICAgIHJldHVybiB4IC0gcHg7XG4gICAgICAgICAgICB2YXIgbSA9IHZ5IC8gdngsIFxuICAgICAgICAgICAgICAgIGIgPSBweSAtIG0gKiBweDsgXG4gICAgICAgICAgICByZXR1cm4gKHkgLSAobSAqIHgpIC0gYikgLyBNYXRoLnNxcnQobSAqIG0gKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgUHJvamVjdCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUHJvamVjdCcsXG4gICAgX2xpc3Q6ICdwcm9qZWN0cycsXG4gICAgX3JlZmVyZW5jZTogJ3Byb2plY3QnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUHJvamVjdChlbGVtZW50KSB7XG4gICAgICAgIFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gW107XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fdmlldyA9IFZpZXcuY3JlYXRlKHRoaXMsXG4gICAgICAgICAgICAgICAgZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1zID0ge307XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMubGF5ZXJzLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLmxheWVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gW107XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMubGVuZ3RoID09PSAwO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fdmlldylcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXRWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXc7XG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG4gICAgfSxcblxuICAgIHNldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFN0eWxlLmluaXRpYWxpemUoc3R5bGUpO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcbiAgICB9LFxuXG4gICAgZ2V0QWN0aXZlTGF5ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKHsgcHJvamVjdDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9zZWxlY3RlZEl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3NlbGVjdGVkSXRlbXNbaWRdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXNJbnNlcnRlZCgpKVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICBhZGRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbY2hpbGRdKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5ZXIgPSBjaGlsZDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICAgICAgICAgICh0aGlzLl9hY3RpdmVMYXllclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuYWRkQ2hpbGQobmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSkpLmFkZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSxcblxuICAgIF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkID0gaXRlbS5faWQsXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcbiAgICAgICAgaWYgKGl0ZW0uX3NlbGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtc1tpZF0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbXNbaWRdID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGxheWVyc1tpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICBkZXNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzZWxlY3RlZEl0ZW1zKVxuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtc1tpXS5zZXRGdWxseVNlbGVjdGVkKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgaGl0VGVzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMubGF5ZXJzW2ldLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoKTtcbiAgICB9LFxuXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCwgbnVsbCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgaW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuX2FjdGl2ZUxheWVyO1xuICAgICAgICByZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZlcnNpb24rKztcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG4gICAgICAgIHZhciBwYXJhbSA9IG5ldyBCYXNlKHtcbiAgICAgICAgICAgIG9mZnNldDogbmV3IFBvaW50KDAsIDApLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHZpZXdNYXRyaXg6IG1hdHJpeC5pc0lkZW50aXR5KCkgPyBudWxsIDogbWF0cml4LFxuICAgICAgICAgICAgbWF0cmljZXM6IFtuZXcgTWF0cml4KCldLCBcbiAgICAgICAgICAgIHVwZGF0ZU1hdHJpeDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxheWVycyA9IHRoaXMubGF5ZXJzLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGxheWVyc1tpXS5kcmF3KGN0eCwgcGFyYW0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlV2lkdGggPSAxO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGFuZGxlU2l6ZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbjtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGl0ZW1zKVxuICAgICAgICAgICAgICAgIGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1N5bWJvbCcsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2woaXRlbSwgZG9udENlbnRlcikge1xuICAgICAgICB0aGlzLl9pZCA9IFN5bWJvbC5faWQgPSAoU3ltYm9sLl9pZCB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG4gICAgICAgIHRoaXMucHJvamVjdC5zeW1ib2xzLnB1c2godGhpcyk7XG4gICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgdGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuICAgIH0sXG5cbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY2xhc3MsIHRoaXMuX2RlZmluaXRpb25dLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICAgICAgSXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAxKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb247XG4gICAgfSxcblxuICAgIHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG4gICAgICAgIGlmIChpdGVtLl9wYXJlbnRTeW1ib2wpXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5jbG9uZSgpO1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24uX3BhcmVudFN5bWJvbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICBpdGVtLnNldFNlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgaWYgKCFfZG9udENlbnRlcilcbiAgICAgICAgICAgIGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuICAgICAgICBpdGVtLl9wYXJlbnRTeW1ib2wgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG5cbiAgICBwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWRTeW1ib2wodGhpcywgcG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcbiAgICB9XG59KTtcblxudmFyIEl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG4gICAgc3RhdGljczoge1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcbiAgICAgICAgICAgIGlmIChzcmMuX3NlcmlhbGl6ZUZpZWxkcylcbiAgICAgICAgICAgICAgICBzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IG5ldyBCYXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTk9fSU5TRVJUOiB7IGluc2VydDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBfY2xhc3M6ICdJdGVtJyxcbiAgICBfYXBwbHlNYXRyaXg6IHRydWUsXG4gICAgX2NhbkFwcGx5TWF0cml4OiB0cnVlLFxuICAgIF9ib3VuZHNTZWxlY3RlZDogZmFsc2UsXG4gICAgX3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIGFwcGx5TWF0cml4OiBudWxsLFxuICAgICAgICBtYXRyaXg6IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgcGl2b3Q6IG51bGwsXG4gICAgICAgIGxvY2tlZDogZmFsc2UsXG4gICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgIGJsZW5kTW9kZTogJ25vcm1hbCcsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGd1aWRlOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjbGlwTWFzazogZmFsc2UsXG4gICAgICAgIGRhdGE6IHt9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7XG4gICAgfSxcblxuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcywgcG9pbnQpIHtcbiAgICAgICAgdmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcbiAgICAgICAgICAgIGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG4gICAgICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG4gICAgICAgICAgICBwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuICAgICAgICBpZiAoIWludGVybmFsKVxuICAgICAgICAgICAgdGhpcy5faWQgPSBJdGVtLl9pZCA9IChJdGVtLl9pZCB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgcGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG4gICAgICAgIGlmIChwb2ludClcbiAgICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuICAgICAgICBtYXRyaXguX293bmVyID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgU3R5bGUocHJvamVjdC5fY3VycmVudFN0eWxlLCB0aGlzLCBwcm9qZWN0KTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9qZWN0KSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgfHwgaGFzUHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Byb3BzICYmIHByb3BzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyZW50KHByb3BzLnBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChwcm9qZWN0Ll9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoKSkuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVClcbiAgICAgICAgICAgIHRoaXMuX3NldChwcm9wcywgeyBpbnNlcnQ6IHRydWUsIHBhcmVudDogdHJ1ZSB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGhhc1Byb3BzO1xuICAgIH0sXG5cbiAgICBfZXZlbnRzOiBuZXcgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1vdXNlRmxhZ3MgPSB7XG4gICAgICAgICAgICBtb3VzZWRvd246IHtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd246IDEsXG4gICAgICAgICAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICAgICAgICAgIGNsaWNrOiAxLFxuICAgICAgICAgICAgICAgIGRvdWJsZWNsaWNrOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2V1cDoge1xuICAgICAgICAgICAgICAgIG1vdXNldXA6IDEsXG4gICAgICAgICAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICAgICAgICAgIGNsaWNrOiAxLFxuICAgICAgICAgICAgICAgIGRvdWJsZWNsaWNrOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW91c2Vtb3ZlOiB7XG4gICAgICAgICAgICAgICAgbW91c2VkcmFnOiAxLFxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZTogMSxcbiAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiAxLFxuICAgICAgICAgICAgICAgIG1vdXNlbGVhdmU6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbW91c2VFdmVudCA9IHtcbiAgICAgICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlcnMgPSB0aGlzLmdldFZpZXcoKS5fZXZlbnRDb3VudGVycztcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2tleV0gPSAoY291bnRlcnNba2V5XSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIChtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5nZXRWaWV3KCkuX2V2ZW50Q291bnRlcnM7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNba2V5XSAtPSBtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEJhc2UuZWFjaChbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcbiAgICAgICAgICAgICdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gbW91c2VFdmVudDtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBvbkZyYW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUl0ZW0odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlSXRlbShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb25Mb2FkOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGFuaW1hdGUpO1xuICAgIH0sXG5cbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHt9LFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoYXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemUodGhpcy5fc2VyaWFsaXplRmllbGRzKTtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcbiAgICAgICAgICAgIHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuICAgICAgICByZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcbiAgICB9LFxuXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG4gICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLl9wYXJlbnRTeW1ib2wsXG4gICAgICAgICAgICBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG4gICAgICAgICAgICBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcbiAgICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fY3VycmVudFBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlUGFyZW50XG4gICAgICAgICAgICAgICAgJiYgKGZsYWdzICYgNDApKSB7XG4gICAgICAgICAgICBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgICBJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0KSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiAxKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2plY3QuX2NoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBwcm9qZWN0Ll9jaGFuZ2VzQnlJZFt0aGlzLl9pZF07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LmZsYWdzIHw9IGZsYWdzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5ID0geyBpdGVtOiB0aGlzLCBmbGFnczogZmxhZ3MgfTtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdID0gZW50cnk7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3QuX2NoYW5nZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcylcbiAgICAgICAgICAgIHRoaXMuX3NldChwcm9wcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRJZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH0sXG5cbiAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lLCB1bmlxdWUpIHtcblxuICAgICAgICBpZiAodGhpcy5fbmFtZSlcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU5hbWVkKCk7XG4gICAgICAgIGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgaWYgKG5hbWUgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIG5hbWVkQ2hpbGRyZW4gPSBwYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgb3JpZyA9IG5hbWUsXG4gICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICB3aGlsZSAodW5pcXVlICYmIGNoaWxkcmVuW25hbWVdKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBvcmlnICsgJyAnICsgKGkrKyk7XG4gICAgICAgICAgICAobmFtZWRDaGlsZHJlbltuYW1lXSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0gfHwgW10pLnB1c2godGhpcyk7XG4gICAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDEyOCk7XG4gICAgfSxcblxuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICAgIH0sXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgdGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG4gICAgfVxufSwgQmFzZS5lYWNoKFsnbG9ja2VkJywgJ3Zpc2libGUnLCAnYmxlbmRNb2RlJywgJ29wYWNpdHknLCAnZ3VpZGUnXSxcbiAgICBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuICAgICAgICAgICAgbmFtZSA9ICdfJyArIG5hbWU7XG4gICAgICAgIHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gdGhpc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKG5hbWUgPT09ICdfbG9ja2VkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAxMjggOiAxMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG57fSksIHtcbiAgICBiZWFuczogdHJ1ZSxcblxuICAgIF9sb2NrZWQ6IGZhbHNlLFxuXG4gICAgX3Zpc2libGU6IHRydWUsXG5cbiAgICBfYmxlbmRNb2RlOiAnbm9ybWFsJyxcblxuICAgIF9vcGFjaXR5OiAxLFxuXG4gICAgX2d1aWRlOiBmYWxzZSxcblxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmlzU2VsZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNlbGVjdGVkID0gISFzZWxlY3RlZCkgXiB0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3QuX3VwZGF0ZVNlbGVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoMTI5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2VsZWN0ZWQ6IGZhbHNlLFxuXG4gICAgaXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiB0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICBzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgaXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGlwTWFzaztcbiAgICB9LFxuXG4gICAgc2V0Q2xpcE1hc2s6IGZ1bmN0aW9uKGNsaXBNYXNrKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcbiAgICAgICAgICAgIGlmIChjbGlwTWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKDEyOSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fY2hhbmdlZCgxMDI0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2xpcE1hc2s6IGZhbHNlLFxuXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSlcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfSxcblxuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfSxcblxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbihfZG9udExpbmspIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG4gICAgICAgICAgICBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uID0gcGl2b3RcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90KVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB0aGlzLCAnc2V0UG9zaXRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuICAgIH0sXG5cbiAgICBnZXRQaXZvdDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG4gICAgICAgIHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuICAgICAgICBpZiAocGl2b3QpIHtcbiAgICAgICAgICAgIHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcbiAgICAgICAgICAgIHBpdm90ID0gbmV3IGN0b3IocGl2b3QueCwgcGl2b3QueSwgdGhpcywgJ3NldFBpdm90Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpdm90O1xuICAgIH0sXG5cbiAgICBzZXRQaXZvdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgX3Bpdm90OiBudWxsLFxuXG4gICAgZ2V0UmVnaXN0cmF0aW9uOiAnI2dldFBpdm90JyxcbiAgICBzZXRSZWdpc3RyYXRpb246ICcjc2V0UGl2b3QnXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG4gICAgICAgICdpbnRlcm5hbEJvdW5kcycsICdpbnRlcm5hbFJvdWdoQm91bmRzJ10sXG4gICAgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSAnZ2V0JyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICAgICAgbWF0Y2ggPSBrZXkubWF0Y2goL15pbnRlcm5hbCguKikkLyksXG4gICAgICAgICAgICBpbnRlcm5hbEdldHRlciA9IG1hdGNoID8gJ2dldCcgKyBtYXRjaFsxXSA6IG51bGw7XG4gICAgICAgIHRoaXNbZ2V0dGVyXSA9IGZ1bmN0aW9uKF9tYXRyaXgpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHNHZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG4gICAgICAgICAgICAgICAgbmFtZSA9ICFpbnRlcm5hbEdldHRlciAmJiAodHlwZW9mIGJvdW5kc0dldHRlciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYm91bmRzR2V0dGVyIDogYm91bmRzR2V0dGVyICYmIGJvdW5kc0dldHRlcltnZXR0ZXJdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxHZXR0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgTGlua2VkUmVjdGFuZ2xlKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuICAgICAgICAgICAgICAgICAgICA6IGJvdW5kcztcbiAgICAgICAgfTtcbiAgICB9LFxue1xuICAgIGJlYW5zOiB0cnVlLFxuXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIHZhciB4MSA9IEluZmluaXR5LFxuICAgICAgICAgICAgeDIgPSAteDEsXG4gICAgICAgICAgICB5MSA9IHgxLFxuICAgICAgICAgICAgeTIgPSB4MjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLl92aXNpYmxlICYmICFjaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSwgY2FjaGVJdGVtKTtcbiAgICAgICAgICAgICAgICB4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuICAgICAgICAgICAgICAgIHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG4gICAgICAgICAgICAgICAgeDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG4gICAgICAgICAgICAgICAgeTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh4MSlcbiAgICAgICAgICAgICAgICA/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuICAgICAgICAgICAgICAgIDogbmV3IFJlY3RhbmdsZSgpO1xuICAgIH0sXG5cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuICAgICAgICAgICAgY2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcbiAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuICAgICAgICBpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgbWF0cml4LnNjYWxlKFxuICAgICAgICAgICAgICAgICAgICBib3VuZHMud2lkdGggIT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAxLFxuICAgICAgICAgICAgICAgICAgICBib3VuZHMuaGVpZ2h0ICE9IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAxKTtcbiAgICAgICAgfVxuICAgICAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgIH0sXG5cbiAgICBfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtLCBpbnRlcm5hbEdldHRlcikge1xuICAgICAgICBtYXRyaXggPSBtYXRyaXggJiYgbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKTtcbiAgICAgICAgdmFyIF9tYXRyaXggPSBpbnRlcm5hbEdldHRlciA/IG51bGwgOiB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuICAgICAgICAgICAgY2FjaGUgPSAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKSAmJiBnZXR0ZXI7XG4gICAgICAgIHZhciBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnRTeW1ib2w7XG4gICAgICAgIGlmIChjYWNoZVBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gY2FjaGVJdGVtLl9pZCxcbiAgICAgICAgICAgICAgICByZWYgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuICAgICAgICAgICAgICAgICAgICBpZHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBsaXN0OiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJlZi5pZHNbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmVmLmxpc3QucHVzaChjYWNoZUl0ZW0pO1xuICAgICAgICAgICAgICAgIHJlZi5pZHNbaWRdID0gY2FjaGVJdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9ib3VuZHMgJiYgdGhpcy5fYm91bmRzW2NhY2hlXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNbY2FjaGVdLmNsb25lKCk7XG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHMoaW50ZXJuYWxHZXR0ZXIgfHwgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG1hdHJpeCB8fCBfbWF0cml4LCBjYWNoZUl0ZW0pO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm91bmRzKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX2JvdW5kc1tjYWNoZV0gPSBib3VuZHMuY2xvbmUoKTtcbiAgICAgICAgICAgIGNhY2hlZC5faW50ZXJuYWwgPSAhIWludGVybmFsR2V0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIHN0YXRpY3M6IHtcbiAgICAgICAgX2NsZWFyQm91bmRzQ2FjaGU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGl0ZW0uX2JvdW5kc0NhY2hlO1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5fYm91bmRzID0gaXRlbS5fcG9zaXRpb24gPSBpdGVtLl9ib3VuZHNDYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBsaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUob3RoZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59KSwge1xuICAgIGJlYW5zOiB0cnVlLFxuXG4gICAgX2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpO1xuICAgIH0sXG5cbiAgICBnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKTtcbiAgICAgICAgcmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5yb3RhdGlvbjtcbiAgICB9LFxuXG4gICAgc2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcbiAgICAgICAgICAgIHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG4gICAgICAgICAgICBkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgICAgICB0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRTY2FsaW5nOiBmdW5jdGlvbihfZG9udExpbmspIHtcbiAgICAgICAgdmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpLFxuICAgICAgICAgICAgc2NhbGluZyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nLFxuICAgICAgICAgICAgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG4gICAgICAgIHJldHVybiBzY2FsaW5nICYmIG5ldyBjdG9yKHNjYWxpbmcueCwgc2NhbGluZy55LCB0aGlzLCAnc2V0U2NhbGluZycpO1xuICAgIH0sXG5cbiAgICBzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG4gICAgICAgICAgICB0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcbiAgICAgICAgICAgIGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG4gICAgICAgICAgICB0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xuICAgIH0sXG5cbiAgICBzZXRNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICB0aGlzLl9tYXRyaXguaW5pdGlhbGl6ZShtYXRyaXgpO1xuICAgICAgICBpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCxcbiAgICAgICAgICAgIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuICAgICAgICBpZiAobWF0cml4ICYmIG1hdHJpeC5fdXBkYXRlVmVyc2lvbiAhPT0gdXBkYXRlVmVyc2lvbilcbiAgICAgICAgICAgIG1hdHJpeCA9IG51bGw7XG4gICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgICAgIG1hdHJpeC5wcmVDb25jYXRlbmF0ZShwYXJlbnQuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcbiAgICAgICAgICAgIG1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kb250Q2xvbmUgPyBtYXRyaXggOiBtYXRyaXguY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgZ2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG4gICAgfSxcblxuICAgIHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISF0cmFuc2Zvcm0pXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG4gICAgc2V0VHJhbnNmb3JtQ29udGVudDogJyNzZXRBcHBseU1hdHJpeCcsXG59LCB7XG4gICAgZ2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0O1xuICAgIH0sXG5cbiAgICBfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuICAgICAgICBpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2plY3QpXG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX3NldFByb2plY3QocHJvamVjdCk7XG4gICAgICAgICAgICBpbnN0YWxsRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFsbEV2ZW50cylcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG4gICAgfSxcblxuICAgIGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG4gICAgfSxcblxuICAgIF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG4gICAgICAgIF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG4gICAgfSxcblxuICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgfSxcblxuICAgIHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5hZGRDaGlsZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgfSxcblxuICAgIHNldENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcykge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuICAgIH0sXG5cbiAgICBnZXRGaXJzdENoaWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblt0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuICAgICAgICAgICAgICAgICYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeClcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2tcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9lcXVhbHMoaXRlbSlcbiAgICAgICAgICAgICAgICB8fCBmYWxzZTtcbiAgICB9LFxuXG4gICAgX2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuICAgIH0sXG5cbiAgICBfY2xvbmU6IGZ1bmN0aW9uKGNvcHksIGluc2VydCkge1xuICAgICAgICBjb3B5LnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBjb3B5LmFkZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgIHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLFxuICAgICAgICAgICAgICAgICdfY2xpcE1hc2snLCAnX2d1aWRlJywgJ19hcHBseU1hdHJpeCddO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgY29weVtrZXldID0gdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvcHkuX21hdHJpeC5pbml0aWFsaXplKHRoaXMuX21hdHJpeCk7XG4gICAgICAgIGNvcHkuX2RhdGEgPSB0aGlzLl9kYXRhID8gQmFzZS5jbG9uZSh0aGlzLl9kYXRhKSA6IG51bGw7XG4gICAgICAgIGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuICAgICAgICBpZiAodGhpcy5fbmFtZSlcbiAgICAgICAgICAgIGNvcHkuc2V0TmFtZSh0aGlzLl9uYW1lLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcblxuICAgIGNvcHlUbzogZnVuY3Rpb24oaXRlbU9yUHJvamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlbU9yUHJvamVjdC5hZGRDaGlsZCh0aGlzLmNsb25lKGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcbiAgICAgICAgICAgIHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuICAgICAgICAgICAgdG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuICAgICAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcbiAgICAgICAgICAgIGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgICAgdGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgIHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcbiAgICAgICAgcmFzdGVyLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRvcExlZnQuYWRkKHNpemUuZGl2aWRlKDIpKSlcbiAgICAgICAgICAgICAgICAuc2NhbGUoMSAvIHNjYWxlKSk7XG4gICAgICAgIHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJhc3RlcjtcbiAgICB9LFxuXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jb250YWlucyhcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG4gICAgfSxcblxuICAgIF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcbiAgICB9LFxuXG4gICAgaXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcbiAgICB9LFxuXG4gICAgX2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcbiAgICAgICAgICAgIHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuICAgICAgICAgICAgbWF0cml4OiB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgICBpbnNlcnQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0czogZnVuY3Rpb24oaXRlbSwgX21hdHJpeCkge1xuICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksXG4gICAgICAgICAgICAgICAgX21hdHJpeCB8fCBpdGVtLl9tYXRyaXgpLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGl0VGVzdChcbiAgICAgICAgICAgICAgICBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgSGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpKTtcbiAgICB9LFxuXG4gICAgX2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgICAgcGFyZW50VG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCxcbiAgICAgICAgICAgIHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcbiAgICAgICAgICAgIHRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeFxuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudFRvdGFsTWF0cml4LmNoYWluKG1hdHJpeClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZUNvbmNhdGVuYXRlKHZpZXcuX21hdHJpeCksXG4gICAgICAgICAgICB0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgUGF0aC5fZ2V0UGVuUGFkZGluZygxLCB0b3RhbE1hdHJpeC5pbnZlcnRlZCgpKVxuICAgICAgICAgICAgICAgICAgICApLm11bHRpcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDAuMDAwMDEpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEludGVybmFsUm91Z2hCb3VuZHMoKVxuICAgICAgICAgICAgICAgIC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuICAgICAgICAgICAgICAgIHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkXG4gICAgICAgICAgICAgICAgfHwgb3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG4gICAgICAgICAgICAgICAgfHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG4gICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHJlcztcblxuICAgICAgICBmdW5jdGlvbiBjaGVja0JvdW5kcyh0eXBlLCBwYXJ0KSB7XG4gICAgICAgICAgICB2YXIgcHQgPSBib3VuZHNbJ2dldCcgKyBwYXJ0XSgpO1xuICAgICAgICAgICAgaWYgKHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUodG9sZXJhbmNlUGFkZGluZykubGVuZ3RoIDw9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogQmFzZS5oeXBoZW5hdGUocGFydCksIHBvaW50OiBwdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jZW50ZXIpXG4gICAgICAgICAgICAgICAgcmVzID0gY2hlY2tCb3VuZHMoJ2NlbnRlcicsICdDZW50ZXInKTtcbiAgICAgICAgICAgIGlmICghcmVzICYmIG9wdGlvbnMuYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSBjaGVja0JvdW5kcygnYm91bmRzJywgcG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9ICFyZXMgJiYgdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9nZXRDaGlsZEhpdFRlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAhcmVzOyBpLS0pXG4gICAgICAgICAgICAgICAgcmVzID0gY2hpbGRyZW5baV0uX2hpdFRlc3QocG9pbnQsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzICYmIGNoZWNrU2VsZilcbiAgICAgICAgICAgIHJlcyA9IHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlcyAmJiByZXMucG9pbnQpXG4gICAgICAgICAgICByZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG4gICAgICAgIG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXg7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH0sXG5cbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgbWF0Y2hlczogZnVuY3Rpb24obmFtZSwgY29tcGFyZSkge1xuICAgICAgICBmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG9iajEpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsMSA9IG9iajFbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwyID0gb2JqMltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF0aGlzLm1hdGNoZXMoa2V5LCBuYW1lW2tleV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpc1snaXMnICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSgpXG4gICAgICAgICAgICAgICAgICAgIDogbmFtZSA9PT0gJ3R5cGUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzW25hbWVdO1xuICAgICAgICAgICAgaWYgKC9eKGNvbnN0cnVjdG9yfGNsYXNzKSQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgY29tcGFyZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZS50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCk7XG4gICAgfSxcblxuICAgIGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCwgbnVsbCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBbMF0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhjaGlsZHJlbiwgbWF0Y2gsIG1hdHJpeCwgcGFyYW0sXG4gICAgICAgICAgICAgICAgZmlyc3RPbmx5KSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nID0gbWF0Y2gub3ZlcmxhcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9IG1hdGNoLmluc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gb3ZlcmxhcHBpbmcgfHwgaW5zaWRlLFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gIGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG4gICAgICAgICAgICAgICAgcGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSwgXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZTogcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmc6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGU6IHJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGluc2lkZTogdHJ1ZSwgb3ZlcmxhcHBpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSBwYXJhbS5pdGVtcyxcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSBwYXJhbS5pbnNpZGUsXG4gICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSBwYXJhbS5vdmVybGFwcGluZztcbiAgICAgICAgICAgIG1hdHJpeCA9IGluc2lkZSAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUuaW50ZXJzZWN0cyhib3VuZHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGluc2lkZSAmJiBpbnNpZGUuY29udGFpbnMoYm91bmRzKSkgJiYgIShvdmVybGFwcGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIG92ZXJsYXBwaW5nLmludGVyc2VjdHMoY2hpbGQsIGNoaWxkTWF0cml4KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG1hdGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0T25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZ2V0SXRlbXMoY2hpbGQuX2NoaWxkcmVuLCBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTWF0cml4LCBwYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0T25seSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0T25seSAmJiBpdGVtcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcblxuICAgIGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgdmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlcyAhPT0gdGhpc1xuICAgICAgICAgICAgICAgID8gdGhpcy5hZGRDaGlsZChyZXMpXG4gICAgICAgICAgICAgICAgOiByZXM7XG4gICAgfSxcblxuICAgIGFkZENoaWxkOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5pbnNlcnRDaGlsZHJlbihpbmRleCwgW2l0ZW1dLCBfcHJlc2VydmUpO1xuICAgICAgICByZXR1cm4gcmVzICYmIHJlc1swXTtcbiAgICB9LFxuXG4gICAgYWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zLCBfcHJlc2VydmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcywgX3ByZXNlcnZlKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBfcHJvdG8pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShpdGVtcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChfcHJvdG8gJiYgIShpdGVtIGluc3RhbmNlb2YgX3Byb3RvKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcbiAgICAgICAgICAgICAgICBub3RpZnlTZWxmID0gcHJvamVjdCAmJiBwcm9qZWN0Ll9jaGFuZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGl0ZW0uX3BhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaXRlbS5fc2V0UHJvamVjdCh0aGlzLl9wcm9qZWN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5fbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZXROYW1lKGl0ZW0uX25hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChub3RpZnlTZWxmKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgxMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbihhYm92ZSwgaXRlbSwgX3ByZXNlcnZlKSB7XG4gICAgICAgIGlmICghaXRlbS5fcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IGl0ZW0uX2luZGV4ICsgKGFib3ZlID8gMSA6IDApO1xuICAgICAgICBpZiAoaXRlbS5fcGFyZW50ID09PSB0aGlzLl9wYXJlbnQgJiYgaW5kZXggPiB0aGlzLl9pbmRleClcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIHJldHVybiBpdGVtLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoaW5kZXgsIHRoaXMsIF9wcmVzZXJ2ZSk7XG4gICAgfSxcblxuICAgIGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydCh0cnVlLCBpdGVtLCBfcHJlc2VydmUpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRCZWxvdzogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQoZmFsc2UsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG4gICAgfSxcblxuICAgIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG4gICAgYXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuICAgIH0sXG5cbiAgICBtb3ZlQWJvdmU6ICcjaW5zZXJ0QWJvdmUnLFxuXG4gICAgbW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuICAgIHJlZHVjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuICAgICAgICAgICAgY2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgICAgICBjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIG5hbWVkQ2hpbGRyZW4gPSBwYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICAgICAgICAgICAgbmFtZWRBcnJheSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0sXG4gICAgICAgICAgICAgICAgaW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICAgICAgICBuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbihub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTmFtZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIEJhc2Uuc3BsaWNlKHBhcmVudC5fY2hpbGRyZW4sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG5vdGlmeVNlbGYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCg1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RpZnlQYXJlbnQpXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9jaGFuZ2VkKDExKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBvayA9IGl0ZW0gJiYgaXRlbS5pbnNlcnRCZWxvdyh0aGlzKTtcbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIG9rO1xuICAgIH0sXG5cbiAgICByZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmcm9tID0gZnJvbSB8fCAwO1xuICAgICAgICB0byA9IEJhc2UucGljayh0bywgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlbW92ZWRbaV0uX3JlbW92ZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoMTEpO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgY2xlYXI6ICcjcmVtb3ZlQ2hpbGRyZW4nLFxuXG4gICAgcmV2ZXJzZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5faW5kZXggPSBpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgxMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIH0sXG5cbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG4gICAgfSxcblxuICAgIGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG4gICAgfSxcblxuICAgIGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU2hhZG93KCk7XG4gICAgfSxcblxuICAgIF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdDEgPSBnZXRMaXN0KHRoaXMpLFxuICAgICAgICAgICAgbGlzdDIgPSBnZXRMaXN0KGl0ZW0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QxW2ldLl9pbmRleCA8IGxpc3QyW2ldLl9pbmRleCA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgaXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaXNJbnNlcnRlZCgpIDogZmFsc2U7XG4gICAgfSxcblxuICAgIGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcbiAgICB9LFxuXG4gICAgaXNCZWxvdzogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG4gICAgfSxcblxuICAgIGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW07XG4gICAgfSxcblxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSBpdGVtKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG4gICAgfSxcblxuICAgIGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5fcGFyZW50XG4gICAgICAgICAgICAgICAgJiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcbiAgICAgICAgICAgICAgICAmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5yb3RhdGUoYW5nbGUsXG4gICAgICAgICAgICAgICAgUG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuICAgIH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClbbmFtZV0ocG9pbnQsXG4gICAgICAgICAgICAgICAgY2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcbiAgICB9O1xufSwge1xuXG59KSwge1xuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlNYXRyaXgpIHtcbiAgICAgICAgaWYgKG1hdHJpeCAmJiBtYXRyaXguaXNJZGVudGl0eSgpKVxuICAgICAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgICAgdmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG4gICAgICAgICAgICBhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG4gICAgICAgICAgICAgICAgJiYgKCFfbWF0cml4LmlzSWRlbnRpdHkoKSB8fCBtYXRyaXgpO1xuICAgICAgICBpZiAoIW1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG1hdHJpeClcbiAgICAgICAgICAgIF9tYXRyaXgucHJlQ29uY2F0ZW5hdGUobWF0cml4KTtcbiAgICAgICAgaWYgKGFwcGx5TWF0cml4ID0gYXBwbHlNYXRyaXggJiYgdGhpcy5fdHJhbnNmb3JtQ29udGVudChfbWF0cml4KSkge1xuICAgICAgICAgICAgdmFyIHBpdm90ID0gdGhpcy5fcGl2b3QsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcbiAgICAgICAgICAgIGlmIChwaXZvdClcbiAgICAgICAgICAgICAgICBfbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdCwgcGl2b3QsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuICAgICAgICAgICAgaWYgKHN0cm9rZUNvbG9yKVxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcbiAgICAgICAgICAgIF9tYXRyaXgucmVzZXQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcyxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgICAgIHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcbiAgICAgICAgaWYgKGRlY29tcCAmJiAhZGVjb21wLnNoZWFyaW5nICYmIGRlY29tcC5yb3RhdGlvbiAlIDkwID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBib3VuZHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbHlNYXRyaXggfHwgIXJlY3QuX2ludGVybmFsKVxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG4gICAgICAgICAgICAgICAgcmVjdCA9IGJvdW5kc1tnZXR0ZXIgJiYgZ2V0dGVyLmdldEJvdW5kcyB8fCBnZXR0ZXIgfHwgJ2dldEJvdW5kcyddO1xuICAgICAgICAgICAgaWYgKHJlY3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSByZWN0LmdldENlbnRlcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgfSBlbHNlIGlmIChtYXRyaXggJiYgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICBsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl90cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgICAgICAgICBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICBwYXJlbnRUb0xvY2FsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICBsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcbiAgICAgICAgcmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgICBpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgcmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcbiAgICAgICAgICAgIHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pXG4gICAgICAgICAgICAgICAgICAgID8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG4gICAgICAgICAgICAgICAgICAgIDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG4gICAgICAgIG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcbiAgICAgICAgdGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcbiAgICB9LFxuXG4gICAgX3NldFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgICAgZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKCksXG4gICAgICAgICAgICBzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCksXG4gICAgICAgICAgICBzaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCk7XG4gICAgICAgIGlmIChmaWxsQ29sb3IpXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKHN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuICAgICAgICAgICAgICAgICAgICBtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJva2VKb2luKVxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuICAgICAgICAgICAgICAgIGlmIChzdHJva2VDYXApXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuICAgICAgICAgICAgICAgIGlmIChtaXRlckxpbWl0KVxuICAgICAgICAgICAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhZG93Q29sb3IpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3dCbHVyID0gc3R5bGUuZ2V0U2hhZG93Qmx1cigpO1xuICAgICAgICAgICAgaWYgKHNoYWRvd0JsdXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRTaGFkb3dPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG4gICAgICAgIHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcbiAgICAgICAgICAgIHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuICAgICAgICAgICAgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuICAgICAgICAgICAgZ2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uY2hhaW4obWF0cml4KTtcbiAgICAgICAgaWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChtYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5jaGFpbihtYXRyaXgpIDogbWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuICAgICAgICBpZiAocGFyYW0udXBkYXRlTWF0cml4KSB7XG4gICAgICAgICAgICBnbG9iYWxNYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuICAgICAgICAgICAgbm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuICAgICAgICAgICAgbmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcbiAgICAgICAgICAgIGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyYW0uZG9udFN0YXJ0IFxuICAgICAgICAgICAgICAgICAgICB8fCBwYXJhbS5jbGlwXG4gICAgICAgICAgICAgICAgICAgIHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8sXG4gICAgICAgICAgICBtYWluQ3R4LCBpdGVtT2Zmc2V0LCBwcmV2T2Zmc2V0O1xuICAgICAgICBpZiAoIWRpcmVjdCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSk7XG4gICAgICAgICAgICBpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuICAgICAgICAgICAgaXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcbiAgICAgICAgICAgIG1haW5DdHggPSBjdHg7XG4gICAgICAgICAgICBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKVxuICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuICAgICAgICAgICAgaWYgKHBpeGVsUmF0aW8gIT09IDEpXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXhcbiAgICAgICAgICAgICAgICA/IHBhcmVudFN0cm9rZU1hdHJpeC5jaGFpbihtYXRyaXgpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSxcbiAgICAgICAgICAgIGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuICAgICAgICAgICAgdHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuICAgICAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUJsZW5kKVxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pXG4gICAgICAgICAgICAoZGlyZWN0ID8gbWF0cml4IDogZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKS5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgICBpZiAoY2xpcClcbiAgICAgICAgICAgIHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcbiAgICAgICAgaWYgKHN0cm9rZU1hdHJpeCkge1xuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0KVxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgbWF0cmljZXMucG9wKCk7XG4gICAgICAgIGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKVxuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgaWYgKCFkaXJlY3QpIHtcbiAgICAgICAgICAgIEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICBpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcbiAgICAgICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgICAgICAgIHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2lzVXBkYXRlZDogZnVuY3Rpb24odXBkYXRlVmVyc2lvbikge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuICAgICAgICB2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPT09IHVwZGF0ZVZlcnNpb247XG4gICAgICAgIGlmICghdXBkYXRlZCAmJiBwYXJlbnQgJiYgcGFyZW50Ll92aXNpYmxlXG4gICAgICAgICAgICAgICAgJiYgcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSxcblxuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgc2VsZWN0ZWRJdGVtcywgdXBkYXRlVmVyc2lvbikge1xuICAgICAgICBpZiAoKHRoaXMuX2RyYXdTZWxlY3RlZCB8fCB0aGlzLl9ib3VuZHNTZWxlY3RlZClcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKVxuICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLmdldExheWVyKCkuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSxcbiAgICAgICAgICAgICAgICBteCA9IG1hdHJpeC5jaGFpbih0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb2xvci50b0NhbnZhc1N0eWxlKGN0eCkgOiAnIzAwOWRlYyc7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd1NlbGVjdGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdTZWxlY3RlZChjdHgsIG14LCBzZWxlY3RlZEl0ZW1zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib3VuZHNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmID0gc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IG14Ll90cmFuc2Zvcm1Db3JuZXJzKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpc1sncmVtb3ZlT24nICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFzaCA9IHt9O1xuICAgICAgICBoYXNoW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlT24oaGFzaCk7XG4gICAgfTtcbn0sIHtcblxuICAgIHJlbW92ZU9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmpbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuICAgICAgICAgICAgICAgICAgICBzZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgfHwge307XG4gICAgICAgICAgICAgICAgc2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuICAgICAgICAgICAgICAgIHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0dyb3VwJyxcbiAgICBfc2VsZWN0Q2hpbGRyZW46IHRydWUsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgICBjaGlsZHJlbjogW11cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuICAgICAgICBfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuICAgICAgICBpZiAoZmxhZ3MgJiAxMDI2KSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Q2xpcEl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcbiAgICAgICAgaWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsaXBJdGVtID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLl9jbGlwTWFzaykge1xuICAgICAgICAgICAgICAgICAgICBjbGlwSXRlbSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jbGlwSXRlbSA9IGNsaXBJdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGlwSXRlbTtcbiAgICB9LFxuXG4gICAgaXNDbGlwcGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcbiAgICB9LFxuXG4gICAgc2V0Q2xpcHBlZDogZnVuY3Rpb24oY2xpcHBlZCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgY2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG4gICAgfSxcblxuICAgIF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG4gICAgICAgIHZhciBjbGlwID0gcGFyYW0uY2xpcCxcbiAgICAgICAgICAgIGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKSxcbiAgICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICBwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICBjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcbiAgICAgICAgICAgICAgICBkcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbGlwSXRlbSkge1xuICAgICAgICAgICAgY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGNsaXBJdGVtKVxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBMYXllciA9IEdyb3VwLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTGF5ZXInLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoYXJnKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG4gICAgICAgICAgICAgICAgPyBuZXcgQmFzZShhcmcpIFxuICAgICAgICAgICAgICAgIDogeyBjaGlsZHJlbjogQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzIH0sXG4gICAgICAgICAgICBpbnNlcnQgPSBwcm9wcy5pbnNlcnQ7XG4gICAgICAgIHByb3BzLmluc2VydCA9IGZhbHNlO1xuICAgICAgICBHcm91cC5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgICAgaWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdC5hZGRDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbiBfcmVtb3ZlKG5vdGlmeSkge1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIF9yZW1vdmUuYmFzZS5jYWxsKHRoaXMsIG5vdGlmeSk7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG4gICAgICAgICAgICBpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgICBCYXNlLnNwbGljZShwcm9qZWN0LmxheWVycywgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG4gICAgICAgICAgICBwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbiBnZXROZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldE5leHRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuICAgICAgICAgICAgICAgIDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldFByZXZpb3VzU2libGluZy5iYXNlLmNhbGwodGhpcylcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgaXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXM7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIF9pbnNlcnQoYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIExheWVyICYmICFpdGVtLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIEJhc2Uuc3BsaWNlKGl0ZW0uX3Byb2plY3QubGF5ZXJzLCBbdGhpc10sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uX2luZGV4ICsgKGFib3ZlID8gMSA6IDApLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb2plY3QoaXRlbS5fcHJvamVjdCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2luc2VydC5iYXNlLmNhbGwodGhpcywgYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG4gICAgfVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTaGFwZScsXG4gICAgX2FwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgIHJhZGl1czogbnVsbFxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcykge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcbiAgICB9LFxuXG4gICAgX2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZVxuICAgICAgICAgICAgJiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSlcbiAgICAgICAgICAgICYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBTaGFwZShJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgIGNvcHkuc2V0VHlwZSh0aGlzLl90eXBlKTtcbiAgICAgICAgY29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuICAgICAgICBjb3B5LnNldFJhZGl1cyh0aGlzLl9yYWRpdXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sXG5cbiAgICBzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIH0sXG5cbiAgICBnZXRTaGFwZTogJyNnZXRUeXBlJyxcbiAgICBzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICAgIHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghdGhpcy5fc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMuc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhZCA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG4gICAgICAgICAgICAgICAgPyByYWRcbiAgICAgICAgICAgICAgICA6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuICAgIH0sXG5cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHJhZGl1cykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICAgICAgaWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBzaXplID0gcmFkaXVzICogMjtcbiAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgICAgIHRoaXMuX3NpemUuc2V0KHNpemUsIHNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmFkaXVzLmVxdWFscyhyYWRpdXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IFNpemUubWF4KHRoaXMuX3NpemUsIHJhZGl1cy5tdWx0aXBseSgyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaXplLnNldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoOSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGhbQmFzZS5jYXBpdGFsaXplKHRoaXMuX3R5cGUpXSh7XG4gICAgICAgICAgICBjZW50ZXI6IG5ldyBQb2ludCgpLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5fc2l6ZSxcbiAgICAgICAgICAgIHJhZGl1czogdGhpcy5fcmFkaXVzLFxuICAgICAgICAgICAgaW5zZXJ0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG4gICAgICAgIHBhdGgudHJhbnNmb3JtKHRoaXMuX21hdHJpeCk7XG4gICAgICAgIGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgX2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICAgIGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG4gICAgICAgICAgICBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcbiAgICAgICAgICAgIHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuICAgICAgICBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuICAgICAgICAgICAgICAgIGlzQ2lyY2xlID0gdHlwZSA9PT0gJ2NpcmNsZSc7XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmRvbnRTdGFydClcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByeCA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICByeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3NpemUsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHVudHJhbnNmb3JtZWQgJiYgdHlwZSA9PT0gJ3JlY3QnICYmIHJ4ID09PSAwICYmIHJ5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHdpZHRoIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAga2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSByeCAqIGthcHBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSByeSAqIGthcHBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCwgLXkgKyByeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCwgLXkgKyBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCArIGN4LCAteSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCArIHJ4LCAteSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4IC0gcngsIC15LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLSBjeCwgLXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgLXkgKyBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCAteSArIHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHkgLSByeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5IC0gY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAtIGN4LCB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLSByeCwgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCArIHJ4LCB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC14ICsgY3gsIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLXgsIHkgLSBjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAteCwgeSAtIHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlTWF0cml4KVxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCAhPT0gcngpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgIT09IHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjWzE2XSwgY1sxN10pO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggIT09IHJ4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzI2XSwgY1syN10sIGNbMjhdLCBjWzI5XSwgY1szMF0sIGNbMzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCk7XG4gICAgICAgICAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTdHJva2UpXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcbiAgICB9LFxuXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcbiAgICAgICAgaWYgKGdldHRlciAhPT0gJ2dldEJvdW5kcycgJiYgdGhpcy5oYXNTdHJva2UoKSlcbiAgICAgICAgICAgIHJlY3QgPSByZWN0LmV4cGFuZCh0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xuICAgICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuICAgIH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7IFxuXG4gICAgZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcbiAgICAgICAgaWYgKCFyYWRpdXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHZhciBoYWxmU2l6ZSA9IHRoYXQuX3NpemUuZGl2aWRlKDIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gbmV3IFBvaW50KGkgJiAxID8gMSA6IC0xLCBpID4gMSA/IDEgOiAtMSksXG4gICAgICAgICAgICAgICAgICAgIGNvcm5lciA9IGRpci5tdWx0aXBseShoYWxmU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvcm5lciwgY2VudGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gcG9pbnQuZ2V0QW5nbGVJblJhZGlhbnMoKSxcbiAgICAgICAgICAgIHdpZHRoID0gcmFkaXVzLndpZHRoICogMixcbiAgICAgICAgICAgIGhlaWdodCA9IHJhZGl1cy5oZWlnaHQgKiAyLFxuICAgICAgICAgICAgeCA9IHdpZHRoICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgeSA9IGhlaWdodCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoICogaGVpZ2h0IC8gKDIgKiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBvaW50LnN1YnRyYWN0KGNlbnRlcikuZGl2aWRlKHRoaXMuX3JhZGl1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0TGVuZ3RoKCkgPD0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIF9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0ID0gcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdCA9IDIgKiBNYXRoLmFicyhwdC5nZXRMZW5ndGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGdldEVsbGlwc2VSYWRpdXMocHQsIHJhZGl1cykpIDw9IHN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlciA9IHJlY3QuZXhwYW5kKHN0cm9rZVdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lciA9IHJlY3QuZXhwYW5kKC1zdHJva2VXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWlubmVyLl9jb250YWluc1BvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZWxsaXBzZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBoaXQgPSAyICogTWF0aC5hYnMocG9pbnQuZ2V0TGVuZ3RoKCkgLSByYWRpdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPD0gc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhpdFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59LCB7XG5cbnN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG4gICAgICAgIHZhciBpdGVtID0gbmV3IFNoYXBlKEJhc2UuZ2V0TmFtZWQoYXJncykpO1xuICAgICAgICBpdGVtLl90eXBlID0gdHlwZTtcbiAgICAgICAgaXRlbS5fc2l6ZSA9IHNpemU7XG4gICAgICAgIGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgcmV0dXJuIGl0ZW0udHJhbnNsYXRlKHBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBDaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5taW4oU2l6ZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgncmVjdGFuZ2xlJywgcmVjdC5nZXRDZW50ZXIodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIsXG4gICAgICAgICAgICAgICAgcmFkaXVzO1xuICAgICAgICAgICAgaWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKTtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuICAgICAgICB9XG4gICAgfTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdSYXN0ZXInLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcbiAgICBfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgICBzb3VyY2U6IG51bGxcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplKG9iamVjdCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U291cmNlKG9iamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1hZ2Uob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3NpemUpXG4gICAgICAgICAgICB0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcbiAgICB9LFxuXG4gICAgX2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpLFxuICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICBjb3B5LnNldEltYWdlKGltYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHRoaXMuX3NpemUpO1xuICAgICAgICAgICAgY29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgICAgICAgICAgY29weS5zZXRDYW52YXMoY29weUNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG4gICAgfSxcblxuICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICAgIHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLnNldENhbnZhcyhDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSkpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUud2lkdGg7XG4gICAgfSxcblxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplLmhlaWdodDtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplLndpZHRoID09PSAwICYmIHRoaXMuX3NpemUuaGVpZ2h0ID09PSAwO1xuICAgIH0sXG5cbiAgICBnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICAgIG9yaWcgPSBuZXcgUG9pbnQoMCwgMCkudHJhbnNmb3JtKG1hdHJpeCksXG4gICAgICAgICAgICB1ID0gbmV3IFBvaW50KDEsIDApLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpLFxuICAgICAgICAgICAgdiA9IG5ldyBQb2ludCgwLCAxKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaXplKFxuICAgICAgICAgICAgNzIgLyB1LmdldExlbmd0aCgpLFxuICAgICAgICAgICAgNzIgLyB2LmdldExlbmd0aCgpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFBwaTogJyNnZXRSZXNvbHV0aW9uJyxcblxuICAgIGdldEltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICAgIH0sXG5cbiAgICBzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcylcbiAgICAgICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcbiAgICAgICAgaWYgKGltYWdlICYmIGltYWdlLmdldENvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuICAgICAgICAgICAgICAgIGltYWdlID8gaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoIDogMCxcbiAgICAgICAgICAgICAgICBpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDUyMSk7XG4gICAgfSxcblxuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ltYWdlKVxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICAgIH0sXG5cbiAgICBzZXRDYW52YXM6ICcjc2V0SW1hZ2UnLFxuXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24obW9kaWZ5KSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dClcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChtb2RpZnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoNTEzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgICB9LFxuXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9LFxuXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuICAgIH0sXG5cbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBpbWFnZTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkZWQoKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBwYXBlciA9IHZpZXcuX3Njb3BlO1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnbG9hZCcpO1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAgICAgaW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzcmMpIHx8IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkZWQsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRG9tRXZlbnQuYWRkKGltYWdlLCB7XG4gICAgICAgICAgICAgICAgbG9hZDogbG9hZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaW1hZ2Uuc3JjKVxuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEltYWdlKGltYWdlKTtcbiAgICB9LFxuXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5faW1hZ2U7XG4gICAgfVxufSwge1xuICAgIGJlYW5zOiBmYWxzZSxcblxuICAgIGdldFN1YkNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHJlY3QueCwgcmVjdC55LFxuICAgICAgICAgICAgICAgIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIHJldHVybiBjdHguY2FudmFzO1xuICAgIH0sXG5cbiAgICBnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICByYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgcmFzdGVyLnNldENhbnZhcyh0aGlzLmdldFN1YkNhbnZhcyhyZWN0KSk7XG4gICAgICAgIHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcbiAgICAgICAgcmFzdGVyLl9tYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fbWF0cml4KTtcbiAgICAgICAgcmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmFzdGVyO1xuICAgIH0sXG5cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjID0gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2Uuc3JjO1xuICAgICAgICBpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgIHJldHVybiBjYW52YXMgPyBjYW52YXMudG9EYXRhVVJMKCkgOiBudWxsO1xuICAgIH0sXG5cbiAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlICkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBnZXRBdmVyYWdlQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgYm91bmRzLCBwYXRoO1xuICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXRoSXRlbSkge1xuICAgICAgICAgICAgcGF0aCA9IG9iamVjdDtcbiAgICAgICAgICAgIGJvdW5kcyA9IG9iamVjdC5nZXRCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3Qud2lkdGgpIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QueCkge1xuICAgICAgICAgICAgYm91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYW1wbGVTaXplID0gMzIsXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcbiAgICAgICAgdmFyIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dDtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTaXplKHNhbXBsZVNpemUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2FtcGxlU2l6ZSArIDEsIHNhbXBsZVNpemUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG4gICAgICAgICAgICAgICAgLnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoLWJvdW5kcy54LCAtYm91bmRzLnkpO1xuICAgICAgICBtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcbiAgICAgICAgaWYgKHBhdGgpXG4gICAgICAgICAgICBwYXRoLmRyYXcoY3R4LCBuZXcgQmFzZSh7IGNsaXA6IHRydWUsIG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG4gICAgICAgIHRoaXMuX21hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuZ2V0RWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHZhciBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAuNSwgMC41LCBNYXRoLmNlaWwod2lkdGgpLFxuICAgICAgICAgICAgICAgIE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuICAgICAgICAgICAgY2hhbm5lbHMgPSBbMCwgMCwgMF0sXG4gICAgICAgICAgICB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gcGl4ZWxzW2kgKyAzXTtcbiAgICAgICAgICAgIHRvdGFsICs9IGFscGhhO1xuICAgICAgICAgICAgYWxwaGEgLz0gMjU1O1xuICAgICAgICAgICAgY2hhbm5lbHNbMF0gKz0gcGl4ZWxzW2ldICogYWxwaGE7XG4gICAgICAgICAgICBjaGFubmVsc1sxXSArPSBwaXhlbHNbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBjaGFubmVsc1syXSArPSBwaXhlbHNbaSArIDJdICogYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG4gICAgICAgICAgICBjaGFubmVsc1tpXSAvPSB0b3RhbDtcbiAgICAgICAgcmV0dXJuIHRvdGFsID8gQ29sb3IucmVhZChjaGFubmVscykgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRQaXhlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEocG9pbnQueCwgcG9pbnQueSwgMSwgMSkuZGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcigncmdiJywgW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdLFxuICAgICAgICAgICAgICAgIGRhdGFbM10gLyAyNTUpO1xuICAgIH0sXG5cbiAgICBzZXRQaXhlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgY29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcbiAgICAgICAgICAgIGFscGhhID0gY29sb3IuX2FscGhhLFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuICAgICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgZGF0YVswXSA9IGNvbXBvbmVudHNbMF0gKiAyNTU7XG4gICAgICAgIGRhdGFbMV0gPSBjb21wb25lbnRzWzFdICogMjU1O1xuICAgICAgICBkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcbiAgICAgICAgZGF0YVszXSA9IGFscGhhICE9IG51bGwgPyBhbHBoYSAqIDI1NSA6IDI1NTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuY3JlYXRlSW1hZ2VEYXRhKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVjdC5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcbiAgICAgICAgICAgICAgICByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgfSxcblxuICAgIHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0aGlzLmdldENvbnRleHQodHJ1ZSkucHV0SW1hZ2VEYXRhKGRhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuICAgICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuICAgIH0sXG5cbiAgICBfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcbiAgICAgICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLXRoaXMuX3NpemUud2lkdGggLyAyLCAtdGhpcy5fc2l6ZS5oZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbnZhciBQbGFjZWRTeW1ib2wgPSBJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUGxhY2VkU3ltYm9sJyxcbiAgICBfYXBwbHlNYXRyaXg6IGZhbHNlLFxuICAgIF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2JvdW5kc0dldHRlcjogeyBnZXRCb3VuZHM6ICdnZXRTdHJva2VCb3VuZHMnIH0sXG4gICAgX2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuICAgIF9zZXJpYWxpemVGaWVsZHM6IHtcbiAgICAgICAgc3ltYm9sOiBudWxsXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBsYWNlZFN5bWJvbChhcmcwLCBhcmcxKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuICAgICAgICAgICAgICAgIGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKVxuICAgICAgICAgICAgdGhpcy5zZXRTeW1ib2woYXJnMCBpbnN0YW5jZW9mIFN5bWJvbCA/IGFyZzAgOiBuZXcgU3ltYm9sKGFyZzApKTtcbiAgICB9LFxuXG4gICAgX2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ltYm9sID09PSBpdGVtLl9zeW1ib2w7XG4gICAgfSxcblxuICAgIGdldFN5bWJvbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zeW1ib2w7XG4gICAgfSxcblxuICAgIHNldFN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHRoaXMuX3N5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCg5KTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBQbGFjZWRTeW1ib2woSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICBjb3B5LnNldFN5bWJvbCh0aGlzLl9zeW1ib2wpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtKSB7XG4gICAgICAgIHZhciBkZWZpbml0aW9uID0gdGhpcy5zeW1ib2wuX2RlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oZGVmaW5pdGlvbi5fbWF0cml4KSwgY2FjaGVJdGVtKTtcbiAgICB9LFxuXG4gICAgX2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5fc3ltYm9sLl9kZWZpbml0aW9uLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgIHJlcy5pdGVtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgX2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcbiAgICAgICAgdGhpcy5zeW1ib2wuX2RlZmluaXRpb24uZHJhdyhjdHgsIHBhcmFtKTtcbiAgICB9XG5cbn0pO1xuXG52YXIgSGl0UmVzdWx0ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhbHVlcy5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGljczoge1xuICAgICAgICBnZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhc2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG4gICAgICAgICAgICAgICAgZmlsbDogIW9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAhb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzZWdtZW50czogIW9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaGFuZGxlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5kczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2VudGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBib3VuZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGd1aWRlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdTZWdtZW50JyxcbiAgICBiZWFuczogdHJ1ZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICAgICAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgcG9pbnQsIGhhbmRsZUluLCBoYW5kbGVPdXQ7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoYXJnMC5wb2ludCkge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gYXJnMC5wb2ludDtcbiAgICAgICAgICAgICAgICBoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG4gICAgICAgICAgICAgICAgaGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gYXJnMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMiAmJiB0eXBlb2YgYXJnMCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHBvaW50ID0gYXJndW1lbnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDMpIHtcbiAgICAgICAgICAgIHBvaW50ID0gYXJnMDtcbiAgICAgICAgICAgIGhhbmRsZUluID0gYXJnMTtcbiAgICAgICAgICAgIGhhbmRsZU91dCA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSB7IFxuICAgICAgICAgICAgcG9pbnQgPSBhcmcwICE9PSB1bmRlZmluZWQgPyBbIGFyZzAsIGFyZzEgXSA6IG51bGw7XG4gICAgICAgICAgICBoYW5kbGVJbiA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IFsgYXJnMiwgYXJnMyBdIDogbnVsbDtcbiAgICAgICAgICAgIGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG4gICAgICAgIG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcbiAgICAgICAgbmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaXNMaW5lYXIoKSA/IHRoaXMuX3BvaW50XG4gICAgICAgICAgICAgICAgOiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4LFxuICAgICAgICAgICAgY3VydmU7XG4gICAgICAgIGlmIChjdXJ2ZXMpIHtcbiAgICAgICAgICAgIGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlSW4pXG4gICAgICAgICAgICAgICAgICAgICYmIChjdXJ2ZSA9IGluZGV4ID4gMCA/IGN1cnZlc1tpbmRleCAtIDFdIDogcGF0aC5fY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0gOiBudWxsKSlcbiAgICAgICAgICAgICAgICBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgICAgICAgaWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQpXG4gICAgICAgICAgICAgICAgICAgICYmIChjdXJ2ZSA9IGN1cnZlc1tpbmRleF0pKVxuICAgICAgICAgICAgICAgIGN1cnZlLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aC5fY2hhbmdlZCgyNSk7XG4gICAgfSxcblxuICAgIGdldFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50O1xuICAgIH0sXG5cbiAgICBzZXRQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbjtcbiAgICB9LFxuXG4gICAgc2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuXG4gICAgZ2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcbiAgICB9LFxuXG4gICAgc2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCk7XG4gICAgfSxcblxuICAgIHNldExpbmVhcjogZnVuY3Rpb24obGluZWFyKSB7XG4gICAgICAgIGlmIChsaW5lYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUluLnNldCgwLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNDb2xpbmVhcjogZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgICB2YXIgbmV4dDEgPSB0aGlzLmdldE5leHQoKSxcbiAgICAgICAgICAgIG5leHQyID0gc2VnbWVudC5nZXROZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dDEuX2hhbmRsZUluLmlzWmVybygpXG4gICAgICAgICAgICAgICAgJiYgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQyLl9oYW5kbGVJbi5pc1plcm8oKVxuICAgICAgICAgICAgICAgICYmIG5leHQxLl9wb2ludC5zdWJ0cmFjdCh0aGlzLl9wb2ludCkuaXNDb2xpbmVhcihcbiAgICAgICAgICAgICAgICAgICAgbmV4dDIuX3BvaW50LnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG4gICAgfSxcblxuICAgIGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXRQcmV2aW91cygpLFxuICAgICAgICAgICAgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICByZXR1cm4gcHJldi5faGFuZGxlT3V0LmlzWmVybygpICYmIHRoaXMuX2hhbmRsZUluLmlzWmVybygpXG4gICAgICAgICAgICAmJiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dC5faGFuZGxlSW4uaXNaZXJvKClcbiAgICAgICAgICAgICYmIHRoaXMuX3BvaW50LnN1YnRyYWN0KHByZXYuX3BvaW50KS5pc09ydGhvZ29uYWwoXG4gICAgICAgICAgICAgICAgICAgIG5leHQuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSk7XG4gICAgfSxcblxuICAgIGlzQXJjOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKSxcbiAgICAgICAgICAgIGhhbmRsZTEgPSB0aGlzLl9oYW5kbGVPdXQsXG4gICAgICAgICAgICBoYW5kbGUyID0gbmV4dC5faGFuZGxlSW4sXG4gICAgICAgICAgICBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcbiAgICAgICAgaWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuX3BvaW50LFxuICAgICAgICAgICAgICAgIHRvID0gbmV4dC5fcG9pbnQsXG4gICAgICAgICAgICAgICAgY29ybmVyID0gbmV3IExpbmUoZnJvbSwgaGFuZGxlMSwgdHJ1ZSkuaW50ZXJzZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IExpbmUodG8sIGhhbmRsZTIsIHRydWUpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb3JuZXIgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUxLmdldExlbmd0aCgpIC9cbiAgICAgICAgICAgICAgICAgICAgY29ybmVyLnN1YnRyYWN0KGZyb20pLmdldExlbmd0aCgpIC0ga2FwcGEpXG4gICAgICAgICAgICAgICAgJiYgTnVtZXJpY2FsLmlzWmVybyhoYW5kbGUyLmdldExlbmd0aCgpIC9cbiAgICAgICAgICAgICAgICAgICAgY29ybmVyLnN1YnRyYWN0KHRvKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9zZWxlY3Rpb25TdGF0ZTogMCxcblxuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKF9wb2ludCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgcmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG4gICAgICAgICAgICA6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG4gICAgICAgICAgICA6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG4gICAgICAgICAgICA6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBfcG9pbnQpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSAhIXNlbGVjdGVkLCBcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG4gICAgICAgICAgICBvbGRTdGF0ZSA9IHN0YXRlLFxuICAgICAgICAgICAgZmxhZyA9ICFfcG9pbnQgPyA3XG4gICAgICAgICAgICAgICAgICAgIDogX3BvaW50ID09PSB0aGlzLl9wb2ludCA/IDRcbiAgICAgICAgICAgICAgICAgICAgOiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluID8gMVxuICAgICAgICAgICAgICAgICAgICA6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgc3RhdGUgfD0gZmxhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlICY9IH5mbGFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgcGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG4gICAgICAgICAgICBwYXRoLl9jaGFuZ2VkKDEyOSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldEN1cnZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgIXBhdGguX2Nsb3NlZFxuICAgICAgICAgICAgICAgICAgICAmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGguZ2V0Q3VydmVzKClbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuICAgICAgICByZXR1cm4gY3VydmVcbiAgICAgICAgICAgICAgICA/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfSxcblxuICAgIGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuICAgICAgICByZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4ICsgMV1cbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbMF0pIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCAtIDFdXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVPdXQsIHRoaXMuX2hhbmRsZUluKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGggPyAhIXRoaXMuX3BhdGgucmVtb3ZlU2VnbWVudCh0aGlzLl9pbmRleCkgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQgPT09IHRoaXMgfHwgc2VnbWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gc2VnbWVudC5fY2xhc3NcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9wb2ludC5lcXVhbHMoc2VnbWVudC5fcG9pbnQpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuX2hhbmRsZU91dC5lcXVhbHMoc2VnbWVudC5faGFuZGxlT3V0KVxuICAgICAgICAgICAgICAgIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ2hhbmRsZUluOiAnICsgdGhpcy5faGFuZGxlSW4pO1xuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ2hhbmRsZU91dDogJyArIHRoaXMuX2hhbmRsZU91dCk7XG4gICAgICAgIHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG4gICAgICAgICAgICBoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuICAgICAgICAgICAgaGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcbiAgICAgICAgICAgIHggPSBwb2ludC5feCxcbiAgICAgICAgICAgIHkgPSBwb2ludC5feSxcbiAgICAgICAgICAgIGkgPSAyO1xuICAgICAgICBjb29yZHNbMF0gPSB4O1xuICAgICAgICBjb29yZHNbMV0gPSB5O1xuICAgICAgICBpZiAoaGFuZGxlSW4pIHtcbiAgICAgICAgICAgIGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZU91dCkge1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuICAgICAgICAgICAgY29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcbiAgICAgICAgICAgIHggPSBjb29yZHNbMF07XG4gICAgICAgICAgICB5ID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHBvaW50Ll94ID0geDtcbiAgICAgICAgICAgICAgICBwb2ludC5feSA9IHk7XG4gICAgICAgICAgICAgICAgaSAgPSAyO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVJbikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVJbi5feCA9IGNvb3Jkc1tpKytdIC0geDtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVPdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT3V0Ll94ID0gY29vcmRzW2krK10gLSB4O1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZUluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geDtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzW2krK10gPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU91dCkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNbaSsrXSA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tpKytdID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudFBvaW50KHBvaW50LCBvd25lciwga2V5KSB7XG4gICAgICAgIHZhciB4LCB5LCBzZWxlY3RlZDtcbiAgICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICAgICAgeCA9IHkgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHsgXG4gICAgICAgICAgICB5ID0gcG9pbnRbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHQgPSBwb2ludDtcbiAgICAgICAgICAgIGlmICgoeCA9IHB0LngpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB4ID0gcHQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHkgPSBwdC55O1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHRoaXMuX293bmVyID0gb3duZXI7XG4gICAgICAgIG93bmVyW2tleV0gPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcbiAgICAgICAgICAgIHggPSBmLm51bWJlcih0aGlzLl94KSxcbiAgICAgICAgICAgIHkgPSBmLm51bWJlcih0aGlzLl95KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgPyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cbiAgICAgICAgICAgICAgICA6IFt4LCB5XTtcbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0WTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG5cbiAgICBzZXRZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgICB0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgaXNaZXJvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy5feCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLl95KTtcbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuX293bmVyLnNldFNlbGVjdGVkKHNlbGVjdGVkLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuICAgIH1cbn0pO1xuXG52YXIgQ3VydmUgPSBCYXNlLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnQ3VydmUnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuICAgICAgICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoY291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGggPSBhcmcwO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudDEgPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KGFyZzApO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudChhcmcxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb2ludDEsIGhhbmRsZTEsIGhhbmRsZTIsIHBvaW50MjtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHBvaW50MSA9IGFyZzA7XG4gICAgICAgICAgICAgICAgaGFuZGxlMSA9IGFyZzE7XG4gICAgICAgICAgICAgICAgaGFuZGxlMiA9IGFyZzI7XG4gICAgICAgICAgICAgICAgcG9pbnQyID0gYXJnMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDgpIHtcbiAgICAgICAgICAgICAgICBwb2ludDEgPSBbYXJnMCwgYXJnMV07XG4gICAgICAgICAgICAgICAgcG9pbnQyID0gW2FyZzYsIGFyZzddO1xuICAgICAgICAgICAgICAgIGhhbmRsZTEgPSBbYXJnMiAtIGFyZzAsIGFyZzMgLSBhcmcxXTtcbiAgICAgICAgICAgICAgICBoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KHBvaW50MSwgbnVsbCwgaGFuZGxlMSk7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KHBvaW50MiwgaGFuZGxlMiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGdldFBvaW50MTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG4gICAgfSxcblxuICAgIHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcbiAgICB9LFxuXG4gICAgc2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG4gICAgfSxcblxuICAgIHNldEhhbmRsZTE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBnZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcbiAgICB9LFxuXG4gICAgc2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnbWVudDE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDE7XG4gICAgfSxcblxuICAgIGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQyO1xuICAgIH0sXG5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfSxcblxuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcbiAgICB9LFxuXG4gICAgZ2V0TmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcbiAgICAgICAgcmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1swXSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG4gICAgICAgIHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggLSAxXVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG4gICAgfSxcblxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgICAgICB0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICByZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG4gICAgICAgICAgICBwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5pc0xpbmVhcigpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuZ2V0RGlzdGFuY2UodGhpcy5fc2VnbWVudDEuX3BvaW50KVxuICAgICAgICAgICAgICAgIDogQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcbiAgICB9LFxuXG4gICAgZ2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG4gICAgfSxcblxuICAgIGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuICAgIH0sXG5cbiAgICBpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuICAgIH0sXG5cbiAgICBpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xpbmVhcigpICYmIE51bWVyaWNhbC5pc1plcm8oXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VnbWVudDEuX3BvaW50Ll95IC0gdGhpcy5fc2VnbWVudDIuX3BvaW50Ll95KTtcbiAgICB9LFxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgICAgcmV0dXJuIEN1cnZlLmdldEludGVyc2VjdGlvbnModGhpcy5nZXRWYWx1ZXMoKSwgY3VydmUuZ2V0VmFsdWVzKCksXG4gICAgICAgICAgICAgICAgdGhpcywgY3VydmUsIFtdKTtcbiAgICB9LFxuXG4gICAgX2dldFBhcmFtZXRlcjogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gaXNQYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICA/IG9mZnNldFxuICAgICAgICAgICAgICAgIDogb2Zmc2V0ICYmIG9mZnNldC5jdXJ2ZSA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICA/IG9mZnNldC5wYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgOiBvZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBpc1BhcmFtZXRlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDAuNSBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQsIDApO1xuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIsIGlnbm9yZUxpbmVhcikge1xuICAgICAgICB2YXIgcGFyYW1ldGVyID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpLFxuICAgICAgICAgICAgdG9sZXJhbmNlID0gMC4wMDAwMSxcbiAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgIGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UgJiYgcGFyYW1ldGVyIDwgMSAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciksXG4gICAgICAgICAgICAgICAgaXNMaW5lYXIgPSBpZ25vcmVMaW5lYXIgPyBmYWxzZSA6IHRoaXMuaXNMaW5lYXIoKSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gcGFydHNbMF0sXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBwYXJ0c1sxXTtcblxuICAgICAgICAgICAgaWYgKCFpc0xpbmVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFszXSAtIGxlZnRbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocmlnaHRbNF0gLSByaWdodFs2XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeCA9IGxlZnRbNl0sIHkgPSBsZWZ0WzddLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNMaW5lYXIgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNMaW5lYXIgJiYgbmV3IFBvaW50KHJpZ2h0WzJdIC0geCwgcmlnaHRbM10gLSB5KSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlZ21lbnQxLl9pbmRleCA+IDAgJiYgdGhpcy5fc2VnbWVudDIuX2luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdGguYWRkKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdGguaW5zZXJ0KHRoaXMuX3NlZ21lbnQyLl9pbmRleCwgc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXM7IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fc2VnbWVudDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIHNwbGl0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoXG4gICAgICAgICAgICA/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlcikpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2UoKSwgdGhpcy5fc2VnbWVudDEucmV2ZXJzZSgpKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGgpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuICAgICAgICAgICAgICAgIGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG4gICAgICAgICAgICByZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChoYW5kbGVPdXQueCwgaGFuZGxlT3V0LnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyKTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpKVxuICAgICAgICAgICAgcGFydHMucHVzaCgnaGFuZGxlMTogJyArIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQpO1xuICAgICAgICBpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuICAgICAgICBwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuICAgICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH0sXG5cbnN0YXRpY3M6IHtcbiAgICBnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG4gICAgICAgIHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcbiAgICAgICAgICAgIGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcbiAgICAgICAgICAgIGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuICAgICAgICAgICAgcDIgPSBzZWdtZW50Mi5fcG9pbnQsXG4gICAgICAgICAgICB2YWx1ZXMgPSBbXG4gICAgICAgICAgICAgICAgcDEuX3gsIHAxLl95LFxuICAgICAgICAgICAgICAgIHAxLl94ICsgaDEuX3gsIHAxLl95ICsgaDEuX3ksXG4gICAgICAgICAgICAgICAgcDIuX3ggKyBoMi5feCwgcDIuX3kgKyBoMi5feSxcbiAgICAgICAgICAgICAgICBwMi5feCwgcDIuX3lcbiAgICAgICAgICAgIF07XG4gICAgICAgIGlmIChtYXRyaXgpXG4gICAgICAgICAgICBtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHZhbHVlcywgdmFsdWVzLCA0KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHYsIHQsIHR5cGUpIHtcbiAgICAgICAgdmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG4gICAgICAgICAgICBjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuICAgICAgICAgICAgYzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcbiAgICAgICAgICAgIHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSAwLjAwMDAxLFxuICAgICAgICAgICAgeCwgeTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgIHZhciBpc1plcm8gPSB0IDwgdG9sZXJhbmNlO1xuICAgICAgICAgICAgeCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcbiAgICAgICAgICAgIHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY3ggPSAzICogKGMxeCAtIHAxeCksXG4gICAgICAgICAgICAgICAgYnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcbiAgICAgICAgICAgICAgICBheCA9IHAyeCAtIHAxeCAtIGN4IC0gYngsXG5cbiAgICAgICAgICAgICAgICBjeSA9IDMgKiAoYzF5IC0gcDF5KSxcbiAgICAgICAgICAgICAgICBieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuICAgICAgICAgICAgICAgIGF5ID0gcDJ5IC0gcDF5IC0gY3kgLSBieTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgeCA9ICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQgKyBwMXg7XG4gICAgICAgICAgICAgICAgeSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0IDwgdG9sZXJhbmNlICYmIGMxeCA9PT0gcDF4ICYmIGMxeSA9PT0gcDF5XG4gICAgICAgICAgICAgICAgICAgICAgICB8fCB0ID4gMSAtIHRvbGVyYW5jZSAmJiBjMnggPT09IHAyeCAmJiBjMnkgPT09IHAyeSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4IC0gYzF4O1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5IC0gYzF5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gY3g7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjeTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQgPiAxIC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSAzICogKHAyeCAtIGMyeCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAzICogKHAyeSAtIGMyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICgzICogYXkgKiB0ICsgMiAqIGJ5KSAqIHQgKyBjeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gNiAqIGF5ICogdCArIDIgKiBieTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh4ICogeTIgLSB5ICogeDIpIC8gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIHN1YmRpdmlkZTogZnVuY3Rpb24odiwgdCkge1xuICAgICAgICB2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcbiAgICAgICAgICAgIGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG4gICAgICAgICAgICBjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuICAgICAgICAgICAgcDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcbiAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHQgPSAwLjU7XG4gICAgICAgIHZhciB1ID0gMSAtIHQsXG4gICAgICAgICAgICBwM3ggPSB1ICogcDF4ICsgdCAqIGMxeCwgcDN5ID0gdSAqIHAxeSArIHQgKiBjMXksXG4gICAgICAgICAgICBwNHggPSB1ICogYzF4ICsgdCAqIGMyeCwgcDR5ID0gdSAqIGMxeSArIHQgKiBjMnksXG4gICAgICAgICAgICBwNXggPSB1ICogYzJ4ICsgdCAqIHAyeCwgcDV5ID0gdSAqIGMyeSArIHQgKiBwMnksXG4gICAgICAgICAgICBwNnggPSB1ICogcDN4ICsgdCAqIHA0eCwgcDZ5ID0gdSAqIHAzeSArIHQgKiBwNHksXG4gICAgICAgICAgICBwN3ggPSB1ICogcDR4ICsgdCAqIHA1eCwgcDd5ID0gdSAqIHA0eSArIHQgKiBwNXksXG4gICAgICAgICAgICBwOHggPSB1ICogcDZ4ICsgdCAqIHA3eCwgcDh5ID0gdSAqIHA2eSArIHQgKiBwN3k7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbcDF4LCBwMXksIHAzeCwgcDN5LCBwNngsIHA2eSwgcDh4LCBwOHldLCBcbiAgICAgICAgICAgIFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV0gXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHAxID0gdltjb29yZF0sXG4gICAgICAgICAgICBjMSA9IHZbY29vcmQgKyAyXSxcbiAgICAgICAgICAgIGMyID0gdltjb29yZCArIDRdLFxuICAgICAgICAgICAgcDIgPSB2W2Nvb3JkICsgNl0sXG4gICAgICAgICAgICBjID0gMyAqIChjMSAtIHAxKSxcbiAgICAgICAgICAgIGIgPSAzICogKGMyIC0gYzEpIC0gYyxcbiAgICAgICAgICAgIGEgPSBwMiAtIHAxIC0gYyAtIGI7XG4gICAgICAgIHJldHVybiBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCBwMSAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcbiAgICB9LFxuXG4gICAgZ2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHgsIHkpIHtcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDAuMDAwMDE7XG4gICAgICAgIGlmIChNYXRoLmFicyh2WzBdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModlsxXSAtIHkpIDwgdG9sZXJhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmIChNYXRoLmFicyh2WzZdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModls3XSAtIHkpIDwgdG9sZXJhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHZhciB0eHMgPSBbXSxcbiAgICAgICAgICAgIHR5cyA9IFtdLFxuICAgICAgICAgICAgc3ggPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIDAsIHgsIHR4cywgMCwgMSksXG4gICAgICAgICAgICBzeSA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMSwgeSwgdHlzLCAwLCAxKSxcbiAgICAgICAgICAgIHR4LCB0eTtcbiAgICAgICAgZm9yICh2YXIgY3ggPSAwOyAgc3ggPT0gLTEgfHwgY3ggPCBzeDspIHtcbiAgICAgICAgICAgIGlmIChzeCA9PSAtMSB8fCAodHggPSB0eHNbY3grK10pID49IDAgJiYgdHggPD0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5ID0gMDsgc3kgPT0gLTEgfHwgY3kgPCBzeTspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5ID09IC0xIHx8ICh0eSA9IHR5c1tjeSsrXSkgPj0gMCAmJiB0eSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ggPT0gLTEpIHR4ID0gdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzeSA9PSAtMSkgdHkgPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0eCAtIHR5KSA8IHRvbGVyYW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHR4ICsgdHkpICogMC41O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07IFxuICAgICAgICBpZiAodG8gPCAxKVxuICAgICAgICAgICAgdiA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdOyBcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSxcblxuICAgIGlzTGluZWFyOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuICAgICAgICByZXR1cm4gaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG4gICAgICAgICAgICAgICAgJiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pO1xuICAgIH0sXG5cbiAgICBpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIHRvbGVyYW5jZSkge1xuICAgICAgICB2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcbiAgICAgICAgICAgIGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG4gICAgICAgICAgICBjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuICAgICAgICAgICAgcDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcbiAgICAgICAgICAgIHV4ID0gMyAqIGMxeCAtIDIgKiBwMXggLSBwMngsXG4gICAgICAgICAgICB1eSA9IDMgKiBjMXkgLSAyICogcDF5IC0gcDJ5LFxuICAgICAgICAgICAgdnggPSAzICogYzJ4IC0gMiAqIHAyeCAtIHAxeCxcbiAgICAgICAgICAgIHZ5ID0gMyAqIGMyeSAtIDIgKiBwMnkgLSBwMXk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG4gICAgICAgICAgICAgICAgPCAxMCAqIHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcbiAgICB9LFxuXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcbiAgICAgICAgICAgIGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG4gICAgICAgICAgICBjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuICAgICAgICAgICAgcDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcbiAgICAgICAgcmV0dXJuICggIDMuMCAqIGMxeSAqIHAxeCAtIDEuNSAqIGMxeSAqIGMyeFxuICAgICAgICAgICAgICAgIC0gMS41ICogYzF5ICogcDJ4IC0gMy4wICogcDF5ICogYzF4XG4gICAgICAgICAgICAgICAgLSAxLjUgKiBwMXkgKiBjMnggLSAwLjUgKiBwMXkgKiBwMnhcbiAgICAgICAgICAgICAgICArIDEuNSAqIGMyeSAqIHAxeCArIDEuNSAqIGMyeSAqIGMxeFxuICAgICAgICAgICAgICAgIC0gMy4wICogYzJ5ICogcDJ4ICsgMC41ICogcDJ5ICogcDF4XG4gICAgICAgICAgICAgICAgKyAxLjUgKiBwMnkgKiBjMXggKyAzLjAgKiBwMnkgKiBjMngpIC8gMTA7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgbWluID0gdi5zbGljZSgwLCAyKSwgXG4gICAgICAgICAgICBtYXggPSBtaW4uc2xpY2UoKSwgXG4gICAgICAgICAgICByb290cyA9IFswLCAwXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspXG4gICAgICAgICAgICBDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sXG4gICAgICAgICAgICAgICAgICAgIGksIDAsIG1pbiwgbWF4LCByb290cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG4gICAgfSxcblxuICAgIF9hZGRCb3VuZHM6IGZ1bmN0aW9uKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSwgcGFkZGluZykge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB2YWx1ZSAtIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG4gICAgICAgICAgICBpZiAobGVmdCA8IG1pbltjb29yZF0pXG4gICAgICAgICAgICAgICAgbWluW2Nvb3JkXSA9IGxlZnQ7XG4gICAgICAgICAgICBpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuICAgICAgICAgICAgICAgIG1heFtjb29yZF0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuICAgICAgICAgICAgYiA9IDIgKiAodjAgKyB2MikgLSA0ICogdjEsXG4gICAgICAgICAgICBjID0gdjEgLSB2MCxcbiAgICAgICAgICAgIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcbiAgICAgICAgICAgIHRNaW4gPSAwLjAwMDAxLFxuICAgICAgICAgICAgdE1heCA9IDEgLSB0TWluO1xuICAgICAgICBhZGQodjMsIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gcm9vdHNbaV0sXG4gICAgICAgICAgICAgICAgdSA9IDEgLSB0O1xuICAgICAgICAgICAgaWYgKHRNaW4gPCB0ICYmIHQgPCB0TWF4KVxuICAgICAgICAgICAgICAgIGFkZCh1ICogdSAqIHUgKiB2MFxuICAgICAgICAgICAgICAgICAgICArIDMgKiB1ICogdSAqIHQgKiB2MVxuICAgICAgICAgICAgICAgICAgICArIDMgKiB1ICogdCAqIHQgKiB2MlxuICAgICAgICAgICAgICAgICAgICArIHQgKiB0ICogdCAqIHYzLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn19LCBCYXNlLmVhY2goWydnZXRCb3VuZHMnLCAnZ2V0U3Ryb2tlQm91bmRzJywgJ2dldEhhbmRsZUJvdW5kcycsICdnZXRSb3VnaEJvdW5kcyddLFxuICAgIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZHMpXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzID0ge307XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgICAgICBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFt0aGlzLl9zZWdtZW50MSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQyXSwgZmFsc2UsIHRoaXMuX3BhdGguZ2V0U3R5bGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzLmNsb25lKCk7XG4gICAgICAgIH07XG4gICAgfSxcbntcblxufSksIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuICAgIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICByZXR1cm4gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBpc1BhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICA/IG9mZnNldCA6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSwgaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5nZXRWYWx1ZXMoKSwgcGFyYW1ldGVyLCBpbmRleCk7XG4gICAgICAgIH07XG4gICAgfSxcbntcbiAgICBiZWFuczogZmFsc2UsXG5cbiAgICBnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuICAgICAgICByZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyQXQodGhpcy5nZXRWYWx1ZXMoKSwgb2Zmc2V0LCBzdGFydCk7XG4gICAgfSxcblxuICAgIGdldFBhcmFtZXRlck9mOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5nZXRWYWx1ZXMoKSwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKCFpc1BhcmFtZXRlcilcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA+PSAwICYmIG9mZnNldCA8PSAxICYmIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIG9mZnNldCk7XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0KHRoaXMuZ2V0UGFyYW1ldGVyT2YoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcbiAgICAgICAgICAgICAgICB0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuICAgICAgICAgICAgY291bnQgPSAxMDAsXG4gICAgICAgICAgICBtaW5EaXN0ID0gSW5maW5pdHksXG4gICAgICAgICAgICBtaW5UID0gMDtcblxuICAgICAgICBmdW5jdGlvbiByZWZpbmUodCkge1xuICAgICAgICAgICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgQ3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAwKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlZmluZShpIC8gY291bnQpO1xuXG4gICAgICAgIHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuICAgICAgICB3aGlsZSAoc3RlcCA+IDAuMDAwMDEpIHtcbiAgICAgICAgICAgIGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSlcbiAgICAgICAgICAgICAgICBzdGVwIC89IDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB0ID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBtaW5ULCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIG1pblQsIHB0LCBudWxsLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAgIHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG4gICAgfSxcblxuICAgIGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG4gICAgfVxuXG59KSxcbm5ldyBmdW5jdGlvbigpIHsgXG5cbiAgICBmdW5jdGlvbiBnZXRMZW5ndGhJbnRlZ3JhbmQodikge1xuICAgICAgICB2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcbiAgICAgICAgICAgIGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG4gICAgICAgICAgICBjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuICAgICAgICAgICAgcDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblxuICAgICAgICAgICAgYXggPSA5ICogKGMxeCAtIGMyeCkgKyAzICogKHAyeCAtIHAxeCksXG4gICAgICAgICAgICBieCA9IDYgKiAocDF4ICsgYzJ4KSAtIDEyICogYzF4LFxuICAgICAgICAgICAgY3ggPSAzICogKGMxeCAtIHAxeCksXG5cbiAgICAgICAgICAgIGF5ID0gOSAqIChjMXkgLSBjMnkpICsgMyAqIChwMnkgLSBwMXkpLFxuICAgICAgICAgICAgYnkgPSA2ICogKHAxeSArIGMyeSkgLSAxMiAqIGMxeSxcbiAgICAgICAgICAgIGN5ID0gMyAqIChjMXkgLSBwMXkpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuICAgICAgICAgICAgICAgIGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGlvbnMoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0aWNzOiB0cnVlLFxuXG4gICAgICAgIGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBhID0gMDtcbiAgICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYiA9IDE7XG4gICAgICAgICAgICB2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgJiYgaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG4gICAgICAgICAgICAgICAgICAgICYmIGlzWmVybyh2WzZdIC0gdls0XSkgJiYgaXNaZXJvKHZbN10gLSB2WzVdKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IHZbNl0gLSB2WzBdLCBcbiAgICAgICAgICAgICAgICAgICAgZHkgPSB2WzddIC0gdlsxXTsgXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodik7XG4gICAgICAgICAgICByZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYiwgZ2V0SXRlcmF0aW9ucyhhLCBiKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKHYsIG9mZnNldCwgc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0IDwgMCA/IDEgOiAwXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIHZhciBmb3J3YXJkID0gb2Zmc2V0ID4gMCxcbiAgICAgICAgICAgICAgICBhID0gZm9yd2FyZCA/IHN0YXJ0IDogMCxcbiAgICAgICAgICAgICAgICBiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcbiAgICAgICAgICAgICAgICByYW5nZUxlbmd0aCA9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRJdGVyYXRpb25zKGEsIGIpKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID49IHJhbmdlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3J3YXJkID8gYiA6IGE7XG4gICAgICAgICAgICB2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICAgICAgZnVuY3Rpb24gZih0KSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIHN0YXJ0LCB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SXRlcmF0aW9ucyhzdGFydCwgdCkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMTYsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDEpO1xuICAgICAgICB9XG4gICAgfTtcbn0sIG5ldyBmdW5jdGlvbigpIHsgXG4gICAgZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG4gICAgICAgICAgICBwb2ludDIpIHtcbiAgICAgICAgdmFyIGxvYyA9IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlMSwgdDEsIHBvaW50MSwgY3VydmUyLCB0MiwgcG9pbnQyKTtcbiAgICAgICAgaWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jKSlcbiAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKGxvYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcbiAgICAgICAgICAgIHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcbiAgICAgICAgaWYgKHJlY3Vyc2lvbiA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcTB4ID0gdjJbMF0sIHEweSA9IHYyWzFdLCBxM3ggPSB2Mls2XSwgcTN5ID0gdjJbN10sXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSAwLjAwMDAxLFxuICAgICAgICAgICAgaHVsbEVwc2lsb24gPSAxZS05LFxuICAgICAgICAgICAgZ2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuICAgICAgICAgICAgZDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzJdLCB2MlszXSkgfHwgMCxcbiAgICAgICAgICAgIGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pIHx8IDAsXG4gICAgICAgICAgICBmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG4gICAgICAgICAgICBkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcbiAgICAgICAgICAgIGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuICAgICAgICAgICAgZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuICAgICAgICAgICAgZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuICAgICAgICAgICAgZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuICAgICAgICAgICAgZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuICAgICAgICAgICAgdE1pbk5ldywgdE1heE5ldywgdERpZmY7XG4gICAgICAgIGlmIChxMHggPT09IHEzeCAmJiB1TWF4IC0gdU1pbiA8PSBodWxsRXBzaWxvbiAmJiByZWN1cnNpb24gPiAzKSB7XG4gICAgICAgICAgICB0TWluTmV3ID0gKHRNYXggKyB0TWluKSAvIDI7XG4gICAgICAgICAgICB0TWF4TmV3ID0gdE1pbk5ldztcbiAgICAgICAgICAgIHREaWZmID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBodWxsID0gZ2V0Q29udmV4SHVsbChkcDAsIGRwMSwgZHAyLCBkcDMpLFxuICAgICAgICAgICAgICAgIHRvcCA9IGh1bGxbMF0sXG4gICAgICAgICAgICAgICAgYm90dG9tID0gaHVsbFsxXSxcbiAgICAgICAgICAgICAgICB0TWluQ2xpcCwgdE1heENsaXA7XG4gICAgICAgICAgICB0TWluQ2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcbiAgICAgICAgICAgIHRvcC5yZXZlcnNlKCk7XG4gICAgICAgICAgICBib3R0b20ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgdE1heENsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCk7XG4gICAgICAgICAgICBpZiAodE1pbkNsaXAgPT0gbnVsbCB8fCB0TWF4Q2xpcCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcbiAgICAgICAgICAgIHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcDtcbiAgICAgICAgICAgIHRNaW5OZXcgPSB0TWF4ICogdE1pbkNsaXAgKyB0TWluICogKDEgLSB0TWluQ2xpcCk7XG4gICAgICAgICAgICB0TWF4TmV3ID0gdE1heCAqIHRNYXhDbGlwICsgdE1pbiAqICgxIC0gdE1heENsaXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRURGlmZiA+IDAuOCAmJiB0RGlmZiA+IDAuOCkge1xuICAgICAgICAgICAgaWYgKHRNYXhOZXcgLSB0TWluTmV3ID4gdU1heCAtIHVNaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjEsIDAuNSksXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDI7XG4gICAgICAgICAgICAgICAgYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgICAgICAgICB2MiwgcGFydHNbMF0sIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuICAgICAgICAgICAgICAgIGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdjIsIHBhcnRzWzFdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuICAgICAgICAgICAgICAgICAgICB1TWluLCB1TWF4LCB0LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcbiAgICAgICAgICAgICAgICAgICAgdCA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcbiAgICAgICAgICAgICAgICBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLCB2MSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgdU1pbiwgdCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG4gICAgICAgICAgICAgICAgYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgICAgICAgICBwYXJ0c1sxXSwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICB2YXIgdDEgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDIsXG4gICAgICAgICAgICAgICAgdDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICAgIGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcbiAgICAgICAgdmFyIHAwID0gWyAwLCBkcTAgXSxcbiAgICAgICAgICAgIHAxID0gWyAxIC8gMywgZHExIF0sXG4gICAgICAgICAgICBwMiA9IFsgMiAvIDMsIGRxMiBdLFxuICAgICAgICAgICAgcDMgPSBbIDEsIGRxMyBdLFxuICAgICAgICAgICAgZ2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuICAgICAgICAgICAgZGlzdDEgPSBnZXRTaWduZWREaXN0YW5jZSgwLCBkcTAsIDEsIGRxMywgMSAvIDMsIGRxMSksXG4gICAgICAgICAgICBkaXN0MiA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAyIC8gMywgZHEyKSxcbiAgICAgICAgICAgIGZsaXAgPSBmYWxzZSxcbiAgICAgICAgICAgIGh1bGw7XG4gICAgICAgIGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuICAgICAgICAgICAgaHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG4gICAgICAgICAgICBmbGlwID0gZGlzdDEgPCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBtYXgsIGNyb3NzID0gMCxcbiAgICAgICAgICAgICAgICBkaXN0WmVybyA9IGRpc3QxID09PSAwIHx8IGRpc3QyID09PSAwO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3QxKSA+IE1hdGguYWJzKGRpc3QyKSkge1xuICAgICAgICAgICAgICAgIHBtYXggPSBwMTtcbiAgICAgICAgICAgICAgICBjcm9zcyA9IChkcTMgLSBkcTIgLSAoZHEzIC0gZHEwKSAvIDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAqICgyICogKGRxMyAtIGRxMikgLSBkcTMgKyBkcTEpIC8gMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG1heCA9IHAyO1xuICAgICAgICAgICAgICAgIGNyb3NzID0gKGRxMSAtIGRxMCArIChkcTAgLSBkcTMpIC8gMylcbiAgICAgICAgICAgICAgICAgICAgICAgICogKC0yICogKGRxMCAtIGRxMSkgKyBkcTAgLSBkcTIpIC8gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh1bGwgPSBjcm9zcyA8IDAgfHwgZGlzdFplcm9cbiAgICAgICAgICAgICAgICAgICAgPyBbW3AwLCBwbWF4LCBwM10sIFtwMCwgcDNdXVxuICAgICAgICAgICAgICAgICAgICA6IFtbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG4gICAgICAgICAgICBmbGlwID0gZGlzdDEgPyBkaXN0MSA8IDAgOiBkaXN0MiA8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsaXAgPyBodWxsLnJldmVyc2UoKSA6IGh1bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuICAgICAgICB2YXIgdFByb3h5LFxuICAgICAgICAgICAgdFZhbCA9IG51bGwsXG4gICAgICAgICAgICBweCwgcHksXG4gICAgICAgICAgICBxeCwgcXk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaHVsbEJvdHRvbS5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBweSA9IGh1bGxCb3R0b21baV1bMV07XG4gICAgICAgICAgICBxeSA9IGh1bGxCb3R0b21baSArIDFdWzFdO1xuICAgICAgICAgICAgaWYgKHB5IDwgcXkpIHtcbiAgICAgICAgICAgICAgICB0UHJveHkgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxeSA8PSBkTWF4KSB7XG4gICAgICAgICAgICAgICAgcHggPSBodWxsQm90dG9tW2ldWzBdO1xuICAgICAgICAgICAgICAgIHF4ID0gaHVsbEJvdHRvbVtpICsgMV1bMF07XG4gICAgICAgICAgICAgICAgdFByb3h5ID0gcHggKyAoZE1heCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHVsbFRvcFswXVsxXSA8PSBkTWF4KVxuICAgICAgICAgICAgdFByb3h5ID0gaHVsbFRvcFswXVswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBodWxsVG9wLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB5ID0gaHVsbFRvcFtpXVsxXTtcbiAgICAgICAgICAgIHF5ID0gaHVsbFRvcFtpICsgMV1bMV07XG4gICAgICAgICAgICBpZiAocHkgPj0gZE1pbikge1xuICAgICAgICAgICAgICAgIHRWYWwgPSB0UHJveHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHB5ID4gcXkpIHtcbiAgICAgICAgICAgICAgICB0VmFsID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXkgPj0gZE1pbikge1xuICAgICAgICAgICAgICAgIHB4ID0gaHVsbFRvcFtpXVswXTtcbiAgICAgICAgICAgICAgICBxeCA9IGh1bGxUb3BbaSArIDFdWzBdO1xuICAgICAgICAgICAgICAgIHRWYWwgPSBweCArIChkTWluICAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdFZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGUpIHtcbiAgICAgICAgdmFyIGZsaXAgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG4gICAgICAgICAgICB2YyA9IGZsaXAgPyB2MiA6IHYxLFxuICAgICAgICAgICAgdmwgPSBmbGlwID8gdjEgOiB2MixcbiAgICAgICAgICAgIGx4MSA9IHZsWzBdLCBseTEgPSB2bFsxXSxcbiAgICAgICAgICAgIGx4MiA9IHZsWzZdLCBseTIgPSB2bFs3XSxcbiAgICAgICAgICAgIGxkeCA9IGx4MiAtIGx4MSxcbiAgICAgICAgICAgIGxkeSA9IGx5MiAtIGx5MSxcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtbGR5LCBsZHgpLFxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgcmx4MiA9IGxkeCAqIGNvcyAtIGxkeSAqIHNpbixcbiAgICAgICAgICAgIHJ2bCA9IFswLCAwLCAwLCAwLCBybHgyLCAwLCBybHgyLCAwXSxcbiAgICAgICAgICAgIHJ2YyA9IFtdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZjW2ldIC0gbHgxLFxuICAgICAgICAgICAgICAgIHkgPSB2Y1tpICsgMV0gLSBseTE7XG4gICAgICAgICAgICBydmMucHVzaChcbiAgICAgICAgICAgICAgICB4ICogY29zIC0geSAqIHNpbixcbiAgICAgICAgICAgICAgICB5ICogY29zICsgeCAqIHNpbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3RzID0gW10sXG4gICAgICAgICAgICBjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWMocnZjLCAxLCAwLCByb290cywgMCwgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRjID0gcm9vdHNbaV0sXG4gICAgICAgICAgICAgICAgeCA9IEN1cnZlLmV2YWx1YXRlKHJ2YywgdGMsIDApLng7XG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPD0gcmx4Mikge1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHJ2bCwgeCwgMCksXG4gICAgICAgICAgICAgICAgICAgIHQxID0gZmxpcCA/IHRsIDogdGMsXG4gICAgICAgICAgICAgICAgICAgIHQyID0gZmxpcCA/IHRjIDogdGw7XG4gICAgICAgICAgICAgICAgYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gTGluZS5pbnRlcnNlY3QoXG4gICAgICAgICAgICAgICAgdjFbMF0sIHYxWzFdLCB2MVs2XSwgdjFbN10sXG4gICAgICAgICAgICAgICAgdjJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgICAgICAgIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgY3VydmUxLCBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MSwgeCwgeSksIHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBjdXJ2ZTIsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYyLCB4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhdGljczoge1xuICAgICAgICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbih2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lYXIxID0gQ3VydmUuaXNMaW5lYXIodjEpLFxuICAgICAgICAgICAgICAgIGxpbmVhcjIgPSBDdXJ2ZS5pc0xpbmVhcih2Mik7XG4gICAgICAgICAgICAobGluZWFyMSAmJiBsaW5lYXIyXG4gICAgICAgICAgICAgICAgPyBhZGRMaW5lSW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBsaW5lYXIxIHx8IGxpbmVhcjJcbiAgICAgICAgICAgICAgICAgICAgPyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsIDEsIDAsIGZhbHNlLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgICAgIH1cbiAgICB9fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDdXJ2ZUxvY2F0aW9uJyxcbiAgICBiZWFuczogdHJ1ZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHBhcmFtZXRlciwgcG9pbnQsIF9jdXJ2ZTIsXG4gICAgICAgICAgICBfcGFyYW1ldGVyMiwgX3BvaW50MiwgX2Rpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2lkID0gQ3VydmVMb2NhdGlvbi5faWQgPSAoQ3VydmVMb2NhdGlvbi5faWQgfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLl9zZWdtZW50MSA9IGN1cnZlLl9zZWdtZW50MTtcbiAgICAgICAgdGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5fY3VydmUyID0gX2N1cnZlMjtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyMiA9IF9wYXJhbWV0ZXIyO1xuICAgICAgICB0aGlzLl9wb2ludDIgPSBfcG9pbnQyO1xuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcbiAgICB9LFxuXG4gICAgZ2V0U2VnbWVudDogZnVuY3Rpb24oX3ByZWZlckZpcnN0KSB7XG4gICAgICAgIGlmICghdGhpcy5fc2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVyID09PSAwIHx8IF9wcmVmZXJGaXJzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICAgICAgPCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHBhcmFtZXRlciwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3VydmUuX3NlZ21lbnQxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnZlLl9zZWdtZW50MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VnbWVudDtcbiAgICB9LFxuXG4gICAgZ2V0Q3VydmU6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2N1cnZlIHx8IF91bmNhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fY3VydmUgPSB0aGlzLl9zZWdtZW50MS5nZXRDdXJ2ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlID0gdGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKS5nZXRDdXJ2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZTtcbiAgICB9LFxuXG4gICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMuX2ludGVyc2VjdGlvbjtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24gJiYgdGhpcy5fY3VydmUyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLl9wYXJhbWV0ZXIyO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uID0gbmV3IEN1cnZlTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnZlMiwgcGFyYW0sIHRoaXMuX3BvaW50MiB8fCB0aGlzLl9wb2ludCwgdGhpcyk7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24uX2ludGVyc2VjdGlvbiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG4gICAgfSxcblxuICAgIGdldE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIHJldHVybiBwYXRoID8gcGF0aC5fZ2V0T2Zmc2V0KHRoaXMpIDogdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuICAgIH0sXG5cbiAgICBnZXRDdXJ2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXIgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcik7XG4gICAgfSxcblxuICAgIGdldFBhcmFtZXRlcjogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG4gICAgICAgIGlmICgodGhpcy5fcGFyYW1ldGVyID09IG51bGwgfHwgX3VuY2FjaGVkKSAmJiB0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZShfdW5jYWNoZWQpO1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1ldGVyID0gY3VydmUgJiYgY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXI7XG4gICAgfSxcblxuICAgIGdldFBvaW50OiBmdW5jdGlvbihfdW5jYWNoZWQpIHtcbiAgICAgICAgaWYgKCghdGhpcy5fcG9pbnQgfHwgX3VuY2FjaGVkKSAmJiB0aGlzLl9wYXJhbWV0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZShfdW5jYWNoZWQpO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQb2ludEF0KHRoaXMuX3BhcmFtZXRlciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50O1xuICAgIH0sXG5cbiAgICBnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZTtcbiAgICB9LFxuXG4gICAgZGl2aWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLmRpdmlkZSh0aGlzLmdldFBhcmFtZXRlcih0cnVlKSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHNwbGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnZlICYmIGN1cnZlLnNwbGl0KHRoaXMuZ2V0UGFyYW1ldGVyKHRydWUpLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihsb2MpIHtcbiAgICAgICAgdmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG4gICAgICAgIHJldHVybiB0aGlzID09PSBsb2NcbiAgICAgICAgICAgICAgICB8fCBsb2NcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5fY3VydmUgPT09IGxvYy5fY3VydmVcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5fY3VydmUyID09PSBsb2MuX2N1cnZlMlxuICAgICAgICAgICAgICAgICAgICAmJiBpc1plcm8odGhpcy5fcGFyYW1ldGVyIC0gbG9jLl9wYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgICAgICYmIGlzWmVybyh0aGlzLl9wYXJhbWV0ZXIyIC0gbG9jLl9wYXJhbWV0ZXIyKVxuICAgICAgICAgICAgICAgIHx8IGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgcG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG4gICAgICAgICAgICBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuICAgICAgICBpZiAocG9pbnQpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdwb2ludDogJyArIHBvaW50KTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuICAgICAgICB2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlciAhPSBudWxsKVxuICAgICAgICAgICAgcGFydHMucHVzaCgncGFyYW1ldGVyOiAnICsgZi5udW1iZXIocGFyYW1ldGVyKSk7XG4gICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKVxuICAgICAgICAgICAgcGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuICAgICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgIH1cbn0sIEJhc2UuZWFjaChbJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGdldCA9IG5hbWUgKyAnQXQnO1xuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG4gICAgICAgICAgICBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0ocGFyYW1ldGVyLCB0cnVlKTtcbiAgICB9O1xufSwge30pKTtcblxudmFyIFBhdGhJdGVtID0gSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ1BhdGhJdGVtJyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuICAgIH0sXG5cbiAgICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwYXRoLCBfbWF0cml4LCBfZXhwYW5kKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBwYXRoKVxuICAgICAgICAgICAgcGF0aCA9IG51bGw7XG4gICAgICAgIHZhciBsb2NhdGlvbnMgPSBbXSxcbiAgICAgICAgICAgIGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgY3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcbiAgICAgICAgICAgIG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuICAgICAgICAgICAgbWF0cml4MiA9IHBhdGggPyAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKVxuICAgICAgICAgICAgICAgIDogbWF0cml4MSxcbiAgICAgICAgICAgIGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcbiAgICAgICAgICAgIGxlbmd0aDIgPSBwYXRoID8gY3VydmVzMi5sZW5ndGggOiBsZW5ndGgxLFxuICAgICAgICAgICAgdmFsdWVzMiA9IFtdLFxuICAgICAgICAgICAgTUlOID0gMWUtMTEsXG4gICAgICAgICAgICBNQVggPSAxIC0gMWUtMTE7XG4gICAgICAgIGlmIChwYXRoICYmICF0aGlzLmdldEJvdW5kcyhtYXRyaXgxKS50b3VjaGVzKHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG4gICAgICAgICAgICB2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMxID0gcGF0aCA/IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSkgOiB2YWx1ZXMyW2ldO1xuICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZzEgPSBjdXJ2ZTEuZ2V0U2VnbWVudDEoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VnMiA9IGN1cnZlMS5nZXRTZWdtZW50MigpLFxuICAgICAgICAgICAgICAgICAgICBoMSA9IHNlZzEuX2hhbmRsZU91dCxcbiAgICAgICAgICAgICAgICAgICAgaDIgPSBzZWcyLl9oYW5kbGVJbjtcbiAgICAgICAgICAgICAgICBpZiAobmV3IExpbmUoc2VnMS5fcG9pbnQuc3VidHJhY3QoaDEpLCBoMS5tdWx0aXBseSgyKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnNlY3QobmV3IExpbmUoc2VnMi5fcG9pbnQuc3VidHJhY3QoaDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaDIubXVsdGlwbHkoMiksIHRydWUpLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHZhbHVlczEpO1xuICAgICAgICAgICAgICAgICAgICBDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0sIHBhcnRzWzFdLCBjdXJ2ZTEsIGN1cnZlMSwgbG9jYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24obG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvYy5fcGFyYW1ldGVyIDw9IE1BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MuX3BhcmFtZXRlciAvPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgIXBhdGggJiYgKGogPT09IGkgKyAxIHx8IGogPT09IGxlbmd0aDIgLSAxICYmIGkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBmdW5jdGlvbihsb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ID49IE1JTiAmJiB0IDw9IE1BWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0ID0gbG9jYXRpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gbG9jLl9jdXJ2ZS5nZXROZXh0KCksXG4gICAgICAgICAgICAgICAgbmV4dDIgPSBsb2MuX2N1cnZlMi5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBsb2MuX3BhcmFtZXRlciA+PSBNQVgpIHtcbiAgICAgICAgICAgICAgICBsb2MuX3BhcmFtZXRlciA9IDA7XG4gICAgICAgICAgICAgICAgbG9jLl9jdXJ2ZSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dDIgJiYgbG9jLl9wYXJhbWV0ZXIyID49IE1BWCkge1xuICAgICAgICAgICAgICAgIGxvYy5fcGFyYW1ldGVyMiA9IDA7XG4gICAgICAgICAgICAgICAgbG9jLl9jdXJ2ZTIgPSBuZXh0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmUobG9jMSwgbG9jMikge1xuICAgICAgICAgICAgdmFyIHBhdGgxID0gbG9jMS5nZXRQYXRoKCksXG4gICAgICAgICAgICAgICAgcGF0aDIgPSBsb2MyLmdldFBhdGgoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoMSA9PT0gcGF0aDJcbiAgICAgICAgICAgICAgICAgICAgPyAobG9jMS5nZXRJbmRleCgpICsgbG9jMS5nZXRQYXJhbWV0ZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFBhcmFtZXRlcigpKVxuICAgICAgICAgICAgICAgICAgICA6IHBhdGgxLl9pZCAtIHBhdGgyLl9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0ID4gMCkge1xuICAgICAgICAgICAgbG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdDsgaSA+PSAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25zW2ldLmVxdWFscyhsb2NhdGlvbnNbaSA9PT0gMCA/IGxhc3QgOiBpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9leHBhbmQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICBsb2NhdGlvbnMucHVzaChsb2NhdGlvbnNbaV0uZ2V0SW50ZXJzZWN0aW9uKCkpO1xuICAgICAgICAgICAgbG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9ucztcbiAgICB9LFxuXG4gICAgX2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICB2YXIgcGFydHMgPSBkYXRhLm1hdGNoKC9bbWxodmNzcXRhel1bXm1saHZjc3F0YXpdKi9pZyksXG4gICAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgICByZWxhdGl2ZSA9IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlvdXMsXG4gICAgICAgICAgICBjb250cm9sLFxuICAgICAgICAgICAgY3VycmVudCA9IG5ldyBQb2ludCgpLFxuICAgICAgICAgICAgc3RhcnQgPSBuZXcgUG9pbnQoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSlcbiAgICAgICAgICAgICAgICB2YWwgKz0gY3VycmVudFtjb29yZF07XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgZ2V0Q29vcmQoaW5kZXgsICd4JyksXG4gICAgICAgICAgICAgICAgZ2V0Q29vcmQoaW5kZXggKyAxLCAneScpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBwYXJ0WzBdLFxuICAgICAgICAgICAgICAgIGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgICByZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyhjdXJyZW50ID0gc3RhcnQpO1xuICAgICAgICAgICAgc3dpdGNoIChsb3dlcikge1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICB2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmUgJiYgcHJldmlvdXMgJiYgcHJldmlvdXMgIT09ICd6JylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMilcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgIHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lVG8oY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1YmljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRQb2ludChqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gZ2V0UG9pbnQoaiArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgL1tjc10vLnRlc3QocHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gZ2V0UG9pbnQoaiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbG93ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGdldFBvaW50KGopLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSAoL1txdF0vLnRlc3QocHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VycmVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGdldFBvaW50KGopKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBsb3dlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgU2l6ZSgrY29vcmRzWzBdLCArY29vcmRzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArY29vcmRzWzJdLCArY29vcmRzWzRdLCArY29vcmRzWzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCh0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gbG93ZXI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuICAgIH0sXG5cbiAgICBfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuICAgICAgICByZXR1cm4gISEodGhpcy5nZXRXaW5kaW5nUnVsZSgpID09PSAnZXZlbm9kZCcgPyB3aW5kaW5nICYgMSA6IHdpbmRpbmcpO1xuICAgIH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXRoJyxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICAgIHNlZ21lbnRzOiBbXSxcbiAgICAgICAgY2xvc2VkOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG4gICAgICAgICAgICA/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgPyBhcmdcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50c1xuICAgICAgICAgICAgOiBhcmcgJiYgKGFyZy5zaXplID09PSB1bmRlZmluZWQgJiYgKGFyZy54ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgICAgID8gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7IFxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgaWYgKCFzZWdtZW50cyAmJiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcbiAgICAgICAgICAgICAgICBhcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUoIXNlZ21lbnRzICYmIGFyZyk7XG4gICAgfSxcblxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG4gICAgICAgIGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuICAgICAgICBjb3B5Ll9jbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG4gICAgICAgIGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvcHkuX2Nsb2Nrd2lzZSA9IHRoaXMuX2Nsb2Nrd2lzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuICAgICAgICBfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuICAgICAgICBpZiAoZmxhZ3MgJiA4KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgICAgICBwYXJlbnQuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5fY2xvY2t3aXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnZlcyAmJiAhKGZsYWdzICYgMTYpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vbm9DdXJ2ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG4gICAgfSxcblxuICAgIGdldFNlZ21lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuICAgIH0sXG5cbiAgICBzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgICAgICAgdmFyIGZ1bGx5U2VsZWN0ZWQgPSB0aGlzLmlzRnVsbHlTZWxlY3RlZCgpO1xuICAgICAgICB0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG4gICAgICAgIGlmIChmdWxseVNlbGVjdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICBnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG4gICAgfSxcblxuICAgIGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzW3RoaXMuX3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICBnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgICAgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcbiAgICAgICAgaWYgKCFjdXJ2ZXMpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuICAgICAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgIH0sXG5cbiAgICBnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG4gICAgfSxcblxuICAgIGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuICAgICAgICByZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcbiAgICB9LFxuXG4gICAgaXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH0sXG5cbiAgICBzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgyNSk7XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgYmVhbnM6IHRydWUsXG5cbiAgICBnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGYgPSBuZXcgRm9ybWF0dGVyKF9wcmVjaXNpb24pLFxuICAgICAgICAgICAgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxuICAgICAgICAgICAgY3VyWCwgY3VyWSxcbiAgICAgICAgICAgIHByZXZYLCBwcmV2WSxcbiAgICAgICAgICAgIGluWCwgaW5ZLFxuICAgICAgICAgICAgb3V0WCwgb3V0WSxcbiAgICAgICAgICAgIHBhcnRzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuICAgICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICBjdXJYID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgY3VyWSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJ00nICsgZi5wYWlyKGN1clgsIGN1clkpKTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpblggPSBjb29yZHNbMl07XG4gICAgICAgICAgICAgICAgaW5ZID0gY29vcmRzWzNdO1xuICAgICAgICAgICAgICAgIGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBMaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgnbCcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCdjJyArIGYucGFpcihvdXRYIC0gcHJldlgsIG91dFkgLSBwcmV2WSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgJyArIGYucGFpcihpblggLSBwcmV2WCwgaW5ZIC0gcHJldlkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2WCA9IGN1clg7XG4gICAgICAgICAgICBwcmV2WSA9IGN1clk7XG4gICAgICAgICAgICBvdXRYID0gY29vcmRzWzRdO1xuICAgICAgICAgICAgb3V0WSA9IGNvb3Jkc1s1XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuICAgICAgICAgICAgcGFydHMucHVzaCgneicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9XG59LCB7XG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgaXNQb2x5Z29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2VnbWVudHNbaV0uaXNMaW5lYXIoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX2FkZDogZnVuY3Rpb24oc2VncywgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgICBhbW91bnQgPSBzZWdzLmxlbmd0aCxcbiAgICAgICAgICAgIGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG4gICAgICAgICAgICBpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5fcGF0aClcbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcbiAgICAgICAgICAgIHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuICAgICAgICAgICAgc2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIDAsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBzZWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnZlcyB8fCBzZWdzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICAgIGlmICghY3VydmVzKVxuICAgICAgICAgICAgICAgIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZyb20gPSBpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBpbmRleCxcbiAgICAgICAgICAgICAgICBzdGFydCA9IGZyb20sXG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbihmcm9tICsgYW1vdW50LCB0aGlzLl9jb3VudEN1cnZlcygpKTtcbiAgICAgICAgICAgIGlmIChzZWdzLl9jdXJ2ZXMpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW2Zyb20sIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcbiAgICAgICAgICAgICAgICBzdGFydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgdG87IGkrKylcbiAgICAgICAgICAgICAgICBjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RDdXJ2ZXMoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoMjUpO1xuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9LFxuXG4gICAgX2FkanVzdEN1cnZlczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgICBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG4gICAgICAgICAgICBjdXJ2ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgICAgIGN1cnZlLl9wYXRoID0gdGhpcztcbiAgICAgICAgICAgIGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgY3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuICAgICAgICAgICAgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmIGZyb20gPT09IDAgPyBzZWdtZW50cy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgOiBmcm9tIC0gMV0pIHtcbiAgICAgICAgICAgIGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2Zyb21dIHx8IHNlZ21lbnRzWzBdO1xuICAgICAgICAgICAgY3VydmUuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VydmUgPSBjdXJ2ZXNbdG9dKSB7XG4gICAgICAgICAgICBjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1t0b107XG4gICAgICAgICAgICBjdXJ2ZS5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb3VudEN1cnZlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKHNlZ21lbnQxICkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICA6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMsIDEpLCBpbmRleClcbiAgICAgICAgICAgIDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuICAgIH0sXG5cbiAgICBhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuICAgIH0sXG5cbiAgICBpbnNlcnRTZWdtZW50OiBmdW5jdGlvbihpbmRleCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcbiAgICB9LFxuXG4gICAgYWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG4gICAgfSxcblxuICAgIGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbihpbmRleCwgc2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpLCBpbmRleCk7XG4gICAgfSxcblxuICAgIHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG4gICAgfSxcblxuICAgIHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihmcm9tLCB0bywgX2luY2x1ZGVDdXJ2ZXMpIHtcbiAgICAgICAgZnJvbSA9IGZyb20gfHwgMDtcbiAgICAgICAgdG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgICAgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuICAgICAgICAgICAgY291bnQgPSBzZWdtZW50cy5sZW5ndGgsIFxuICAgICAgICAgICAgcmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShmcm9tLCB0byAtIGZyb20pLFxuICAgICAgICAgICAgYW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgICAgIGlmICghYW1vdW50KVxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUsIDApO1xuICAgICAgICAgICAgc2VnbWVudC5faW5kZXggPSBzZWdtZW50Ll9wYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG4gICAgICAgIGlmIChjdXJ2ZXMpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZyb20gPiAwICYmIHRvID09PSBjb3VudCArICh0aGlzLl9jbG9zZWQgPyAxIDogMClcbiAgICAgICAgICAgICAgICAgICAgPyBmcm9tIC0gMVxuICAgICAgICAgICAgICAgICAgICA6IGZyb20sXG4gICAgICAgICAgICAgICAgY3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcbiAgICAgICAgICAgIGlmIChfaW5jbHVkZUN1cnZlcylcbiAgICAgICAgICAgICAgICByZW1vdmVkLl9jdXJ2ZXMgPSBjdXJ2ZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICB0aGlzLl9hZGp1c3RDdXJ2ZXMoaW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VkKDI1KTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuICAgICAgICB2YXIgYXJlYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGFyZWEgKz0gY3VydmVzW2ldLmdldEFyZWEoKTtcbiAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfSxcblxuICAgIGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZCAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlXG4gICAgICAgICAgICAgICAgPT09IGxlbmd0aCAqIDc7XG4gICAgfSxcblxuICAgIHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZClcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgICAgIGlmICghc2VsZWN0ZWQpXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG4gICAgICAgIHNldFNlbGVjdGVkLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3RlZCk7XG4gICAgfSxcblxuICAgIF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gbGVuZ3RoICogNyA6IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50c1tpXS5fc2VsZWN0aW9uU3RhdGUgPSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICA/IDcgOiAwO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzZWdtZW50LCBvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgKz0gbmV3U3RhdGUgLSBvbGRTdGF0ZTtcbiAgICAgICAgaWYgKHRvdGFsID4gMClcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcblxuICAgIGZsYXR0ZW46IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgNjQsIDAuMSksXG4gICAgICAgICAgICBwb3MgPSAwLFxuICAgICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLmxlbmd0aCAvIE1hdGguY2VpbChpdGVyYXRvci5sZW5ndGggLyBtYXhEaXN0YW5jZSksXG4gICAgICAgICAgICBlbmQgPSBpdGVyYXRvci5sZW5ndGggKyAodGhpcy5fY2xvc2VkID8gLXN0ZXAgOiBzdGVwKSAvIDI7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAocG9zIDw9IGVuZCkge1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgU2VnbWVudChpdGVyYXRvci5ldmFsdWF0ZShwb3MsIDApKSk7XG4gICAgICAgICAgICBwb3MgKz0gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgICB9LFxuXG4gICAgcmVkdWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJ2ZS5pc0xpbmVhcigpICYmIGN1cnZlLmdldExlbmd0aCgpID09PSAwKVxuICAgICAgICAgICAgICAgIGN1cnZlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaW1wbGlmeTogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZWdtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgZml0dGVyID0gbmV3IFBhdGhGaXR0ZXIodGhpcywgdG9sZXJhbmNlIHx8IDIuNSk7XG4gICAgICAgICAgICB0aGlzLnNldFNlZ21lbnRzKGZpdHRlci5maXQoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3BsaXQ6IGZ1bmN0aW9uKGluZGV4LCBwYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHBhcmFtZXRlciA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBpbmRleDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLmdldExvY2F0aW9uQXQoYXJnKTtcbiAgICAgICAgICAgIGluZGV4ID0gYXJnLmluZGV4O1xuICAgICAgICAgICAgcGFyYW1ldGVyID0gYXJnLnBhcmFtZXRlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9sZXJhbmNlID0gMC4wMDAwMTtcbiAgICAgICAgaWYgKHBhcmFtZXRlciA+PSAxIC0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgcGFyYW1ldGVyLS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlciA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgIGN1cnZlc1tpbmRleCsrXS5kaXZpZGUocGFyYW1ldGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBwYXRoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMuX2Nsb25lKG5ldyBQYXRoKCkuaW5zZXJ0QWJvdmUodGhpcywgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5fYWRkKHNlZ3MsIDApO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb2Nrd2lzZTtcbiAgICAgICAgcmV0dXJuIFBhdGguaXNDbG9ja3dpc2UodGhpcy5fc2VnbWVudHMpO1xuICAgIH0sXG5cbiAgICBzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpXG4gICAgICAgICAgICB0aGlzLnJldmVyc2UoKTtcbiAgICAgICAgdGhpcy5fY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuICAgICAgICAgICAgc2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG4gICAgICAgICAgICBzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcbiAgICAgICAgICAgIHNlZ21lbnQuX2luZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9jbG9ja3dpc2UgPSAhdGhpcy5fY2xvY2t3aXNlO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDkpO1xuICAgIH0sXG5cbiAgICBqb2luOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcbiAgICAgICAgICAgICAgICBsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpXG4gICAgICAgICAgICAgICAgcGF0aC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB2YXIgZmlyc3QxLFxuICAgICAgICAgICAgICAgIGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG4gICAgICAgICAgICBpZiAobGFzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSkge1xuICAgICAgICAgICAgICAgIGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0MS5zZXRIYW5kbGVJbihsYXN0Mi5faGFuZGxlSW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aC5jbG9zZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkKFtzZWdtZW50c1swXV0pO1xuICAgICAgICAgICAgcGF0aC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuICAgICAgICAgICAgbGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcbiAgICAgICAgaWYgKGZpcnN0ICE9PSBsYXN0ICYmIGZpcnN0Ll9wb2ludC5lcXVhbHMobGFzdC5fcG9pbnQpKSB7XG4gICAgICAgICAgICBmaXJzdC5zZXRIYW5kbGVJbihsYXN0Ll9oYW5kbGVJbik7XG4gICAgICAgICAgICBsYXN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9TaGFwZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHJhZGl1cyxcbiAgICAgICAgICAgIHRvcENlbnRlcjtcblxuICAgICAgICBmdW5jdGlvbiBpc0NvbGluZWFyKGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50c1tpXS5pc0NvbGluZWFyKHNlZ21lbnRzW2pdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHNbaV0uaXNPcnRob2dvbmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0FyYyhpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHNbaV0uaXNBcmMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERpc3RhbmNlKGksIGopIHtcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50c1tpXS5fcG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudHNbal0uX3BvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzUG9seWdvbigpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgICYmIGlzQ29saW5lYXIoMCwgMikgJiYgaXNDb2xpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG4gICAgICAgICAgICBzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcbiAgICAgICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG4gICAgICAgICAgICAgICAgJiYgaXNBcmMoNikgJiYgaXNDb2xpbmVhcigxLCA1KSAmJiBpc0NvbGluZWFyKDMsIDcpKSB7XG4gICAgICAgICAgICB0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuICAgICAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG4gICAgICAgICAgICByYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuICAgICAgICAgICAgICAgICAgICBnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcbiAgICAgICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgJiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcbiAgICAgICAgICAgIGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IFNoYXBlLkNpcmNsZTtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBnZXREaXN0YW5jZSgwLCAyKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKSxcbiAgICAgICAgICAgICAgICBzaGFwZSA9IG5ldyB0eXBlKHtcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcbiAgICAgICAgICAgIHNoYXBlLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2hhcGUuaW5zZXJ0QWJvdmUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG4gICAgICAgICAgICBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgICAgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG4gICAgICAgICAgICB0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcbiAgICAgICAgICAgIHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuICAgICAgICAgICAgam9pbiwgY2FwLCBtaXRlckxpbWl0LFxuICAgICAgICAgICAgYXJlYSwgbG9jLCByZXMsXG4gICAgICAgICAgICBoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgIGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuICAgICAgICAgICAgaGl0Q3VydmVzID0gb3B0aW9ucy5jdXJ2ZXMsXG4gICAgICAgICAgICByYWRpdXMgPSBoaXRTdHJva2VcbiAgICAgICAgICAgICAgICAgICAgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAwIDogbnVsbDtcbiAgICAgICAgaWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgICAgICBqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuICAgICAgICAgICAgICAgIGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuICAgICAgICAgICAgICAgIG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgICAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcuYWRkKG5ldyBQb2ludChyYWRpdXMsIHJhZGl1cykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBqb2luID0gY2FwID0gJ3JvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuICAgICAgICAgICAgICAgIGlmIChwdCAhPT0gYW5jaG9yKVxuICAgICAgICAgICAgICAgICAgICBwdCA9IHB0LmFkZChhbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBzZWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG4gICAgICAgICAgICAgICAgJiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpXG4gICAgICAgICAgICAgICAgfHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuICAgICAgICAgICAgICAgICAgICBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fFxuICAgICAgICAgICAgICAgICAgICBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuICAgICAgICAgICAgYXJlYS5hZGQocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChqb2luICE9PSAncm91bmQnIHx8IGNhcCAhPT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGFyZWEgPSBuZXcgUGF0aCh7IGludGVybmFsOiB0cnVlLCBjbG9zZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2luICE9PSAncm91bmQnICYmIChzZWdtZW50Ll9oYW5kbGVJbi5pc1plcm8oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0FyZWEsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FwICE9PSAncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkVG9BcmVhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYWRpdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcbiAgICAgICAgICAgIGlmIChsb2MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gbG9jLmdldFBhcmFtZXRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgcGFyYW1ldGVyID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpIDw9IG1pdGVyTGltaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhbG9jICYmIGhpdEZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpXG4gICAgICAgICAgICAgICAgfHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlc1xuICAgICAgICAgICAgICAgICAgICA/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IGxvY1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGxvYy5nZXRQb2ludCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxufSwgQmFzZS5lYWNoKFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sXG4gICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0LCBpc1BhcmFtZXRlcik7XG4gICAgICAgICAgICByZXR1cm4gbG9jICYmIGxvY1tuYW1lXSgpO1xuICAgICAgICB9O1xuICAgIH0sXG57XG4gICAgYmVhbnM6IGZhbHNlLFxuXG4gICAgX2dldE9mZnNldDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jYXRpb24gJiYgbG9jYXRpb24uZ2V0SW5kZXgoKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyID0gbG9jYXRpb24uZ2V0UGFyYW1ldGVyKCk7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyID4gMClcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcbiAgICAgICAgICAgIGlmIChsb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG4gICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKGlzUGFyYW1ldGVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB+fm9mZnNldDsgXG4gICAgICAgICAgICByZXR1cm4gY3VydmVzW2luZGV4XS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIGluZGV4LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcbiAgICAgICAgICAgIG1pbkRpc3QgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIG1pbkxvYyA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuICAgICAgICAgICAgaWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgbWluTG9jID0gbG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW5Mb2M7XG4gICAgfSxcblxuICAgIGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG4gICAgfVxufSksIG5ldyBmdW5jdGlvbigpIHsgXG5cbiAgICBmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcbiAgICAgICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcblxuICAgICAgICBmdW5jdGlvbiBkcmF3SGFuZGxlKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaFggPSBjb29yZHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgIGhZID0gY29vcmRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICBpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwWCwgcFkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oaFgsIGhZKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLFxuICAgICAgICAgICAgICAgIHBYID0gY29vcmRzWzBdLFxuICAgICAgICAgICAgICAgIHBZID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYgMSlcbiAgICAgICAgICAgICAgICBkcmF3SGFuZGxlKDIpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYgMilcbiAgICAgICAgICAgICAgICBkcmF3SGFuZGxlKDQpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHBYIC0gaGFsZiwgcFkgLSBoYWxmLCBzaXplLCBzaXplKTtcbiAgICAgICAgICAgIGlmICghKHN0YXRlICYgNCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChwWCAtIGhhbGYgKyAxLCBwWSAtIGhhbGYgKyAxLCBzaXplIC0gMiwgc2l6ZSAtIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgICBmaXJzdCA9IHRydWUsXG4gICAgICAgICAgICBjdXJYLCBjdXJZLFxuICAgICAgICAgICAgcHJldlgsIHByZXZZLFxuICAgICAgICAgICAgaW5YLCBpblksXG4gICAgICAgICAgICBvdXRYLCBvdXRZO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGN1clggPSBjb29yZHNbMF07XG4gICAgICAgICAgICAgICAgY3VyWSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG4gICAgICAgICAgICAgICAgY3VyWCA9IHBvaW50Ll94O1xuICAgICAgICAgICAgICAgIGN1clkgPSBwb2ludC5feTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgICAgICBpblggPSBjb29yZHNbMl07XG4gICAgICAgICAgICAgICAgICAgIGluWSA9IGNvb3Jkc1szXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG4gICAgICAgICAgICAgICAgICAgIGluWCA9IGN1clggKyBoYW5kbGUuX3g7XG4gICAgICAgICAgICAgICAgICAgIGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGN1clgsIGN1clkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKG91dFgsIG91dFksIGluWCwgaW5ZLCBjdXJYLCBjdXJZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2WCA9IGN1clg7XG4gICAgICAgICAgICBwcmV2WSA9IGN1clk7XG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgb3V0WCA9IGNvb3Jkc1s0XTtcbiAgICAgICAgICAgICAgICBvdXRZID0gY29vcmRzWzVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuICAgICAgICAgICAgICAgIG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcbiAgICAgICAgICAgICAgICBvdXRZID0gcHJldlkgKyBoYW5kbGUuX3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuICAgICAgICBpZiAocGF0aC5fY2xvc2VkICYmIGxlbmd0aCA+IDApXG4gICAgICAgICAgICBkcmF3U2VnbWVudChzZWdtZW50c1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcbiAgICAgICAgICAgICAgICBkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG4gICAgICAgICAgICAgICAgaGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcbiAgICAgICAgICAgICAgICBoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcbiAgICAgICAgICAgICAgICBkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2VcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIWRvbnRTdGFydClcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGlmICghZG9udFN0YXJ0ICYmIHRoaXMuX2N1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgY3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlICYmICFkYXNoTGVuZ3RoIHx8IGRvbnRQYWludCkge1xuICAgICAgICAgICAgICAgIGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmICghZG9udFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGFzaEFycmF5WygoaSAlIGRhc2hMZW5ndGgpICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhc2hMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9udFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgMzIsIDAuMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZU1hdHJpeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gaXRlcmF0b3IubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tICUgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IDAgfHwgdG8gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5kcmF3UGFydChjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblxuICAgIGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcbiAgICAgICAgdmFyIG4gPSByaHMubGVuZ3RoLFxuICAgICAgICAgICAgeCA9IFtdLCBcbiAgICAgICAgICAgIHRtcCA9IFtdLCBcbiAgICAgICAgICAgIGIgPSAyO1xuICAgICAgICB4WzBdID0gcmhzWzBdIC8gYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRtcFtpXSA9IDEgLyBiO1xuICAgICAgICAgICAgYiA9IChpIDwgbiAtIDEgPyA0IDogMikgLSB0bXBbaV07XG4gICAgICAgICAgICB4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHhbbiAtIGkgLSAxXSAtPSB0bXBbbiAtIGldICogeFtuIC0gaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc21vb3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuICAgICAgICAgICAgICAgIHNpemUgPSBzZWdtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuICAgICAgICAgICAgICAgIG4gPSBzaXplLFxuICAgICAgICAgICAgICAgIG92ZXJsYXAgPSAwO1xuICAgICAgICAgICAgaWYgKHNpemUgPD0gMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmxhcCA9IE1hdGgubWluKHNpemUsIDQpO1xuICAgICAgICAgICAgICAgIG4gKz0gTWF0aC5taW4oc2l6ZSwgb3ZlcmxhcCkgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtub3RzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgICAgICBrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG4gICAgICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGFwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAga25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcbiAgICAgICAgICAgICAgICAgICAga25vdHNbaSArIHNpemUgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByaHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuICAgICAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feCArIDIgKiBrbm90c1tpICsgMV0uX3g7XG4gICAgICAgICAgICByaHNbMF0gPSBrbm90c1swXS5feCArIDIgKiBrbm90c1sxXS5feDtcbiAgICAgICAgICAgIHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl94O1xuICAgICAgICAgICAgdmFyIHggPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuICAgICAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG4gICAgICAgICAgICByaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcbiAgICAgICAgICAgIHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuICAgICAgICAgICAgdmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gc2l6ZTsgaSA8IG92ZXJsYXA7IGkrKywgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmMSA9IGkgLyBvdmVybGFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSAxIC0gZjEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZSA9IGkgKyBvdmVybGFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgamUgPSBqICsgb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICAgICAgeFtqXSA9IHhbaV0gKiBmMSArIHhbal0gKiBmMjtcbiAgICAgICAgICAgICAgICAgICAgeVtqXSA9IHlbaV0gKiBmMSArIHlbal0gKiBmMjtcbiAgICAgICAgICAgICAgICAgICAgeFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcbiAgICAgICAgICAgICAgICAgICAgeVtqZV0gPSB5W2llXSAqIGYyICsgeVtqZV0gKiBmMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZUluID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwOyBpIDw9IG4gLSBvdmVybGFwOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2kgLSBvdmVybGFwXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlSW4pXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5zZXRIYW5kbGVPdXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUluID0gaSA8IG4gLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgKiBrbm90c1tpICsgMV0uX3ggLSB4W2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMiAqIGtub3RzW2kgKyAxXS5feSAtIHlbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0uX3ggKyB4W24gLSAxXSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xvc2VkICYmIGhhbmRsZUluKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1swXTtcbiAgICAgICAgICAgICAgICBzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSwgbmV3IGZ1bmN0aW9uKCkgeyBcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoYXQuX3NlZ21lbnRzO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VnbWVudCgwKTtcbiAgICAgICAgICAgIGlmICghc2VnbWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZUJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW92ZUJ5KCkgaXMgdW5zdXBwb3J0ZWQgb24gUGF0aCBpdGVtcy4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgaGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG4gICAgICAgICAgICBjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG4gICAgICAgICAgICB0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuICAgICAgICAgICAgdGhpcy5jdWJpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgaGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcbiAgICAgICAgICAgICAgICBoYW5kbGUuYWRkKHRvLnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcbiAgICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG4gICAgICAgICAgICAgICAgdDEgPSAxIC0gdCxcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHRvLm11bHRpcGx5KHQgKiB0KSkuZGl2aWRlKDIgKiB0ICogdDEpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZS5pc05hTigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBwdXQgYSBjdXJ2ZSB0aHJvdWdoIHBvaW50cyB3aXRoIHBhcmFtZXRlciA9ICcgKyB0KTtcbiAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhoYW5kbGUsIHRvKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcmNUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuICAgICAgICAgICAgICAgIGZyb20gPSBjdXJyZW50Ll9wb2ludCxcbiAgICAgICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB0aHJvdWdoLFxuICAgICAgICAgICAgICAgIHBlZWsgPSBCYXNlLnBlZWsoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgY2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuICAgICAgICAgICAgICAgIHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmd1bWVudHMpIDw9IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdWdoID0gdG87XG4gICAgICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmFkaXVzLmlzWmVybygpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG4gICAgICAgICAgICAgICAgICAgIHB0ID0gZnJvbS5zdWJ0cmFjdChtaWRkbGUpLnJvdGF0ZSgtcm90YXRpb24pLFxuICAgICAgICAgICAgICAgICAgICB4ID0gcHQueCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IHB0LnksXG4gICAgICAgICAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICAgICAgICBFUFNJTE9OID0gMWUtMTEsXG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gYWJzKHJhZGl1cy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICByeFNxID0gcnggKiByeCxcbiAgICAgICAgICAgICAgICAgICAgcnlTcSA9IHJ5ICogcnksXG4gICAgICAgICAgICAgICAgICAgIHhTcSA9ICB4ICogeCxcbiAgICAgICAgICAgICAgICAgICAgeVNxID0gIHkgKiB5O1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuICAgICAgICAgICAgICAgIGlmIChmYWN0b3IgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ4ICo9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgcnkgKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICByeFNxID0gcnggKiByeDtcbiAgICAgICAgICAgICAgICAgICAgcnlTcSA9IHJ5ICogcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuICAgICAgICAgICAgICAgIGlmIChhYnMoZmFjdG9yKSA8IEVQU0lMT04pXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGZhY3RvciA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNxcnQoZmFjdG9yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKS5yb3RhdGUocm90YXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2NhbGUocngsIHJ5KTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjbG9ja3dpc2UgJiYgZXh0ZW50ID4gMClcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50IC09IDM2MDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9ja3dpc2UgJiYgZXh0ZW50IDwgMClcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50ICs9IDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwxID0gbmV3IExpbmUoZnJvbS5hZGQodGhyb3VnaCkuZGl2aWRlKDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGwyID0gbmV3IExpbmUodGhyb3VnaC5hZGQodG8pLmRpdmlkZSgyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IG5ldyBMaW5lKGZyb20sIHRvKSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG4gICAgICAgICAgICAgICAgY2VudGVyID0gbDEuaW50ZXJzZWN0KGwyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRocm91Z2hTaWRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZVRvKHRvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKHRvLnN1YnRyYWN0KGNlbnRlcikpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlclNpZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleHQgPSBNYXRoLmFicyhleHRlbnQpLFxuICAgICAgICAgICAgICAgIGNvdW50ID0gZXh0ID49IDM2MCA/IDQgOiBNYXRoLmNlaWwoZXh0IC8gOTApLFxuICAgICAgICAgICAgICAgIGluYyA9IGV4dGVudCAvIGNvdW50LFxuICAgICAgICAgICAgICAgIGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuICAgICAgICAgICAgICAgIHogPSA0IC8gMyAqIE1hdGguc2luKGhhbGYpIC8gKDEgKyBNYXRoLmNvcyhoYWxmKSksXG4gICAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHQgPSB0byxcbiAgICAgICAgICAgICAgICAgICAgb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChvdXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3VidHJhY3QocHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGQoc2VnbWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxpbmVCeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3VydmVCeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuICAgICAgICAgICAgdGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcbiAgICAgICAgICAgIHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGQodG8pKTtcbiAgICAgICAgfSxcblxuICAgICAgICBxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcbiAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFyY0J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuICAgICAgICAgICAgICAgIHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuICAgICAgICAgICAgdGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoam9pbilcbiAgICAgICAgICAgICAgICB0aGlzLmpvaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG59LCB7ICBcblxuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG4gICAgICAgIHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgICAgICAgICAgIG1hdHJpeCk7XG4gICAgfSxcblxuc3RhdGljczoge1xuICAgIGlzQ2xvY2t3aXNlOiBmdW5jdGlvbihzZWdtZW50cykge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gQ3VydmUuZ2V0VmFsdWVzKFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tpXSwgc2VnbWVudHNbaSArIDEgPCBsID8gaSArIDEgOiAwXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMjsgaiA8IDg7IGogKz0gMilcbiAgICAgICAgICAgICAgICBzdW0gKz0gKHZbaiAtIDJdIC0gdltqXSkgKiAodltqICsgMV0gKyB2W2ogLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSA+IDA7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZykge1xuICAgICAgICB2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcbiAgICAgICAgaWYgKCFmaXJzdClcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG4gICAgICAgIHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG4gICAgICAgICAgICBwcmV2Q29vcmRzID0gZmlyc3QuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCBmYWxzZSksXG4gICAgICAgICAgICBtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLCBcbiAgICAgICAgICAgIG1heCA9IG1pbi5zbGljZSgpLCBcbiAgICAgICAgICAgIHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgICAgIHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgICAgIEN1cnZlLl9hZGRCb3VuZHMoXG4gICAgICAgICAgICAgICAgICAgIHByZXZDb29yZHNbaV0sIFxuICAgICAgICAgICAgICAgICAgICBwcmV2Q29vcmRzW2kgKyA0XSwgXG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc1tpICsgMl0sIFxuICAgICAgICAgICAgICAgICAgICBjb29yZHNbaV0sIFxuICAgICAgICAgICAgICAgICAgICBpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gcHJldkNvb3JkcztcbiAgICAgICAgICAgIHByZXZDb29yZHMgPSBjb29yZHM7XG4gICAgICAgICAgICBjb29yZHMgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcbiAgICAgICAgaWYgKGNsb3NlZClcbiAgICAgICAgICAgIHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcbiAgICB9LFxuXG4gICAgZ2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG4gICAgICAgIGlmICghc3R5bGUuaGFzU3Ryb2tlKCkpXG4gICAgICAgICAgICByZXR1cm4gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSAoY2xvc2VkID8gMCA6IDEpLFxuICAgICAgICAgICAgcmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG4gICAgICAgICAgICBwYWRkaW5nID0gUGF0aC5fZ2V0UGVuUGFkZGluZyhyYWRpdXMsIG1hdHJpeCksXG4gICAgICAgICAgICBib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBwYWRkaW5nKSxcbiAgICAgICAgICAgIGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG4gICAgICAgICAgICBjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcbiAgICAgICAgICAgIG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHZhciBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShwYWRkaW5nKS5tdWx0aXBseSgyKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50KSB7XG4gICAgICAgICAgICBib3VuZHMgPSBib3VuZHMuaW5jbHVkZShtYXRyaXhcbiAgICAgICAgICAgICAgICA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50KSA6IHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFJvdW5kKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IGJvdW5kcy51bml0ZShqb2luQm91bmRzLnNldENlbnRlcihtYXRyaXhcbiAgICAgICAgICAgICAgICA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoc2VnbWVudC5fcG9pbnQpIDogc2VnbWVudC5fcG9pbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW4sXG4gICAgICAgICAgICAgICAgaGFuZGxlT3V0ID0gc2VnbWVudC5faGFuZGxlT3V0O1xuICAgICAgICAgICAgaWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcbiAgICAgICAgICAgICAgICAgICAgJiYgaGFuZGxlSW4uaXNDb2xpbmVhcihoYW5kbGVPdXQpKSB7XG4gICAgICAgICAgICAgICAgYWRkUm91bmQoc2VnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG4gICAgICAgICAgICBpZiAoY2FwID09PSAncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgYWRkUm91bmQoc2VnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgICAgYWRkSm9pbihzZWdtZW50c1swXSwgam9pbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuICAgICAgICAgICAgYWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuICAgICAgICBpZiAoIW1hdHJpeClcbiAgICAgICAgICAgIHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuICAgICAgICB2YXIgbXggPSBtYXRyaXguc2hpZnRsZXNzKCksXG4gICAgICAgICAgICBob3IgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KHJhZGl1cywgMCkpLFxuICAgICAgICAgICAgdmVyID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludCgwLCByYWRpdXMpKSxcbiAgICAgICAgICAgIHBoaSA9IGhvci5nZXRBbmdsZUluUmFkaWFucygpLFxuICAgICAgICAgICAgYSA9IGhvci5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgIGIgPSB2ZXIuZ2V0TGVuZ3RoKCk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MocGhpKSxcbiAgICAgICAgICAgIHRhbiA9IE1hdGgudGFuKHBoaSksXG4gICAgICAgICAgICB0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuICAgICAgICAgICAgdHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG4gICAgICAgIHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyAtIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG4gICAgfSxcblxuICAgIF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkUG9pbnQsIGFyZWEpIHtcbiAgICAgICAgdmFyIGN1cnZlMiA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcbiAgICAgICAgICAgIGN1cnZlMSA9IGN1cnZlMi5nZXRQcmV2aW91cygpLFxuICAgICAgICAgICAgcG9pbnQgPSBjdXJ2ZTIuZ2V0UG9pbnRBdCgwLCB0cnVlKSxcbiAgICAgICAgICAgIG5vcm1hbDEgPSBjdXJ2ZTEuZ2V0Tm9ybWFsQXQoMSwgdHJ1ZSksXG4gICAgICAgICAgICBub3JtYWwyID0gY3VydmUyLmdldE5vcm1hbEF0KDAsIHRydWUpLFxuICAgICAgICAgICAgc3RlcCA9IG5vcm1hbDEuZ2V0RGlyZWN0ZWRBbmdsZShub3JtYWwyKSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzO1xuICAgICAgICBub3JtYWwxLnNldExlbmd0aChzdGVwKTtcbiAgICAgICAgbm9ybWFsMi5zZXRMZW5ndGgoc3RlcCk7XG4gICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICBhZGRQb2ludChwb2ludCk7XG4gICAgICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2luID09PSAnbWl0ZXInKSB7XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gbmV3IExpbmUoXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LmFkZChub3JtYWwxKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcbiAgICAgICAgICAgICAgICApLmludGVyc2VjdChuZXcgTGluZShcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuYWRkKG5vcm1hbDIpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuICAgICAgICAgICAgICAgICksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgICAgICBhZGRQb2ludChjb3JuZXIpO1xuICAgICAgICAgICAgICAgIGlmICghYXJlYSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlYSlcbiAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG4gICAgICAgIGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwyKSk7XG4gICAgfSxcblxuICAgIF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuICAgICAgICB2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludCxcbiAgICAgICAgICAgIGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcbiAgICAgICAgICAgIG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5ub3JtYWxpemUocmFkaXVzKTtcbiAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgIGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuICAgICAgICAgICAgYWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXAgPT09ICdzcXVhcmUnKVxuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZShsb2MuZ2V0UGFyYW1ldGVyKCkgPT09IDAgPyAtOTAgOiA5MCkpO1xuICAgICAgICBhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG4gICAgICAgIGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuICAgIH0sXG5cbiAgICBnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcsXG4gICAgICAgICAgICBqb2luUGFkZGluZykge1xuICAgICAgICB2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuICAgICAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgICAgIHgyID0gLXgxLFxuICAgICAgICAgICAgeTEgPSB4MSxcbiAgICAgICAgICAgIHkyID0geDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBqID09PSAwID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nWzBdIDogMCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG4gICAgICAgICAgICAgICAgICAgIHggPSBjb29yZHNbal0sXG4gICAgICAgICAgICAgICAgICAgIHkgPSBjb29yZHNbaiArIDFdLFxuICAgICAgICAgICAgICAgICAgICB4biA9IHggLSBwYWRkaW5nWCxcbiAgICAgICAgICAgICAgICAgICAgeHggPSB4ICsgcGFkZGluZ1gsXG4gICAgICAgICAgICAgICAgICAgIHluID0geSAtIHBhZGRpbmdZLFxuICAgICAgICAgICAgICAgICAgICB5eCA9IHkgKyBwYWRkaW5nWTtcbiAgICAgICAgICAgICAgICBpZiAoeG4gPCB4MSkgeDEgPSB4bjtcbiAgICAgICAgICAgICAgICBpZiAoeHggPiB4MikgeDIgPSB4eDtcbiAgICAgICAgICAgICAgICBpZiAoeW4gPCB5MSkgeTEgPSB5bjtcbiAgICAgICAgICAgICAgICBpZiAoeXggPiB5MikgeTIgPSB5eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICBnZXRSb3VnaEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuICAgICAgICB2YXIgc3Ryb2tlUmFkaXVzID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG4gICAgICAgICAgICBqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuICAgICAgICBpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuICAgICAgICAgICAgaWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcbiAgICAgICAgICAgICAgICBqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcbiAgICAgICAgICAgICAgICBqb2luUmFkaXVzID0gTWF0aC5tYXgoam9pblJhZGl1cywgc3Ryb2tlUmFkaXVzICogTWF0aC5zcXJ0KDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGF0aC5nZXRIYW5kbGVCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCxcbiAgICAgICAgICAgICAgICBQYXRoLl9nZXRQZW5QYWRkaW5nKHN0cm9rZVJhZGl1cywgbWF0cml4KSxcbiAgICAgICAgICAgICAgICBQYXRoLl9nZXRQZW5QYWRkaW5nKGpvaW5SYWRpdXMsIG1hdHJpeCkpO1xuICAgIH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG4gICAgICAgIGVsbGlwc2VTZWdtZW50cyA9IFtcbiAgICAgICAgICAgIG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG4gICAgICAgICAgICBuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuICAgICAgICAgICAgbmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuICAgICAgICAgICAgbmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG4gICAgICAgIF07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcbiAgICAgICAgcGF0aC5fYWRkKHNlZ21lbnRzKTtcbiAgICAgICAgcGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuICAgICAgICByZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbGxpcHNlU2VnbWVudHNbaV07XG4gICAgICAgICAgICBzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KFxuICAgICAgICAgICAgICAgIHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG4gICAgICAgICAgICAgICAgc2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcbiAgICAgICAgICAgICAgICBzZWdtZW50Ll9oYW5kbGVPdXQubXVsdGlwbHkocmFkaXVzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgTGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChbXG4gICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSksXG4gICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG4gICAgICAgICAgICBdLCBmYWxzZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDaXJjbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgbmV3IFNpemUocmFkaXVzKSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJlYWROdWxsOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIGJsID0gcmVjdC5nZXRCb3R0b21MZWZ0KHRydWUpLFxuICAgICAgICAgICAgICAgIHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuICAgICAgICAgICAgICAgIHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcbiAgICAgICAgICAgICAgICBiciA9IHJlY3QuZ2V0Qm90dG9tUmlnaHQodHJ1ZSksXG4gICAgICAgICAgICAgICAgc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoYmwpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgU2VnbWVudCh0bCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZWdtZW50KHRyKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoYnIpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFkaXVzID0gU2l6ZS5taW4ocmFkaXVzLCByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSByYWRpdXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gcmFkaXVzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaHggPSByeCAqIGthcHBhLFxuICAgICAgICAgICAgICAgICAgICBoeSA9IHJ5ICoga2FwcGE7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoYmwuc3VidHJhY3QoMCwgcnkpLCBbMCwgaHldKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZWdtZW50KHRyLnN1YnRyYWN0KHJ4LCAwKSwgbnVsbCwgW2h4LCAwXSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNlZ21lbnQoYnIuc3VidHJhY3QocngsIDApLCBbaHgsIDBdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG4gICAgICAgIEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBPdmFsOiAnI0VsbGlwc2UnLFxuXG4gICAgICAgIEFyYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG4gICAgICAgICAgICAgICAgdGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG4gICAgICAgICAgICAgICAgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSxcbiAgICAgICAgICAgICAgICBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgSXRlbS5OT19JTlNFUlQpO1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8oZnJvbSk7XG4gICAgICAgICAgICBwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoLnNldChwcm9wcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVndWxhclBvbHlnb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcbiAgICAgICAgICAgICAgICBzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3NpZGVzJyksXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG4gICAgICAgICAgICAgICAgc3RlcCA9IDM2MCAvIHNpZGVzLFxuICAgICAgICAgICAgICAgIHRocmVlID0gIShzaWRlcyAlIDMpLFxuICAgICAgICAgICAgICAgIHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRocmVlID8gLTEgOiAwLjUsXG4gICAgICAgICAgICAgICAgc2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3RhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuICAgICAgICAgICAgICAgIHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3BvaW50cycpICogMixcbiAgICAgICAgICAgICAgICByYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMScpLFxuICAgICAgICAgICAgICAgIHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG4gICAgICAgICAgICAgICAgc3RlcCA9IDM2MCAvIHBvaW50cyxcbiAgICAgICAgICAgICAgICB2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuICAgICAgICAgICAgICAgIHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59fSk7XG5cbnZhciBDb21wb3VuZFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG4gICAgX3NlcmlhbGl6ZUZpZWxkczoge1xuICAgICAgICBjaGlsZHJlbjogW11cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG91bmRQYXRoKGFyZykge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUpIHtcbiAgICAgICAgaXRlbXMgPSBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIFBhdGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9ICFfcHJlc2VydmUgJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uX2Nsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0Q2xvY2t3aXNlKGl0ZW0uX2luZGV4ID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5yZXZlcnNlKCk7XG4gICAgfSxcblxuICAgIHNtb290aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uc21vb3RoKCk7XG4gICAgfSxcblxuICAgIGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIHJldHVybiBjaGlsZCAmJiBjaGlsZC5pc0Nsb2Nrd2lzZSgpO1xuICAgIH0sXG5cbiAgICBzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcbiAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgIH0sXG5cbiAgICBnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuICAgIH0sXG5cbiAgICBnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgICAgcmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuICAgIH0sXG5cbiAgICBnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIGN1cnZlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgIH0sXG5cbiAgICBnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG4gICAgfSxcblxuICAgIGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgICAgcmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRGaXJzdEN1cnZlKCk7XG4gICAgfSxcblxuICAgIGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIGFyZWEgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGFyZWEgKz0gY2hpbGRyZW5baV0uZ2V0QXJlYSgpO1xuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9XG59LCB7XG4gICAgYmVhbnM6IHRydWUsXG5cbiAgICBnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIHBhdGhzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgICAgICBteCA9IGNoaWxkLl9tYXRyaXg7XG4gICAgICAgICAgICBwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuICAgICAgICAgICAgICAgICAgICA/IF9tYXRyaXguY2hhaW4obXgpIDogbXgsIF9wcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aHMuam9pbignICcpO1xuICAgIH1cbn0sIHtcbiAgICBfZ2V0Q2hpbGRIaXRUZXN0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJ1xuICAgICAgICAgICAgICAgID8gb3B0aW9uc1xuICAgICAgICAgICAgICAgIDogbmV3IEJhc2Uob3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KTtcbiAgICB9LFxuXG4gICAgX2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyYW0uY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCk7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzZWxlY3RlZEl0ZW1zKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgbXggPSBjaGlsZC5fbWF0cml4O1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEl0ZW1zW2NoaWxkLl9pZF0pXG4gICAgICAgICAgICAgICAgY2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXRyaXguY2hhaW4obXgpKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIG5ldyBmdW5jdGlvbigpIHsgXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGVjayAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBhIG1vdmVUbygpIGNvbW1hbmQgZmlyc3QnKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIHZhciBmaWVsZHMgPSB7XG4gICAgICAgIG1vdmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKCk7XG4gICAgICAgICAgICBpZiAocGF0aCAhPT0gY3VycmVudClcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgcGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlQnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLmNsb3NlUGF0aChqb2luKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG4gICAgICAgICAgICAnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhba2V5XS5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBmaWVsZHM7XG59KTtcblxuUGF0aEl0ZW0uaW5qZWN0KG5ldyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdG9yLCBzdWJ0cmFjdCkge1xuICAgICAgICBmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5jbG9uZShmYWxzZSkucmVkdWNlKCkucmVvcmllbnQoKS50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuICAgICAgICAgICAgX3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyKTtcbiAgICAgICAgaWYgKCFfcGF0aDEuaXNDbG9ja3dpc2UoKSlcbiAgICAgICAgICAgIF9wYXRoMS5yZXZlcnNlKCk7XG4gICAgICAgIGlmIChfcGF0aDIgJiYgIShzdWJ0cmFjdCBeIF9wYXRoMi5pc0Nsb2Nrd2lzZSgpKSlcbiAgICAgICAgICAgIF9wYXRoMi5yZXZlcnNlKCk7XG4gICAgICAgIHNwbGl0UGF0aChfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIG51bGwsIHRydWUpKTtcblxuICAgICAgICB2YXIgY2hhaW4gPSBbXSxcbiAgICAgICAgICAgIHdpbmRpbmdzID0gW10sXG4gICAgICAgICAgICBsZW5ndGhzID0gW10sXG4gICAgICAgICAgICBzZWdtZW50cyA9IFtdLFxuICAgICAgICAgICAgbW9ub0N1cnZlcyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxlY3QocGF0aHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgbW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIHBhdGguX2dldE1vbm9DdXJ2ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb2xsZWN0KF9wYXRoMS5fY2hpbGRyZW4gfHwgW19wYXRoMV0pO1xuICAgICAgICBpZiAoX3BhdGgyKVxuICAgICAgICAgICAgY29sbGVjdChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKTtcbiAgICAgICAgc2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBhLl9pbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICAgICAgX2IgPSBiLl9pbnRlcnNlY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gIV9hICYmICFfYiB8fCBfYSAmJiBfYiA/IDAgOiBfYSA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuX3dpbmRpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNoYWluLmxlbmd0aCA9IHdpbmRpbmdzLmxlbmd0aCA9IGxlbmd0aHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbExlbmd0aCA9IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRTZWcgPSBzZWdtZW50O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNoYWluLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgbGVuZ3Rocy5wdXNoKHRvdGFsTGVuZ3RoICs9IHNlZ21lbnQuZ2V0Q3VydmUoKS5nZXRMZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0U2VnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50ID0gbGVuZ3Rocy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aHNba10gPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoIC09IGxlbmd0aHNbayAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgrK2sgPCBhbW91bnQpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJ2ZSA9IGNoYWluW2tdLmdldEN1cnZlKCksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBob3IgPSBjdXJ2ZS5pc0hvcml6b250YWwoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGN1cnZlLl9wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLl9wYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLl9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgd2luZGluZ3Nbal0gPSBzdWJ0cmFjdCAmJiBfcGF0aDJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwYXRoID09PSBfcGF0aDEgJiYgX3BhdGgyLl9nZXRXaW5kaW5nKHBvaW50LCBob3IpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBwYXRoID09PSBfcGF0aDIgJiYgIV9wYXRoMS5fZ2V0V2luZGluZyhwb2ludCwgaG9yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRXaW5kaW5nKHBvaW50LCBtb25vQ3VydmVzLCBob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZGluZ3Muc29ydCgpO1xuICAgICAgICAgICAgdmFyIHdpbmRpbmcgPSB3aW5kaW5nc1sxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgICAgICBjaGFpbltqXS5fd2luZGluZyA9IHdpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoKTtcbiAgICAgICAgcmVzdWx0LmFkZENoaWxkcmVuKHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSwgdHJ1ZSk7XG4gICAgICAgIF9wYXRoMS5yZW1vdmUoKTtcbiAgICAgICAgaWYgKF9wYXRoMilcbiAgICAgICAgICAgIF9wYXRoMi5yZW1vdmUoKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlZHVjZSgpO1xuICAgICAgICByZXN1bHQuc2V0U3R5bGUocGF0aDEuX3N0eWxlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpdFBhdGgoaW50ZXJzZWN0aW9ucykge1xuICAgICAgICB2YXIgVE9MRVJBTkNFID0gMC4wMDAwMSxcbiAgICAgICAgICAgIGxpbmVhclNlZ21lbnRzO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0TGluZWFyKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lYXJTZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGxpbmVhclNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgIHNlZ21lbnQuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5faGFuZGxlSW4uc2V0KDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMSwgY3VydmUsIHByZXZMb2M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gaW50ZXJzZWN0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICB0ID0gbG9jLl9wYXJhbWV0ZXI7XG4gICAgICAgICAgICBpZiAocHJldkxvYyAmJiBwcmV2TG9jLl9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZVxuICAgICAgICAgICAgICAgICAgICAmJiBwcmV2TG9jLl9wYXJhbWV0ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgdCAvPSBwcmV2TG9jLl9wYXJhbWV0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lYXJTZWdtZW50cylcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRMaW5lYXIoKTtcbiAgICAgICAgICAgICAgICBjdXJ2ZSA9IGxvYy5fY3VydmU7XG4gICAgICAgICAgICAgICAgbGluZWFyU2VnbWVudHMgPSBjdXJ2ZS5pc0xpbmVhcigpICYmIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0N1cnZlLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ7XG4gICAgICAgICAgICBpZiAobmV3Q3VydmUgPSBjdXJ2ZS5kaXZpZGUodCwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gbmV3Q3VydmUuX3NlZ21lbnQxO1xuICAgICAgICAgICAgICAgIGN1cnZlID0gbmV3Q3VydmUuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IHQgPCBUT0xFUkFOQ0VcbiAgICAgICAgICAgICAgICAgICAgPyBjdXJ2ZS5fc2VnbWVudDFcbiAgICAgICAgICAgICAgICAgICAgOiB0ID4gMSAtIFRPTEVSQU5DRVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJ2ZS5fc2VnbWVudDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0KSA8IGN1cnZlLmdldFBhcnRMZW5ndGgodCwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnZlLl9zZWdtZW50MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY3VydmUuX3NlZ21lbnQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VnbWVudC5faW50ZXJzZWN0aW9uID0gbG9jLmdldEludGVyc2VjdGlvbigpO1xuICAgICAgICAgICAgbG9jLl9zZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChsaW5lYXJTZWdtZW50cylcbiAgICAgICAgICAgICAgICBsaW5lYXJTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgcHJldkxvYyA9IGxvYztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZWFyU2VnbWVudHMpXG4gICAgICAgICAgICByZXNldExpbmVhcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG4gICAgICAgIHZhciBUT0xFUkFOQ0UgPSAwLjAwMDAxLFxuICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgIHdpbmRMZWZ0ID0gMCxcbiAgICAgICAgICAgIHdpbmRSaWdodCA9IDAsXG4gICAgICAgICAgICByb290cyA9IFtdLFxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICBNQVggPSAxIC0gVE9MRVJBTkNFO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdmFyIHlUb3AgPSAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgeUJvdHRvbSA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHlCZWZvcmUgPSB5IC0gVE9MRVJBTkNFLFxuICAgICAgICAgICAgICAgIHlBZnRlciA9IHkgKyBUT0xFUkFOQ0U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcbiAgICAgICAgICAgICAgICBpZiAoQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDAsIHgsIHJvb3RzLCAwLCAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeTAgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS55O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkwIDwgeUJlZm9yZSAmJiB5MCA+IHlUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VG9wID0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHkwID4geUFmdGVyICYmIHkwIDwgeUJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlCb3R0b20gPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlUb3AgPSAoeVRvcCArIHkpIC8gMjtcbiAgICAgICAgICAgIHlCb3R0b20gPSAoeUJvdHRvbSArIHkpIC8gMjtcbiAgICAgICAgICAgIGlmICh5VG9wID4gLUluZmluaXR5KVxuICAgICAgICAgICAgICAgIHdpbmRMZWZ0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQoeCwgeVRvcCksIGN1cnZlcyk7XG4gICAgICAgICAgICBpZiAoeUJvdHRvbSA8IEluZmluaXR5KVxuICAgICAgICAgICAgICAgIHdpbmRSaWdodCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHgsIHlCb3R0b20pLCBjdXJ2ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHhCZWZvcmUgPSB4IC0gVE9MRVJBTkNFLFxuICAgICAgICAgICAgICAgIHhBZnRlciA9IHggKyBUT0xFUkFOQ0U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSBjdXJ2ZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGN1cnZlLnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgd2luZGluZyA9IGN1cnZlLndpbmRpbmcsXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBjdXJ2ZS5uZXh0O1xuICAgICAgICAgICAgICAgIGlmICh3aW5kaW5nICYmICh3aW5kaW5nID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB5ID49IHZhbHVlc1sxXSAmJiB5IDw9IHZhbHVlc1s3XVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgeSA+PSB2YWx1ZXNbN10gJiYgeSA8PSB2YWx1ZXNbMV0pXG4gICAgICAgICAgICAgICAgICAgICYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCB5LCByb290cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICFuZXh0LndpbmRpbmcgJiYgbmV4dC52YWx1ZXNbMV0gPT09IHkgPyAxIDogTUFYKSA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gcm9vdHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMCkueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3BlID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAxKS55O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzKHNsb3BlKSA8IFRPTEVSQU5DRSAmJiAhQ3VydmUuaXNMaW5lYXIodmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHQgPCBUT0xFUkFOQ0UgJiYgc2xvcGUgKiBDdXJ2ZS5ldmFsdWF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmUucHJldmlvdXMudmFsdWVzLCB0LCAxKS55IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RDb250YWlucyAmJiB4MCA+PSB4QmVmb3JlICYmIHgwIDw9IHhBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrd2luZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt3aW5kUmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeDAgPD0geEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZExlZnQgKz0gd2luZGluZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh4MCA+PSB4QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRSaWdodCArPSB3aW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChhYnMod2luZExlZnQpLCBhYnMod2luZFJpZ2h0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IsIHNlbGZPcCkge1xuICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXRocyA9IFtdLFxuICAgICAgICAgICAgWkVSTyA9IDFlLTMsXG4gICAgICAgICAgICBPTkUgPSAxIC0gMWUtMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHNlZywgc3RhcnRTZWcsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHNlZyA9IHN0YXJ0U2VnID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnLl92aXNpdGVkIHx8ICFvcGVyYXRvcihzZWcuX3dpbmRpbmcpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG4gICAgICAgICAgICAgICAgaW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbixcbiAgICAgICAgICAgICAgICBzdGFydEludGVyU2VnID0gaW50ZXIgJiYgaW50ZXIuX3NlZ21lbnQsXG4gICAgICAgICAgICAgICAgYWRkZWQgPSBmYWxzZSwgXG4gICAgICAgICAgICAgICAgZGlyID0gMTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlSW4gPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVJbiA6IHNlZy5faGFuZGxlT3V0LFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuICAgICAgICAgICAgICAgICAgICBpbnRlclNlZztcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGZPcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLl92aXNpdGVkID0gaW50ZXJTZWcuX3Zpc2l0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcgPSBpbnRlclNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzEgPSBzZWcuZ2V0Q3VydmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxID0gYzEuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0MSA9IGMxLmdldFRhbmdlbnRBdChkaXIgPCAxID8gWkVSTyA6IE9ORSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzQgPSBpbnRlclNlZy5nZXRDdXJ2ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzID0gYzQuZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MyA9IGMzLmdldFRhbmdlbnRBdChPTkUsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ0ID0gYzQuZ2V0VGFuZ2VudEF0KFpFUk8sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHczID0gdDEuY3Jvc3ModDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc0ID0gdDEuY3Jvc3ModDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHczICogdzQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSB3MyA8IHc0ID8gYzMgOiBjNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEN1cnZlID0gb3BlcmF0b3IoY3VydmUuX3NlZ21lbnQxLl93aW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB3MyA8IHc0ID8gYzQgOiBjMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNlZyA9IG5leHRDdXJ2ZS5fc2VnbWVudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gbmV4dEN1cnZlID09PSBjMyA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5fdmlzaXRlZCAmJiBzZWcuX3BhdGggIT09IG5leHRTZWcuX3BhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhb3BlcmF0b3IobmV4dFNlZy5fd2luZGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnID0gaW50ZXJTZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2VnLl92aXNpdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgYWRkZWQgJiYgaGFuZGxlSW4sIGhhbmRsZU91dCkpO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlZyA9IGRpciA+IDAgPyBzZWcuZ2V0TmV4dCgpIDogc2VnLiBnZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2VnICYmICFzZWcuX3Zpc2l0ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VnICE9PSBzdGFydFNlZyAmJiBzZWcgIT09IHN0YXJ0SW50ZXJTZWdcbiAgICAgICAgICAgICAgICAgICAgJiYgKHNlZy5faW50ZXJzZWN0aW9uIHx8IG9wZXJhdG9yKHNlZy5fd2luZGluZykpKTtcbiAgICAgICAgICAgIGlmIChzZWcgJiYgKHNlZyA9PT0gc3RhcnRTZWcgfHwgc2VnID09PSBzdGFydEludGVyU2VnKSkge1xuICAgICAgICAgICAgICAgIHBhdGguZmlyc3RTZWdtZW50LnNldEhhbmRsZUluKChzZWcgPT09IHN0YXJ0SW50ZXJTZWdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhcnRJbnRlclNlZyA6IHNlZykuX2hhbmRsZUluKTtcbiAgICAgICAgICAgICAgICBwYXRoLnNldENsb3NlZCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aC5sYXN0U2VnbWVudC5faGFuZGxlT3V0LnNldCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoLl9zZWdtZW50cy5sZW5ndGggPlxuICAgICAgICAgICAgICAgICAgICAocGF0aC5fY2xvc2VkID8gcGF0aC5pc1BvbHlnb24oKSA/IDIgOiAwIDogMSkpXG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG4gICAgICAgICAgICAgICAgICAgIGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pdGU6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcgPT09IDEgfHwgdyA9PT0gMDtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcgPT09IDI7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcgPT09IDE7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBleGNsdWRlOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdyb3VwKFt0aGlzLnN1YnRyYWN0KHBhdGgpLCBwYXRoLnN1YnRyYWN0KHRoaXMpXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdyb3VwKFt0aGlzLnN1YnRyYWN0KHBhdGgpLCB0aGlzLmludGVyc2VjdChwYXRoKV0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5QYXRoLmluamVjdCh7XG4gICAgX2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9ub0N1cnZlcyA9IHRoaXMuX21vbm9DdXJ2ZXMsXG4gICAgICAgICAgICBwcmV2Q3VydmU7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuICAgICAgICAgICAgdmFyIHkwID0gdlsxXSxcbiAgICAgICAgICAgICAgICB5MSA9IHZbN10sXG4gICAgICAgICAgICAgICAgY3VydmUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogdixcbiAgICAgICAgICAgICAgICAgICAgd2luZGluZzogeTAgPT09IHkxXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHkwID4geTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC0xIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMSwgXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2Q3VydmUsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwgXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcmV2Q3VydmUpXG4gICAgICAgICAgICAgICAgcHJldkN1cnZlLm5leHQgPSBjdXJ2ZTtcbiAgICAgICAgICAgIG1vbm9DdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgICAgICAgICBwcmV2Q3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcbiAgICAgICAgICAgIGlmIChDdXJ2ZS5nZXRMZW5ndGgodikgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHkwID0gdlsxXSxcbiAgICAgICAgICAgICAgICB5MSA9IHZbM10sXG4gICAgICAgICAgICAgICAgeTIgPSB2WzVdLFxuICAgICAgICAgICAgICAgIHkzID0gdls3XTtcbiAgICAgICAgICAgIGlmIChDdXJ2ZS5pc0xpbmVhcih2KSkge1xuICAgICAgICAgICAgICAgIGluc2VydEN1cnZlKHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IDMgKiAoeTEgLSB5MikgLSB5MCArIHkzLFxuICAgICAgICAgICAgICAgICAgICBiID0gMiAqICh5MCArIHkyKSAtIDQgKiB5MSxcbiAgICAgICAgICAgICAgICAgICAgYyA9IHkxIC0geTAsXG4gICAgICAgICAgICAgICAgICAgIFRPTEVSQU5DRSA9IDAuMDAwMDEsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCBUT0xFUkFOQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAxIC0gVE9MRVJBTkNFKTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0Q3VydmUodik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHJvb3RzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEN1cnZlKHBhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEN1cnZlKHBhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRDdXJ2ZShwYXJ0c1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtb25vQ3VydmVzKSB7XG4gICAgICAgICAgICBtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG4gICAgICAgICAgICAgICAgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBoYW5kbGVDdXJ2ZShjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jbG9zZWQgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcbiAgICAgICAgICAgICAgICAgICAgcDIgPSBzZWdtZW50c1swXS5fcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHAxeCA9IHAxLl94LCBwMXkgPSBwMS5feSxcbiAgICAgICAgICAgICAgICAgICAgcDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuICAgICAgICAgICAgICAgIGhhbmRsZUN1cnZlKFtwMXgsIHAxeSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwMngsIHAyeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vbm9DdXJ2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IG1vbm9DdXJ2ZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBtb25vQ3VydmVzW21vbm9DdXJ2ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgZmlyc3QucHJldmlvdXMgPSBsYXN0O1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dCA9IGZpcnN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb25vQ3VydmVzO1xuICAgIH0sXG5cbiAgICBnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgICBwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgICAgIHZhciBjdXJ2ZXMgPSB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG4gICAgICAgICAgICAgICAgcm9vdHMgPSBbXSxcbiAgICAgICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgICAgICB4SW50ZXJjZXB0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgeEludGVyY2VwdHMucHVzaChDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS54KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHhJbnRlcmNlcHRzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG5cbiAgICByZW9yaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0Q2xvY2t3aXNlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxuQ29tcG91bmRQYXRoLmluamVjdCh7XG4gICAgX2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcbiAgICAgICAgICAgIG1vbm9DdXJ2ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBtb25vQ3VydmVzLnB1c2guYXBwbHkobW9ub0N1cnZlcywgY2hpbGRyZW5baV0uX2dldE1vbm9DdXJ2ZXMoKSk7XG4gICAgICAgIHJldHVybiBtb25vQ3VydmVzO1xuICAgIH0sXG5cbiAgICByZW9yaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKSAtIGEuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgIHZhciBjbG9ja3dpc2UgPSBjaGlsZHJlblswXS5pc0Nsb2Nrd2lzZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGNoaWxkcmVuW2ldLmdldEludGVyaW9yUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBjb3VudGVycyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2pdLmNvbnRhaW5zKHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldENsb2Nrd2lzZShjb3VudGVycyAlIDIgPT09IDAgJiYgY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxudmFyIFBhdGhJdGVyYXRvciA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdQYXRoSXRlcmF0b3InLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgbWF4UmVjdXJzaW9uLCB0b2xlcmFuY2UsIG1hdHJpeCkge1xuICAgICAgICB2YXIgY3VydmVzID0gW10sIFxuICAgICAgICAgICAgcGFydHMgPSBbXSwgXG4gICAgICAgICAgICBsZW5ndGggPSAwLCBcbiAgICAgICAgICAgIG1pbkRpZmZlcmVuY2UgPSAxIC8gKG1heFJlY3Vyc2lvbiB8fCAzMiksXG4gICAgICAgICAgICBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuICAgICAgICAgICAgc2VnbWVudDEgPSBzZWdtZW50c1swXSxcbiAgICAgICAgICAgIHNlZ21lbnQyO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcbiAgICAgICAgICAgIGN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgICAgICAgIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgaW5kZXgsIG1pblQsIG1heFQpIHtcbiAgICAgICAgICAgIGlmICgobWF4VCAtIG1pblQpID4gbWluRGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCB0b2xlcmFuY2UgfHwgMC4yNSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUpLFxuICAgICAgICAgICAgICAgICAgICBoYWxmVCA9IChtaW5UICsgbWF4VCkgLyAyO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVQYXJ0cyhzcGxpdFswXSwgaW5kZXgsIG1pblQsIGhhbGZUKTtcbiAgICAgICAgICAgICAgICBjb21wdXRlUGFydHMoc3BsaXRbMV0sIGluZGV4LCBoYWxmVCwgbWF4VCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1heFQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuICAgICAgICAgICAgc2VnbWVudDEgPSBzZWdtZW50MjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5fY2xvc2VkKVxuICAgICAgICAgICAgYWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblxuICAgICAgICB0aGlzLmN1cnZlcyA9IGN1cnZlcztcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfSxcblxuICAgIGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIGksIGogPSB0aGlzLmluZGV4O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGlmIChqID09IDAgfHwgdGhpcy5wYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5wYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lm9mZnNldCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsID0gcHJldiAmJiBwcmV2LmluZGV4ID09IHBhcnQuaW5kZXggPyBwcmV2LnZhbHVlIDogMCxcbiAgICAgICAgICAgICAgICAgICAgcHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAqIChvZmZzZXQgLSBwcmV2TGVuKSAvIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFydC5pbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSB0aGlzLnBhcnRzW3RoaXMucGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgICAgIGluZGV4OiBwYXJ0LmluZGV4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihvZmZzZXQsIHR5cGUpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuICAgICAgICByZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS52YWx1ZSwgdHlwZSk7XG4gICAgfSxcblxuICAgIGRyYXdQYXJ0OiBmdW5jdGlvbihjdHgsIGZyb20sIHRvKSB7XG4gICAgICAgIGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuICAgICAgICB0byA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQodG8pO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbS5pbmRleDsgaSA8PSB0by5pbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VydmUgPSBDdXJ2ZS5nZXRQYXJ0KHRoaXMuY3VydmVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcbiAgICAgICAgICAgICAgICAgICAgaSA9PSB0by5pbmRleCA/IHRvLnZhbHVlIDogMSk7XG4gICAgICAgICAgICBpZiAoaSA9PSBmcm9tLmluZGV4KVxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuICAgICAgICB9XG4gICAgfVxufSwgQmFzZS5lYWNoKFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ10sXG4gICAgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlKG9mZnNldCwgaW5kZXgpO1xuICAgICAgICB9O1xuICAgIH0sIHt9KVxuKTtcblxudmFyIFBhdGhGaXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG4gICAgICAgICAgICBwcmV2O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gc2VnbWVudHNbaV0ucG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICAgICAgcHJldiA9IHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9LFxuXG4gICAgZml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDAgPyBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV0gOiBbXTtcbiAgICAgICAgaWYgKGxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmZpdEN1YmljKDAsIGxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgcG9pbnRzWzFdLnN1YnRyYWN0KHBvaW50c1swXSkubm9ybWFsaXplKCksXG4gICAgICAgICAgICAgICAgcG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50cztcbiAgICB9LFxuXG4gICAgZml0Q3ViaWM6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB0YW4xLCB0YW4yKSB7XG4gICAgICAgIGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuICAgICAgICAgICAgdmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcbiAgICAgICAgICAgICAgICBwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuICAgICAgICAgICAgdGhpcy5hZGRDdXJ2ZShbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGRpc3QpKSxcbiAgICAgICAgICAgICAgICAgICAgcHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1UHJpbWUgPSB0aGlzLmNob3JkTGVuZ3RoUGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0KSxcbiAgICAgICAgICAgIG1heEVycm9yID0gTWF0aC5tYXgodGhpcy5lcnJvciwgdGhpcy5lcnJvciAqIHRoaXMuZXJyb3IpLFxuICAgICAgICAgICAgc3BsaXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcbiAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG4gICAgICAgICAgICBpZiAobWF4LmVycm9yIDwgdGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VydmUoY3VydmUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGl0ID0gbWF4LmluZGV4O1xuICAgICAgICAgICAgaWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuICAgICAgICAgICAgbWF4RXJyb3IgPSBtYXguZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFYxID0gdGhpcy5wb2ludHNbc3BsaXQgLSAxXS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdF0pLFxuICAgICAgICAgICAgVjIgPSB0aGlzLnBvaW50c1tzcGxpdF0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXQgKyAxXSksXG4gICAgICAgICAgICB0YW5DZW50ZXIgPSBWMS5hZGQoVjIpLmRpdmlkZSgyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGhpcy5maXRDdWJpYyhmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG4gICAgICAgIHRoaXMuZml0Q3ViaWMoc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG4gICAgfSxcblxuICAgIGFkZEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSAxZS0xMSxcbiAgICAgICAgICAgIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcbiAgICAgICAgICAgIHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuICAgICAgICAgICAgQyA9IFtbMCwgMF0sIFswLCAwXV0sXG4gICAgICAgICAgICBYID0gWzAsIDBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHUgPSB1UHJpbWVbaV0sXG4gICAgICAgICAgICAgICAgdCA9IDEgLSB1LFxuICAgICAgICAgICAgICAgIGIgPSAzICogdSAqIHQsXG4gICAgICAgICAgICAgICAgYjAgPSB0ICogdCAqIHQsXG4gICAgICAgICAgICAgICAgYjEgPSBiICogdCxcbiAgICAgICAgICAgICAgICBiMiA9IGIgKiB1LFxuICAgICAgICAgICAgICAgIGIzID0gdSAqIHUgKiB1LFxuICAgICAgICAgICAgICAgIGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuICAgICAgICAgICAgICAgIGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMucG9pbnRzW2ZpcnN0ICsgaV1cbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHB0MS5tdWx0aXBseShiMCArIGIxKSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG4gICAgICAgICAgICBDWzBdWzBdICs9IGExLmRvdChhMSk7XG4gICAgICAgICAgICBDWzBdWzFdICs9IGExLmRvdChhMik7XG4gICAgICAgICAgICBDWzFdWzBdID0gQ1swXVsxXTtcbiAgICAgICAgICAgIENbMV1bMV0gKz0gYTIuZG90KGEyKTtcbiAgICAgICAgICAgIFhbMF0gKz0gYTEuZG90KHRtcCk7XG4gICAgICAgICAgICBYWzFdICs9IGEyLmRvdCh0bXApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRldEMwQzEgPSBDWzBdWzBdICogQ1sxXVsxXSAtIENbMV1bMF0gKiBDWzBdWzFdLFxuICAgICAgICAgICAgYWxwaGExLCBhbHBoYTI7XG4gICAgICAgIGlmIChNYXRoLmFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBkZXRDMFggID0gQ1swXVswXSAqIFhbMV0gICAgLSBDWzFdWzBdICogWFswXSxcbiAgICAgICAgICAgICAgICBkZXRYQzEgID0gWFswXSAgICAqIENbMV1bMV0gLSBYWzFdICAgICogQ1swXVsxXTtcbiAgICAgICAgICAgIGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG4gICAgICAgICAgICBhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGMwID0gQ1swXVswXSArIENbMF1bMV0sXG4gICAgICAgICAgICAgICAgYzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhjMCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgYWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgYWxwaGExID0gYWxwaGEyID0gWFsxXSAvIGMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYTEgPSBhbHBoYTIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpO1xuICAgICAgICBlcHNpbG9uICo9IHNlZ0xlbmd0aDtcbiAgICAgICAgaWYgKGFscGhhMSA8IGVwc2lsb24gfHwgYWxwaGEyIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgYWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuICAgICAgICAgICAgICAgIHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG4gICAgfSxcblxuICAgIHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdVtpIC0gZmlyc3RdID0gdGhpcy5maW5kUm9vdChjdXJ2ZSwgdGhpcy5wb2ludHNbaV0sIHVbaSAtIGZpcnN0XSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuICAgICAgICB2YXIgY3VydmUxID0gW10sXG4gICAgICAgICAgICBjdXJ2ZTIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuICAgICAgICAgICAgY3VydmUyW2ldID0gY3VydmUxW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZTFbaV0pLm11bHRpcGx5KDIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuICAgICAgICAgICAgcHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuICAgICAgICAgICAgcHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuICAgICAgICAgICAgZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcbiAgICAgICAgICAgIGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRmKSA8IDAuMDAwMDEpXG4gICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgcmV0dXJuIHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG4gICAgfSxcblxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG4gICAgICAgIHZhciB0bXAgPSBjdXJ2ZS5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG1wW2pdID0gdG1wW2pdLm11bHRpcGx5KDEgLSB0KS5hZGQodG1wW2ogKyAxXS5tdWx0aXBseSh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRtcFswXTtcbiAgICB9LFxuXG4gICAgY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0KSB7XG4gICAgICAgIHZhciB1ID0gWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuICAgICAgICAgICAgICAgICAgICArIHRoaXMucG9pbnRzW2ldLmdldERpc3RhbmNlKHRoaXMucG9pbnRzW2kgLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG4gICAgICAgICAgICB1W2ldIC89IHVbbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgfSxcblxuICAgIGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG4gICAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IoKGxhc3QgLSBmaXJzdCArIDEpIC8gMiksXG4gICAgICAgICAgICBtYXhEaXN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgdmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuICAgICAgICAgICAgdmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55OyBcbiAgICAgICAgICAgIGlmIChkaXN0ID49IG1heERpc3QpIHtcbiAgICAgICAgICAgICAgICBtYXhEaXN0ID0gZGlzdDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBtYXhEaXN0LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdUZXh0SXRlbScsXG4gICAgX2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuICAgIF9hcHBseU1hdHJpeDogZmFsc2UsXG4gICAgX2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcbiAgICBfc2VyaWFsaXplRmllbGRzOiB7XG4gICAgICAgIGNvbnRlbnQ6IG51bGxcbiAgICB9LFxuICAgIF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSAnJztcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG4gICAgICAgICAgICAgICAgJiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG4gICAgfSxcblxuICAgIF9jbG9uZTogZnVuY3Rpb24gX2Nsb25lKGNvcHkpIHtcbiAgICAgICAgY29weS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICByZXR1cm4gX2Nsb25lLmJhc2UuY2FsbCh0aGlzLCBjb3B5KTtcbiAgICB9LFxuXG4gICAgZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH0sXG5cbiAgICBzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKDI2NSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG4gICAgfSxcblxuICAgIGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcbiAgICBzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cbiAgICBnZXRQYXJhZ3JhcGhTdHlsZTogJyNnZXRTdHlsZScsXG4gICAgc2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50VGV4dCgpIHtcbiAgICAgICAgVGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmUobmV3IFBvaW50VGV4dChJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG4gICAgfSxcblxuICAgIGdldFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG4gICAgfSxcblxuICAgIHNldFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuICAgIH0sXG5cbiAgICBfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2V0U3R5bGVzKGN0eCk7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuICAgICAgICAgICAgbGluZXMgPSB0aGlzLl9saW5lcyxcbiAgICAgICAgICAgIGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG4gICAgICAgICAgICBzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcbiAgICAgICAgY3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy5fbGluZXMsXG4gICAgICAgICAgICBudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgIGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG4gICAgICAgICAgICBsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuICAgICAgICAgICAgeCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuICAgICAgICB2YXIgYm91bmRzID0gbmV3IFJlY3RhbmdsZSh4LFxuICAgICAgICAgICAgICAgICAgICBudW1MaW5lcyA/IC0gMC43NSAqIGxlYWRpbmcgOiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgYm91bmRzKSA6IGJvdW5kcztcbiAgICB9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlcyA9IHtcbiAgICAgICAgZ3JheTogWydncmF5J10sXG4gICAgICAgIHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuICAgICAgICBoc2I6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnYnJpZ2h0bmVzcyddLFxuICAgICAgICBoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG4gICAgICAgIGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuICAgIH07XG5cbiAgICB2YXIgY29tcG9uZW50UGFyc2VycyA9IHt9LFxuICAgICAgICBjb2xvckNhY2hlID0ge30sXG4gICAgICAgIGNvbG9yQ3R4O1xuXG4gICAgZnVuY3Rpb24gZnJvbUNTUyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuICAgICAgICAgICAgY29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gK2NvbXBvbmVudHNbaV07XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IGkgPCAzID8gdmFsdWUgLyAyNTUgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ107XG4gICAgICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmICghY29sb3JDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbG9yQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgICAgICAgICBjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgY29sb3JDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjb2xvckN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMF0gLyAyNTUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMV0gLyAyNTUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbMl0gLyAyNTVcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cyA9IGNhY2hlZC5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cblxuICAgIHZhciBoc2JJbmRpY2VzID0gW1xuICAgICAgICBbMCwgMywgMV0sIFxuICAgICAgICBbMiwgMCwgMV0sIFxuICAgICAgICBbMSwgMCwgM10sIFxuICAgICAgICBbMSwgMiwgMF0sIFxuICAgICAgICBbMywgMSwgMF0sIFxuICAgICAgICBbMCwgMSwgMl0gIFxuICAgIF07XG5cbiAgICB2YXIgY29udmVydGVycyA9IHtcbiAgICAgICAgJ3JnYi1oc2InOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICAgICAgaCA9IGRlbHRhID09PSAwID8gMFxuICAgICAgICAgICAgICAgICAgICA6ICAgKCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogICAgICAgICAgICAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwOyBcbiAgICAgICAgICAgIHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuICAgICAgICB9LFxuXG4gICAgICAgICdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuICAgICAgICAgICAgaCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcbiAgICAgICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihoKSwgXG4gICAgICAgICAgICAgICAgZiA9IGggLSBpLFxuICAgICAgICAgICAgICAgIGkgPSBoc2JJbmRpY2VzW2ldLFxuICAgICAgICAgICAgICAgIHYgPSBbXG4gICAgICAgICAgICAgICAgICAgIGIsICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBiICogKDEgLSBzKSwgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYiAqICgxIC0gcyAqIGYpLCAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGIgKiAoMSAtIHMgKiAoMSAtIGYpKSAgIFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuICAgICAgICB9LFxuXG4gICAgICAgICdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgICAgICAgIGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcbiAgICAgICAgICAgICAgICBoID0gYWNocm9tYXRpYyA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCwgXG4gICAgICAgICAgICAgICAgbCA9IChtYXggKyBtaW4pIC8gMixcbiAgICAgICAgICAgICAgICBzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRlbHRhIC8gKG1heCArIG1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gW2gsIHMsIGxdO1xuICAgICAgICB9LFxuXG4gICAgICAgICdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuICAgICAgICAgICAgaCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG4gICAgICAgICAgICBpZiAocyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIGwsIGxdO1xuICAgICAgICAgICAgdmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcbiAgICAgICAgICAgICAgICB0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgICAgICAgdDEgPSAyICogbCAtIHQyLFxuICAgICAgICAgICAgICAgIGMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQzID0gdDNzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0MyA8IDApIHQzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKHQzID4gMSkgdDMgLT0gMTtcbiAgICAgICAgICAgICAgICBjW2ldID0gNiAqIHQzIDwgMVxuICAgICAgICAgICAgICAgICAgICA/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG4gICAgICAgICAgICAgICAgICAgIDogMiAqIHQzIDwgMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0MlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAzICogdDMgPCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSxcblxuICAgICAgICAncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuICAgICAgICB9LFxuXG4gICAgICAgICdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgIHJldHVybiBbZywgZywgZ107XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ2dyYXktaHNiJzogZnVuY3Rpb24oZykge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAwLCBnXTtcbiAgICAgICAgfSxcblxuICAgICAgICAnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICByZXR1cm4gWzAsIDAsIGddO1xuICAgICAgICB9LFxuXG4gICAgICAgICdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICAncmdiLWdyYWRpZW50JzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICByZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG4gICAgICAgIGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgQmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcbiAgICAgICAgICAgICAgICBoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IG5hbWUgPT09ICdncmFkaWVudCdcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlID09PSAnZ3JhZGllbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZE51bGw6IG5hbWUgPT09ICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuICAgICAgICAgICAgICAgICAgICB8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSwge1xuICAgICAgICBfY2xhc3M6ICdDb2xvcicsXG4gICAgICAgIF9yZWFkSW5kZXg6IHRydWUsXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICByZWFkID0gMCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgYWxwaGEsXG4gICAgICAgICAgICAgICAgdmFsdWVzO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmc7XG4gICAgICAgICAgICAgICAgYXJnID0gYXJnc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcbiAgICAgICAgICAgIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gYXJnO1xuICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gYXJnO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCA9IDE7IFxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gc2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2YWx1ZXMubGVuZ3RoID49IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAncmdiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdncmF5JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHR5cGVzW3R5cGVdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gc2xpY2UuY2FsbCh2YWx1ZXMsIDAsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3JnYic7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMgPSBmcm9tQ1NTKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBjb21wb25lbnRzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBhcmcuX3R5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFyZy5fYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnaHVlJyBpbiBhcmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdsaWdodG5lc3MnIGluIGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdoc2wnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2hzYidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAncmFkaWFsJyBpbiBhcmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZ3JhZGllbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2dyYXknIGluIGFyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZ3JheSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3JnYic7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgaSA9PT0gMCAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAnc3RvcHMnIGluIGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BzOiBhcmcuc3RvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpYWw6IGFyZy5yYWRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGFyZy5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3JlYWQgJiYgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZ3JhZGllbnQnKVxuICAgICAgICAgICAgICAgIHRoaXMuX2lkID0gQ29sb3IuX2lkID0gKENvbG9yLl9pZCB8fCAwKSArIDE7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IGFscGhhO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19yZWFkKVxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWFkID0gcmVhZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuICAgICAgICAgICAgICAgICAgICAvXihncmF5fHJnYikkLy50ZXN0KHRoaXMuX3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3RoaXMuX3R5cGVdLmNvbmNhdChjb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzU3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfY29udmVydDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFzQWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgdmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICA/IENvbG9yLnJlYWQoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbG9yO1xuICAgICAgICAgICAgcmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuX2FscGhhID09PSBjb2wuX2FscGhhXG4gICAgICAgICAgICAgICAgICAgICYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgfHwgZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgaXNHcmFkaWVudCA9IHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcsXG4gICAgICAgICAgICAgICAgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoaXNHcmFkaWVudCA/IHZhbHVlIDogZi5udW1iZXIodmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG4gICAgICAgICAgICByZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG4gICAgICAgICAgICAgICAgYWxwaGEgPSBoZXggfHwgdGhpcy5fYWxwaGEgPT0gbnVsbCA/IDEgOiB0aGlzLl9hbHBoYTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMgPSBbXG4gICAgICAgICAgICAgICAgY29udmVydChjb21wb25lbnRzWzBdKSxcbiAgICAgICAgICAgICAgICBjb252ZXJ0KGNvbXBvbmVudHNbMV0pLFxuICAgICAgICAgICAgICAgIGNvbnZlcnQoY29tcG9uZW50c1syXSlcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoYWxwaGEgPCAxKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIGhleFxuICAgICAgICAgICAgICAgICAgICA/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbXBvbmVudHNbMV0gPDwgOClcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgICAgIDogKGNvbXBvbmVudHMubGVuZ3RoID09IDQgPyAncmdiYSgnIDogJ3JnYignKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb21wb25lbnRzLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSxcblxuICAgICAgICB0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXNTdHlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50JylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuICAgICAgICAgICAgICAgIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuICAgICAgICAgICAgICAgIGNhbnZhc0dyYWRpZW50O1xuICAgICAgICAgICAgaWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gZGVzdGluYXRpb24uZ2V0RGlzdGFuY2Uob3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXTtcbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgMCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICAgICAgICBjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5fcmFtcFBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgICAgIF90eXBlczogdHlwZXMsXG5cbiAgICAgICAgICAgIHJhbmRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgfSxcblxuICAgICAgICBzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbHBoYSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICB9O1xuICAgIH0sIHtcbiAgICB9KTtcbn0pO1xuXG5CYXNlLmVhY2goQ29sb3IuX3R5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG4gICAgdmFyIGN0b3IgPSB0aGlzW0Jhc2UuY2FwaXRhbGl6ZSh0eXBlKSArICdDb2xvciddID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICB2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmcsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGFyZ1xuICAgICAgICAgICAgICAgICAgICA6IGFyZ1R5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgQ29sb3IoYXJnKTtcbiAgICAgICAgfTtcbiAgICBpZiAodHlwZS5sZW5ndGggPT0gMykge1xuICAgICAgICB2YXIgYWNyb255bSA9IHR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgQ29sb3JbYWNyb255bV0gPSB0aGlzW2Fjcm9ueW0gKyAnQ29sb3InXSA9IGN0b3I7XG4gICAgfVxufSwgQmFzZS5leHBvcnRzKTtcblxudmFyIEdyYWRpZW50ID0gQmFzZS5leHRlbmQoe1xuICAgIF9jbGFzczogJ0dyYWRpZW50JyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcbiAgICAgICAgdGhpcy5faWQgPSBHcmFkaWVudC5faWQgPSAoR3JhZGllbnQuX2lkIHx8IDApICsgMTtcbiAgICAgICAgaWYgKHN0b3BzICYmIHRoaXMuX3NldChzdG9wcykpXG4gICAgICAgICAgICBzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fc3RvcHMpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpYWwgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0UmFkaWFsKHR5cGVvZiByYWRpYWwgPT09ICdzdHJpbmcnICYmIHJhZGlhbCA9PT0gJ3JhZGlhbCdcbiAgICAgICAgICAgICAgICAgICAgfHwgcmFkaWFsIHx8IGZhbHNlKTtcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgICByZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX3N0b3BzLCB0aGlzLl9yYWRpYWxdLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3duZXJzKVxuICAgICAgICAgICAgdGhpcy5fb3duZXJzID0gW107XG4gICAgICAgIHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9vd25lcnMgPyB0aGlzLl9vd25lcnMuaW5kZXhPZihjb2xvcikgOiAtMTtcbiAgICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdG9wcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcyk7XG4gICAgfSxcblxuICAgIGdldFN0b3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BzO1xuICAgIH0sXG5cbiAgICBzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcbiAgICAgICAgdGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZEFsbChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5fc3RvcHNbaV07XG4gICAgICAgICAgICBzdG9wLl9vd25lciA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc3RvcC5fZGVmYXVsdFJhbXApXG4gICAgICAgICAgICAgICAgc3RvcC5zZXRSYW1wUG9pbnQoaSAvIChsIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGlhbDtcbiAgICB9LFxuXG4gICAgc2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcbiAgICAgICAgdGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcbiAgICAgICAgaWYgKGdyYWRpZW50ID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChncmFkaWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gZ3JhZGllbnQuX2NsYXNzXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcHNbaV0uZXF1YWxzKGdyYWRpZW50Ll9zdG9wc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcblxudmFyIEdyYWRpZW50U3RvcCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgaWYgKGFyZzApIHtcbiAgICAgICAgICAgIHZhciBjb2xvciwgcmFtcFBvaW50O1xuICAgICAgICAgICAgaWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBhcmcwWzBdO1xuICAgICAgICAgICAgICAgIHJhbXBQb2ludCA9IGFyZzBbMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAuY29sb3IpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGFyZzAuY29sb3I7XG4gICAgICAgICAgICAgICAgcmFtcFBvaW50ID0gYXJnMC5yYW1wUG9pbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gYXJnMDtcbiAgICAgICAgICAgICAgICByYW1wUG9pbnQgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDb2xvcihjb2xvcik7XG4gICAgICAgICAgICB0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuICAgICAgICByZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NvbG9yLCB0aGlzLl9yYW1wUG9pbnRdLCBvcHRpb25zLCB0cnVlLFxuICAgICAgICAgICAgICAgIGRpY3Rpb25hcnkpO1xuICAgIH0sXG5cbiAgICBfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9vd25lcilcbiAgICAgICAgICAgIHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcbiAgICB9LFxuXG4gICAgZ2V0UmFtcFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhbXBQb2ludDtcbiAgICB9LFxuXG4gICAgc2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFJhbXAgPSByYW1wUG9pbnQgPT0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmFtcFBvaW50ID0gcmFtcFBvaW50IHx8IDA7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgfSxcblxuICAgIHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICB0aGlzLl9jb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yID09PSBjb2xvcilcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yID0gY29sb3IuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3NcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5fcmFtcFBvaW50ID09IHN0b3AuX3JhbXBQb2ludFxuICAgICAgICAgICAgICAgIHx8IGZhbHNlO1xuICAgIH1cbn0pO1xuXG52YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBmaWxsQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgc3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZUNhcDogJ2J1dHQnLFxuICAgICAgICBzdHJva2VKb2luOiAnbWl0ZXInLFxuICAgICAgICBzdHJva2VTY2FsaW5nOiB0cnVlLFxuICAgICAgICBtaXRlckxpbWl0OiAxMCxcbiAgICAgICAgZGFzaE9mZnNldDogMCxcbiAgICAgICAgZGFzaEFycmF5OiBbXSxcbiAgICAgICAgd2luZGluZ1J1bGU6ICdub256ZXJvJyxcbiAgICAgICAgc2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgc2hhZG93Qmx1cjogMCxcbiAgICAgICAgc2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcbiAgICAgICAgc2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnQ6ICdzYW5zLXNlcmlmJywgXG4gICAgICAgIGxlYWRpbmc6IG51bGwsXG4gICAgICAgIGp1c3RpZmljYXRpb246ICdsZWZ0J1xuICAgIH07XG5cbiAgICB2YXIgZmxhZ3MgPSB7XG4gICAgICAgIHN0cm9rZVdpZHRoOiA5NyxcbiAgICAgICAgc3Ryb2tlQ2FwOiA5NyxcbiAgICAgICAgc3Ryb2tlSm9pbjogOTcsXG4gICAgICAgIHN0cm9rZVNjYWxpbmc6IDEwNSxcbiAgICAgICAgbWl0ZXJMaW1pdDogOTcsXG4gICAgICAgIGZvbnRGYW1pbHk6IDksXG4gICAgICAgIGZvbnRXZWlnaHQ6IDksXG4gICAgICAgIGZvbnRTaXplOiA5LFxuICAgICAgICBmb250OiA5LCBcbiAgICAgICAgbGVhZGluZzogOSxcbiAgICAgICAganVzdGlmaWNhdGlvbjogOVxuICAgIH07XG5cbiAgICB2YXIgaXRlbSA9IHsgYmVhbnM6IHRydWUgfSxcbiAgICAgICAgZmllbGRzID0ge1xuICAgICAgICAgICAgX2RlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICAgIF90ZXh0RGVmYXVsdHM6IG5ldyBCYXNlKGRlZmF1bHRzLCB7XG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBuZXcgQ29sb3IoKSBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmVhbnM6IHRydWVcbiAgICAgICAgfTtcblxuICAgIEJhc2UuZWFjaChkZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICB2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcbiAgICAgICAgICAgIGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuICAgICAgICAgICAgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2tleV0sXG4gICAgICAgICAgICBzZXQgPSAnc2V0JyArIHBhcnQsXG4gICAgICAgICAgICBnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cbiAgICAgICAgZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob2xkICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5fb3duZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLl9vd25lcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl9vd25lciA9IG93bmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvd25lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgX2RvbnRNZXJnZVxuICAgICAgICAgICAgICAgICAgICB8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdG9yID0gaXNDb2xvciA/IENvbG9yIDogaXNQb2ludCA/IFBvaW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyByZWFkTnVsbDogdHJ1ZSwgY2xvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgaXNDb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fb3duZXIgPSBvd25lcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFZhbHVlID0gY2hpbGRyZW5baV0uX3N0eWxlW2dldF0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHlsZVtnZXRdKF9kb250TWVyZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGl0ZW1bc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZVtzZXRdKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIEl0ZW0uaW5qZWN0KGl0ZW0pO1xuICAgIHJldHVybiBmaWVsZHM7XG59LCB7XG4gICAgX2NsYXNzOiAnU3R5bGUnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX293bmVyID0gX293bmVyO1xuICAgICAgICB0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuICAgICAgICBpZiAoX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0pXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0cyA9IHRoaXMuX3RleHREZWZhdWx0cztcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgdGhpcy5zZXQoc3R5bGUpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHZhciBpc1N0eWxlID0gc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSxcbiAgICAgICAgICAgIHZhbHVlcyA9IGlzU3R5bGUgPyBzdHlsZS5fdmFsdWVzIDogc3R5bGU7XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlID09PSB0aGlzIHx8IHN0eWxlICYmIHRoaXMuX2NsYXNzID09PSBzdHlsZS5fY2xhc3NcbiAgICAgICAgICAgICAgICAmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG4gICAgICAgICAgICAgICAgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZpbGxDb2xvcigpO1xuICAgIH0sXG5cbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcbiAgICB9LFxuXG4gICAgaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRTaGFkb3dDb2xvcigpICYmIHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMDtcbiAgICB9LFxuXG4gICAgZ2V0VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0LmdldFZpZXcoKTtcbiAgICB9LFxuXG4gICAgZ2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb250V2VpZ2h0KClcbiAgICAgICAgICAgICAgICArICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcbiAgICAgICAgICAgICAgICArIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuICAgIH0sXG5cbiAgICBnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuICAgIHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cbiAgICBnZXRMZWFkaW5nOiBmdW5jdGlvbiBnZXRMZWFkaW5nKCkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgIGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG4gICAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG4gICAgICAgIHJldHVybiBsZWFkaW5nICE9IG51bGwgPyBsZWFkaW5nIDogZm9udFNpemUgKiAxLjI7XG4gICAgfVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcbiAgICAgICAgICAgIHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldLFxuICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgICAgICAgICBlbFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0U3R5bGVzOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IGVsICYmIGVsLm5vZGVUeXBlICE9PSA5ID8gZWwub3duZXJEb2N1bWVudCA6IGVsLFxuICAgICAgICAgICAgICAgIHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgICAgICBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICByZWN0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuICAgICAgICAgICAgICAgIHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcbiAgICAgICAgICAgIGlmICghdmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IGRvYy5kZWZhdWx0VmlldztcbiAgICAgICAgICAgICAgICB4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuICAgICAgICAgICAgICAgIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcbiAgICAgICAgICAgICAgICB2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG4gICAgICAgICAgICAgICAgICAgICYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQcmVmaXgoZWwsIGtleSwgdHJ1ZSwgbmFtZVtrZXldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuICAgIGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG4gICAgICAgICAgICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFBvaW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlc1xuICAgICAgICAgICAgICAgID8gZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdXG4gICAgICAgICAgICAgICAgICAgIDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cbiAgICAgICAgICAgICAgICA6IGV2ZW50O1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgcG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgIH0sXG5cbiAgICBnZXRSZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG4gICAgfSxcblxuICAgIGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gRG9tRXZlbnQuZ2V0UG9pbnQoZXZlbnQpLnN1YnRyYWN0KERvbUVsZW1lbnQuZ2V0T2Zmc2V0KFxuICAgICAgICAgICAgICAgIHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmF0aXZlUmVxdWVzdCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuICAgICAgICByZXF1ZXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgY2FsbGJhY2tzID0gW10sXG4gICAgICAgIGZvY3VzZWQgPSB0cnVlLFxuICAgICAgICB0aW1lcjtcblxuICAgIGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHtcbiAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibHVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGNhbGxiYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gY2FsbGJhY2tzW2ldLFxuICAgICAgICAgICAgICAgIGZ1bmMgPSBlbnRyeVswXSxcbiAgICAgICAgICAgICAgICBlbCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgaWYgKCFlbCB8fCAoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoZWwsICdrZWVwYWxpdmUnKSA9PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgfHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKFtjYWxsYmFjaywgZWxlbWVudF0pO1xuICAgICAgICBpZiAobmF0aXZlUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuICAgIF9jbGFzczogJ1ZpZXcnLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gVmlldyhwcm9qZWN0LCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdmFyIHNpemU7XG4gICAgICAgIGlmICggIW5vQ2FudmFzICkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuICAgICAgICAgICAgICAgIHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuICAgICAgICAgICAgRG9tRXZlbnQuYWRkKGVsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuICAgICAgICAgICAgdmFyIG5vbmUgPSAnbm9uZSc7XG4gICAgICAgICAgICBEb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiBub25lLFxuICAgICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiBub25lLFxuICAgICAgICAgICAgICAgIHRvdWNoQ2FsbG91dDogbm9uZSxcbiAgICAgICAgICAgICAgICBjb250ZW50Wm9vbWluZzogbm9uZSxcbiAgICAgICAgICAgICAgICB1c2VyRHJhZzogbm9uZSxcbiAgICAgICAgICAgICAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNpemUgPSBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0U2l6ZSgpLnN1YnRyYWN0KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2luZG93RXZlbnRzID0ge1xuICAgICAgICAgICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRWaWV3U2l6ZShEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRTaXplKCkuc3VidHJhY3Qob2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIERvbUV2ZW50LmFkZCh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRTaXplID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcbiAgICAgICAgICAgIGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAnc3RhdHMnKVxuICAgICAgICAgICAgICAgICAgICAmJiB0eXBlb2YgU3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0YXRzLnN0eWxlLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG4gICAgICAgICAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgICAgICB0aGlzLl9pZCA9ICd2aWV3LScgKyBWaWV3Ll9pZCsrO1xuICAgICAgICAgICAgc2l6ZSA9IG5ldyBTaXplKGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuICAgICAgICBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmlld1NpemUgPSBzaXplO1xuICAgICAgICAodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLl96b29tID0gMTtcbiAgICAgICAgaWYgKCFWaWV3Ll9mb2N1c2VkKVxuICAgICAgICAgICAgVmlldy5fZm9jdXNlZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb2plY3QpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuICAgICAgICAgICAgVmlldy5fZm9jdXNlZCA9IG51bGw7XG4gICAgICAgIFZpZXcuX3ZpZXdzLnNwbGljZShWaWV3Ll92aWV3cy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICAgICAgZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG4gICAgICAgIGlmICh0aGlzLl9wcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy5fcHJvamVjdC5fdmlldyA9IG51bGw7XG4gICAgICAgIERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcbiAgICAgICAgRG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuICAgICAgICB0aGlzLm9mZignZnJhbWUnKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mcmFtZUl0ZW1zID0ge307XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBfZXZlbnRzOiB7XG4gICAgICAgIG9uRnJhbWU6IHtcbiAgICAgICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNpemU6IHt9XG4gICAgfSxcblxuICAgIF9hbmltYXRlOiBmYWxzZSxcbiAgICBfdGltZTogMCxcbiAgICBfY291bnQ6IDAsXG5cbiAgICBfcmVxdWVzdEZyYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBEb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhhdC5fYW5pbWF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGF0Ll9yZXF1ZXN0RnJhbWUoKTtcbiAgICAgICAgICAgIHRoYXQuX2hhbmRsZUZyYW1lKCk7XG4gICAgICAgIH0sIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXBlciA9IHRoaXMuX3Njb3BlO1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDAsXG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMuX2JlZm9yZSA/IG5vdyAtIHRoaXMuX2JlZm9yZSA6IDA7XG4gICAgICAgIHRoaXMuX2JlZm9yZSA9IG5vdztcbiAgICAgICAgdGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnZnJhbWUnLCBuZXcgQmFzZSh7XG4gICAgICAgICAgICBkZWx0YTogZGVsdGEsXG4gICAgICAgICAgICB0aW1lOiB0aGlzLl90aW1lICs9IGRlbHRhLFxuICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NvdW50KytcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdHMpXG4gICAgICAgICAgICB0aGlzLl9zdGF0cy51cGRhdGUoKTtcbiAgICAgICAgdGhpcy5faGFuZGxpbmdGcmFtZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZnJhbWVJdGVtcztcbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICAgIGl0ZW1zW2l0ZW0uX2lkXSA9IHtcbiAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgY291bnQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGl0ZW1zW2l0ZW0uX2lkXTtcbiAgICAgICAgICAgIGlmICgtLXRoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcbiAgICAgICAgICAgIGVudHJ5Lml0ZW0uZW1pdCgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuICAgICAgICAgICAgICAgIHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG4gICAgICAgICAgICAgICAgY291bnQ6IGVudHJ5LmNvdW50KytcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgJiAxKVxuICAgICAgICAgICAgdGhpcy5fcHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fbWF0cml4LmNvbmNhdGVuYXRlKG1hdHJpeCk7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfSxcblxuICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcbiAgICB9LFxuXG4gICAgZ2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG4gICAgfSxcblxuICAgIGdldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuICAgICAgICAgICAgZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcbiAgICAgICAgaWYgKGRlbHRhLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDsgXG4gICAgICAgIHRoaXMuZW1pdCgncmVzaXplJywge1xuICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIGRlbHRhOiBkZWx0YVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSxcblxuICAgIF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBlbGVtZW50LmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2JvdW5kcylcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksIHRoaXMuX3ZpZXdTaXplKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgfSxcblxuICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZHMoKS5nZXRTaXplKCk7XG4gICAgfSxcblxuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuICAgIH0sXG5cbiAgICBzZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KGNlbnRlci5zdWJ0cmFjdCh0aGlzLmdldENlbnRlcigpKSk7XG4gICAgfSxcblxuICAgIGdldFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcbiAgICB9LFxuXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnNjYWxlKHpvb20gLyB0aGlzLl96b29tLFxuICAgICAgICAgICAgdGhpcy5nZXRDZW50ZXIoKSkpO1xuICAgICAgICB0aGlzLl96b29tID0gem9vbTtcbiAgICB9LFxuXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERvbUVsZW1lbnQuaXNJblZpZXcodGhpcy5fZWxlbWVudCk7XG4gICAgfSxcblxuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKSk7XG4gICAgfSxcblxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0ZWQpXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcbiAgICB9LFxuXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgdmlld1RvUHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcbiAgICB9XG5cbn0sIHtcbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIF92aWV3czogW10sXG4gICAgICAgIF92aWV3c0J5SWQ6IHt9LFxuICAgICAgICBfaWQ6IDAsXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihwcm9qZWN0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzVmlldyhwcm9qZWN0LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcbiAgICBpZiAoIG5vQ2FudmFzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvb2wsXG4gICAgICAgIHByZXZGb2N1cyxcbiAgICAgICAgdGVtcEZvY3VzLFxuICAgICAgICBkcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgVmlldy5fdmlld3NCeUlkW3RhcmdldC5nZXRBdHRyaWJ1dGUoJ2lkJyldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVGb2N1cygpIHtcbiAgICAgICAgaWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gVmlldy5fdmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdmlldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCkge1xuICAgICAgICB2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgdmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuICAgICAgICBpZiAodG9vbCkge1xuICAgICAgICAgICAgdG9vbC5faGFuZGxlRXZlbnQoZHJhZ2dpbmcgJiYgdG9vbC5yZXNwb25kcygnbW91c2VkcmFnJylcbiAgICAgICAgICAgICAgICAgICAgPyAnbW91c2VkcmFnJyA6ICdtb3VzZW1vdmUnLCBwb2ludCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcudXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0b29sO1xuICAgIH1cblxuICAgIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuICAgICAgICBtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcbiAgICBpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcbiAgICAgICAgbW91c2Vtb3ZlID0gJ3BvaW50ZXJtb3ZlIE1TUG9pbnRlck1vdmUnO1xuICAgICAgICBtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuICAgICAgICBtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcbiAgICAgICAgbW91c2V1cCA9ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG4gICAgICAgIGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuICAgICAgICAgICAgICAgIC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pKSkpIHtcbiAgICAgICAgICAgIG1vdXNlZG93biArPSAnIG1vdXNlZG93bic7XG4gICAgICAgICAgICBtb3VzZW1vdmUgKz0gJyBtb3VzZW1vdmUnO1xuICAgICAgICAgICAgbW91c2V1cCArPSAnIG1vdXNldXAnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdFdmVudHMgPSB7XG4gICAgICAgICdzZWxlY3RzdGFydCBkcmFnc3RhcnQnOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nKVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRvY0V2ZW50cyA9IHtcbiAgICAgICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG4gICAgICAgICAgICAgICAgaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2Nyb2xsOiB1cGRhdGVGb2N1c1xuICAgIH07XG5cbiAgICB2aWV3RXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcbiAgICAgICAgICAgIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG4gICAgICAgIGRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgdmlldy5faGFuZGxlRXZlbnQoJ21vdXNlZG93bicsIHBvaW50LCBldmVudCk7XG4gICAgICAgIGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcbiAgICAgICAgICAgIHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuICAgICAgICB2aWV3LnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBkb2NFdmVudHNbbW91c2Vtb3ZlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcbiAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh2aWV3ICE9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHByZXZGb2N1cyA9IHZpZXc7XG4gICAgICAgICAgICAgICAgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRlbXBGb2N1cyAmJiB0ZW1wRm9jdXMgPT09IHZpZXcpIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcbiAgICAgICAgICAgICAgICB1cGRhdGVGb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChkcmFnZ2luZyB8fCB2aWV3LmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50KSlcbiAgICAgICAgICAgICAgICB0b29sID0gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuICAgICAgICBpZiAoIXZpZXcgfHwgIWRyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcbiAgICAgICAgZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5faGFuZGxlRXZlbnQoJ21vdXNldXAnLCBwb2ludCwgZXZlbnQpO1xuICAgICAgICBpZiAodG9vbClcbiAgICAgICAgICAgIHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgdmlldy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgRG9tRXZlbnQuYWRkKGRvY3VtZW50LCBkb2NFdmVudHMpO1xuXG4gICAgRG9tRXZlbnQuYWRkKHdpbmRvdywge1xuICAgICAgICBsb2FkOiB1cGRhdGVGb2N1c1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgX3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cbiAgICAgICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgIHN0YXRpY3M6IHtcbiAgICAgICAgICAgIHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdDYW52YXNWaWV3JyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG4gICAgICAgIGlmICggIW5vQ2FudmFzICkge1xuICAgICAgICAgICAgaWYgKCEoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZS5pc1plcm8oKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICAgICAgY2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50Q291bnRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgIGlmICghbm9DYW52YXMgJiYgIS9eb2ZmfGZhbHNlJC8udGVzdChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShjYW52YXMsICdoaWRwaScpKSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IERvbUVsZW1lbnQuZ2V0UHJlZml4ZWQodGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuICAgIH0sXG5cbiAgICBfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW8sXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgICAgZWxlbWVudC53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgICAgZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQaXhlbFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICBwcmV2Rm9udCA9IGN0eC5mb250O1xuICAgICAgICBjdHguZm9udCA9IHNpemUgKyAnIHNlcmlmJztcbiAgICAgICAgc2l6ZSA9IHBhcnNlRmxvYXQoY3R4LmZvbnQpO1xuICAgICAgICBjdHguZm9udCA9IHByZXZGb250O1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9LFxuXG4gICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgIHByZXZGb250ID0gY3R4LmZvbnQsXG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIGN0eC5mb250ID0gZm9udDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZXNbaV0pLndpZHRoKTtcbiAgICAgICAgY3R4LmZvbnQgPSBwcmV2Rm9udDtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG4gICAgICAgIGlmICghcHJvamVjdCB8fCAhcHJvamVjdC5fbmVlZHNVcGRhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jb250ZXh0LFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuICAgICAgICBwcm9qZWN0LmRyYXcoY3R4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX3BpeGVsUmF0aW8pO1xuICAgICAgICBwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59LCBuZXcgZnVuY3Rpb24oKSB7IFxuXG4gICAgdmFyIGRvd25Qb2ludCxcbiAgICAgICAgbGFzdFBvaW50LFxuICAgICAgICBvdmVyUG9pbnQsXG4gICAgICAgIGRvd25JdGVtLFxuICAgICAgICBsYXN0SXRlbSxcbiAgICAgICAgb3Zlckl0ZW0sXG4gICAgICAgIGRyYWdJdGVtLFxuICAgICAgICBkYmxDbGljayxcbiAgICAgICAgY2xpY2tUaW1lO1xuXG4gICAgZnVuY3Rpb24gY2FsbEV2ZW50KHZpZXcsIHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBsYXN0UG9pbnQpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0YXJnZXQsXG4gICAgICAgICAgICBtb3VzZUV2ZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGwob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPyBwb2ludC5zdWJ0cmFjdChsYXN0UG9pbnQpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGNhbGwoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbCh2aWV3KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRDb3VudGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG4gICAgICAgICAgICAgICAgaGl0ID0gcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHRvbGVyYW5jZTogMCxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaXRlbSA9IGhpdCAmJiBoaXQuaXRlbSxcbiAgICAgICAgICAgICAgICBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgICAgICAgc3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIGRibENsaWNrID0gbGFzdEl0ZW0gPT0gaXRlbSAmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG4gICAgICAgICAgICAgICAgZG93bkl0ZW0gPSBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgZG93blBvaW50ID0gbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0gPSAhc3RvcHBlZCAmJiBpdGVtO1xuICAgICAgICAgICAgICAgIHdoaWxlIChkcmFnSXRlbSAmJiAhZHJhZ0l0ZW0ucmVzcG9uZHMoJ21vdXNlZHJhZycpKVxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbSA9IGRyYWdJdGVtLl9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgICAgICBzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSwgZG93blBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0l0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RQb2ludCAmJiAhbGFzdFBvaW50LmVxdWFscyhwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCwgZHJhZ0l0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBkcmFnSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlclBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXZlbnQodGhpcywgJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlclBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0b3BwZWQgJiYgaXRlbSAmJiBpdGVtID09PSBkb3duSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsRXZlbnQodGhpcywgZGJsQ2xpY2sgJiYgZG93bkl0ZW0ucmVzcG9uZHMoJ2RvdWJsZWNsaWNrJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgZG93blBvaW50LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgZGJsQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgICAgIGlmIChkcmFnSXRlbSlcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtLCBsYXN0UG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlclBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IG92ZXJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxFdmVudCh0aGlzLCAnbW91c2VsZWF2ZScsIGV2ZW50LCBwb2ludCwgb3Zlckl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBvdmVySXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxFdmVudCh0aGlzLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3BwZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cbnZhciBFdmVudCA9IEJhc2UuZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdFdmVudCcsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfSxcblxuICAgIGlzUHJldmVudGVkOiBmYWxzZSxcbiAgICBpc1N0b3BwZWQ6IGZhbHNlLFxuXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcblxuICAgIGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBLZXkubW9kaWZpZXJzO1xuICAgIH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuICAgIF9jbGFzczogJ0tleUV2ZW50JyxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuICAgICAgICBFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgdGhpcy50eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCc7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNoYXJhY3RlciA9IGNoYXJhY3RlcjtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuICAgICAgICAgICAgICAgICsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG4gICAgICAgICAgICAgICAgKyBcIicsIGNoYXJhY3RlcjogJ1wiICsgdGhpcy5jaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICArIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKClcbiAgICAgICAgICAgICAgICArIFwiIH1cIjtcbiAgICB9XG59KTtcblxudmFyIEtleSA9IG5ldyBmdW5jdGlvbigpIHtcbiAgICBpZiAoIG5vQ2FudmFzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNwZWNpYWxLZXlzID0ge1xuICAgICAgICA4OiAnYmFja3NwYWNlJyxcbiAgICAgICAgOTogJ3RhYicsXG4gICAgICAgIDEzOiAnZW50ZXInLFxuICAgICAgICAxNjogJ3NoaWZ0JyxcbiAgICAgICAgMTc6ICdjb250cm9sJyxcbiAgICAgICAgMTg6ICdvcHRpb24nLFxuICAgICAgICAxOTogJ3BhdXNlJyxcbiAgICAgICAgMjA6ICdjYXBzLWxvY2snLFxuICAgICAgICAyNzogJ2VzY2FwZScsXG4gICAgICAgIDMyOiAnc3BhY2UnLFxuICAgICAgICAzNTogJ2VuZCcsXG4gICAgICAgIDM2OiAnaG9tZScsXG4gICAgICAgIDM3OiAnbGVmdCcsXG4gICAgICAgIDM4OiAndXAnLFxuICAgICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgICAgNDA6ICdkb3duJyxcbiAgICAgICAgNDY6ICdkZWxldGUnLFxuICAgICAgICA5MTogJ2NvbW1hbmQnLFxuICAgICAgICA5MzogJ2NvbW1hbmQnLCBcbiAgICAgICAgMjI0OiAnY29tbWFuZCcgXG4gICAgfSxcblxuICAgIHNwZWNpYWxDaGFycyA9IHtcbiAgICAgICAgOTogdHJ1ZSwgXG4gICAgICAgIDEzOiB0cnVlLCBcbiAgICAgICAgMzI6IHRydWUgXG4gICAgfSxcblxuICAgIG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcbiAgICAgICAgc2hpZnQ6IGZhbHNlLFxuICAgICAgICBjb250cm9sOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uOiBmYWxzZSxcbiAgICAgICAgY29tbWFuZDogZmFsc2UsXG4gICAgICAgIGNhcHNMb2NrOiBmYWxzZSxcbiAgICAgICAgc3BhY2U6IGZhbHNlXG4gICAgfSksXG5cbiAgICBjaGFyQ29kZU1hcCA9IHt9LCBcbiAgICBrZXlNYXAgPSB7fSwgXG4gICAgZG93bkNvZGU7IFxuXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleUNvZGUsIGNoYXJDb2RlLCBldmVudCkge1xuICAgICAgICB2YXIgY2hhcmFjdGVyID0gY2hhckNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSA6ICcnLFxuICAgICAgICAgICAgc3BlY2lhbEtleSA9IHNwZWNpYWxLZXlzW2tleUNvZGVdLFxuICAgICAgICAgICAga2V5ID0gc3BlY2lhbEtleSB8fCBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJyxcbiAgICAgICAgICAgIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuICAgICAgICAgICAgc2NvcGUgPSB2aWV3ICYmIHZpZXcuaXNWaXNpYmxlKCkgJiYgdmlldy5fc2NvcGUsXG4gICAgICAgICAgICB0b29sID0gc2NvcGUgJiYgc2NvcGUudG9vbCxcbiAgICAgICAgICAgIG5hbWU7XG4gICAgICAgIGtleU1hcFtrZXldID0gZG93bjtcbiAgICAgICAgaWYgKHNwZWNpYWxLZXkgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKHNwZWNpYWxLZXkpKSBpbiBtb2RpZmllcnMpXG4gICAgICAgICAgICBtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgY2hhckNvZGVNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFyQ29kZU1hcFtrZXlDb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSB7XG4gICAgICAgICAgICBwYXBlciA9IHNjb3BlO1xuICAgICAgICAgICAgdG9vbC5lbWl0KHR5cGUsIG5ldyBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpKTtcbiAgICAgICAgICAgIGlmICh2aWV3KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBEb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIGlmIChjb2RlIGluIHNwZWNpYWxLZXlzIHx8IG1vZGlmaWVycy5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlS2V5KHRydWUsIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlIGluIHNwZWNpYWxDaGFycyB8fCBtb2RpZmllcnMuY29tbWFuZCA/IGNvZGUgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb3duQ29kZSA9IGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZG93bkNvZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUtleSh0cnVlLCBkb3duQ29kZSwgZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRvd25Db2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcbiAgICAgICAgICAgIGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuICAgICAgICAgICAgICAgIGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgRG9tRXZlbnQuYWRkKHdpbmRvdywge1xuICAgICAgICBibHVyOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZm9yICh2YXIgY29kZSBpbiBjaGFyQ29kZU1hcClcbiAgICAgICAgICAgICAgICBoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG4gICAgICAgIGlzRG93bjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gISFrZXlNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgTW91c2VFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnTW91c2VFdmVudCcsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuICAgICAgICBFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG4gICAgICAgICAgICAgICAgKyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnRcbiAgICAgICAgICAgICAgICArICcsIHRhcmdldDogJyArIHRoaXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgKyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuICAgICAgICAgICAgICAgICsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuICAgICAgICAgICAgICAgICsgJyB9JztcbiAgICB9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG4gICAgX2NsYXNzOiAnVG9vbEV2ZW50JyxcbiAgICBfaXRlbTogbnVsbCxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuICAgICAgICB0aGlzLnRvb2wgPSB0b29sO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfSxcblxuICAgIF9jaG9vc2VQb2ludDogZnVuY3Rpb24ocG9pbnQsIHRvb2xQb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fcG9pbnQsIHRoaXMudG9vbC5fcG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSBwb2ludDtcbiAgICB9LFxuXG4gICAgZ2V0TGFzdFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuICAgICAgICB0aGlzLl9sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG4gICAgfSxcblxuICAgIGdldERvd25Qb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcbiAgICB9LFxuXG4gICAgc2V0RG93blBvaW50OiBmdW5jdGlvbihkb3duUG9pbnQpIHtcbiAgICAgICAgdGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuICAgIH0sXG5cbiAgICBnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWlkZGxlUG9pbnQgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2wuX3BvaW50LmFkZCh0aGlzLnRvb2wuX2xhc3RQb2ludCkuZGl2aWRlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcbiAgICB9LFxuXG4gICAgc2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKG1pZGRsZVBvaW50KSB7XG4gICAgICAgIHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG4gICAgfSxcblxuICAgIGdldERlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kZWx0YSAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludFxuICAgICAgICAgICAgICAgID8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcbiAgICAgICAgICAgICAgICA6IHRoaXMuX2RlbHRhO1xuICAgIH0sXG5cbiAgICBzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fZGVsdGEgPSBkZWx0YTtcbiAgICB9LFxuXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuICAgICAgICAgICAgICAgID8gdGhpcy50b29sLl9kb3duQ291bnRcbiAgICAgICAgICAgICAgICA6IHRoaXMudG9vbC5fY291bnQ7XG4gICAgfSxcblxuICAgIHNldENvdW50OiBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cbiAgICAgICAgICAgID0gY291bnQ7XG4gICAgfSxcblxuICAgIGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2l0ZW0pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICAgIH0sXG5cbiAgICBzZXRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlXG4gICAgICAgICAgICAgICAgKyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuICAgICAgICAgICAgICAgICsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KClcbiAgICAgICAgICAgICAgICArICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcbiAgICAgICAgICAgICAgICArICcgfSc7XG4gICAgfVxufSk7XG5cbnZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcbiAgICBfY2xhc3M6ICdUb29sJyxcbiAgICBfbGlzdDogJ3Rvb2xzJyxcbiAgICBfcmVmZXJlbmNlOiAndG9vbCcsXG4gICAgX2V2ZW50czogWyAnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsXG4gICAgICAgICAgICAnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcbiAgICAgICAgICAgICdvbktleURvd24nLCAnb25LZXlVcCcgXSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcbiAgICAgICAgUGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICB0aGlzLl9kb3duQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9zZXQocHJvcHMpO1xuICAgIH0sXG5cbiAgICBnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcbiAgICB9LFxuXG4gICAgc2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG4gICAgICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcbiAgICAgICAgICAgICAgICAmJiB0aGlzLl9taW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhEaXN0YW5jZSA9IHRoaXMuX21pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1heERpc3RhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuICAgIH0sXG5cbiAgICBzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fbWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgICAgICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuICAgICAgICAgICAgICAgICYmIHRoaXMuX21heERpc3RhbmNlIDwgdGhpcy5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZSA9PSB0aGlzLl9tYXhEaXN0YW5jZVxuICAgICAgICAgICAgPyB0aGlzLl9taW5EaXN0YW5jZSA6IG51bGw7XG4gICAgfSxcblxuICAgIHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgIHRoaXMuX21heERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSxcblxuICAgIF91cGRhdGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgc3RhcnQsXG4gICAgICAgICAgICBuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkge1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRpc3QgPSBtaW5EaXN0YW5jZSAhPSBudWxsID8gbWluRGlzdGFuY2UgOiAwLFxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IgPSBwb2ludC5zdWJ0cmFjdCh0aGlzLl9wb2ludCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gdmVjdG9yLmdldExlbmd0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGlzdCA9IG1heERpc3RhbmNlICE9IG51bGwgPyBtYXhEaXN0YW5jZSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKG1heERpc3QgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50LmFkZCh2ZWN0b3Iubm9ybWFsaXplKG1heERpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaE1heERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZHNDaGFuZ2UgJiYgcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFBvaW50ID0gc3RhcnQgJiYgdHlwZSA9PSAnbW91c2Vtb3ZlJyA/IHBvaW50IDogdGhpcy5fcG9pbnQ7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gcG9pbnQ7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgdGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuICAgICAgICAgICAgdGhpcy5fZG93blBvaW50ID0gdGhpcy5fcG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9kb3duQ291bnQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvdW50ID0gc3RhcnQgPyAwIDogdGhpcy5fY291bnQgKyAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX2ZpcmVFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHNldHMgPSBwYXBlci5wcm9qZWN0Ll9yZW1vdmVTZXRzO1xuICAgICAgICBpZiAoc2V0cykge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZXVwJylcbiAgICAgICAgICAgICAgICBzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc2V0ID0gc2V0c1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZXRbaWRdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gc2V0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyICE9IHNldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldHNbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbmRzKHR5cGUpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5lbWl0KHR5cGUsIG5ldyBUb29sRXZlbnQodGhpcywgdHlwZSwgZXZlbnQpKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcbiAgICAgICAgcGFwZXIgPSB0aGlzLl9zY29wZTtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgY2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZWRyYWcnOlxuICAgICAgICAgICAgdmFyIG5lZWRzQ2hhbmdlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF0Y2hNYXhEaXN0YW5jZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgbmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG4gICAgICAgICAgICAgICAgbmVlZHNDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hdGNoTWF4RGlzdGFuY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21vdXNldXAnOlxuICAgICAgICAgICAgaWYgKCFwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuX3VwZGF0ZUV2ZW50KCdtb3VzZWRyYWcnLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCgnbW91c2VkcmFnJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgY2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSwgdGhpcy5fZmlyc3RNb3ZlLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gY2FsbGVkO1xuICAgIH1cblxufSk7XG5cbnZhciBIdHRwID0ge1xuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG4gICAgICAgICAgICAgICAgICAgICdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgICB4aHIub3BlbihtZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKCdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBsb2FkICcgKyB1cmwgKyAnIChFcnJvciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBzdGF0dXMgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHhoci5zZW5kKG51bGwpO1xuICAgIH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IHtcbiAgICBjYW52YXNlczogW10sXG5cbiAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyxcbiAgICAgICAgICAgIGNsZWFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoLmhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGgud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBub0NhbnZhcyApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge30gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW52YXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKGNsZWFyKVxuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggKyAxLCBoZWlnaHQgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0sXG5cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICByZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuICAgIH1cbn07XG5cbnZhciBCbGVuZE1vZGUgPSBuZXcgZnVuY3Rpb24oKSB7Y29uc29sZS5sb2coJ3RoZXJlJyk7XG4gICAgaWYgKCBub0NhbnZhcyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLFxuICAgICAgICBzciwgc2csIHNiLCBzYSwgXG4gICAgICAgIGJyLCBiZywgYmIsIGJhLCBcbiAgICAgICAgZHIsIGRnLCBkYjsgICAgIFxuXG4gICAgZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0THVtKHIsIGcsIGIsIGwpIHtcbiAgICAgICAgdmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuICAgICAgICBkciA9IHIgKyBkO1xuICAgICAgICBkZyA9IGcgKyBkO1xuICAgICAgICBkYiA9IGIgKyBkO1xuICAgICAgICB2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcbiAgICAgICAgICAgIG1uID0gbWluKGRyLCBkZywgZGIpLFxuICAgICAgICAgICAgbXggPSBtYXgoZHIsIGRnLCBkYik7XG4gICAgICAgIGlmIChtbiA8IDApIHtcbiAgICAgICAgICAgIHZhciBsbW4gPSBsIC0gbW47XG4gICAgICAgICAgICBkciA9IGwgKyAoZHIgLSBsKSAqIGwgLyBsbW47XG4gICAgICAgICAgICBkZyA9IGwgKyAoZGcgLSBsKSAqIGwgLyBsbW47XG4gICAgICAgICAgICBkYiA9IGwgKyAoZGIgLSBsKSAqIGwgLyBsbW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG14ID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbG4gPSAyNTUgLSBsLFxuICAgICAgICAgICAgICAgIG14bCA9IG14IC0gbDtcbiAgICAgICAgICAgIGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG4gICAgICAgICAgICBkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuICAgICAgICAgICAgZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNhdChyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcbiAgICAgICAgdmFyIGNvbCA9IFtyLCBnLCBiXSxcbiAgICAgICAgICAgIG14ID0gbWF4KHIsIGcsIGIpLCBcbiAgICAgICAgICAgIG1uID0gbWluKHIsIGcsIGIpLCBcbiAgICAgICAgICAgIG1kOyBcbiAgICAgICAgbW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuICAgICAgICBteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG4gICAgICAgIG1kID0gbWluKG1uLCBteCkgPT09IDAgPyBtYXgobW4sIG14KSA9PT0gMSA/IDIgOiAxIDogMDtcbiAgICAgICAgaWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG4gICAgICAgICAgICBjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuICAgICAgICAgICAgY29sW214XSA9IHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xbbWRdID0gY29sW214XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29sW21uXSA9IDA7XG4gICAgICAgIGRyID0gY29sWzBdO1xuICAgICAgICBkZyA9IGNvbFsxXTtcbiAgICAgICAgZGIgPSBjb2xbMl07XG4gICAgfVxuXG4gICAgdmFyIG1vZGVzID0ge1xuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkciA9IGJyICogc3IgLyAyNTU7XG4gICAgICAgICAgICBkZyA9IGJnICogc2cgLyAyNTU7XG4gICAgICAgICAgICBkYiA9IGJiICogc2IgLyAyNTU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2NyZWVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gYnIgKyBzciAtIChiciAqIHNyIC8gMjU1KTtcbiAgICAgICAgICAgIGRnID0gYmcgKyBzZyAtIChiZyAqIHNnIC8gMjU1KTtcbiAgICAgICAgICAgIGRiID0gYmIgKyBzYiAtIChiYiAqIHNiIC8gMjU1KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcbiAgICAgICAgICAgIGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcbiAgICAgICAgICAgIGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcbiAgICAgICAgfSxcblxuICAgICAgICAnc29mdC1saWdodCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBzciAqIGJyIC8gMjU1O1xuICAgICAgICAgICAgZHIgPSB0ICsgYnIgKiAoMjU1IC0gKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgICAgICAgIHQgPSBzZyAqIGJnIC8gMjU1O1xuICAgICAgICAgICAgZGcgPSB0ICsgYmcgKiAoMjU1IC0gKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgICAgICAgIHQgPSBzYiAqIGJiIC8gMjU1O1xuICAgICAgICAgICAgZGIgPSB0ICsgYmIgKiAoMjU1IC0gKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTUgLSB0KSAvIDI1NTtcbiAgICAgICAgfSxcblxuICAgICAgICAnaGFyZC1saWdodCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuICAgICAgICAgICAgZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuICAgICAgICAgICAgZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuICAgICAgICB9LFxuXG4gICAgICAgICdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcbiAgICAgICAgICAgIGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG4gICAgICAgICAgICBkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdjb2xvci1idXJuJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkciA9IGJyID09PSAyNTUgPyAyNTUgOiBzciA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJyKSAqIDI1NSAvIHNyKTtcbiAgICAgICAgICAgIGRnID0gYmcgPT09IDI1NSA/IDI1NSA6IHNnID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmcpICogMjU1IC8gc2cpO1xuICAgICAgICAgICAgZGIgPSBiYiA9PT0gMjU1ID8gMjU1IDogc2IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiYikgKiAyNTUgLyBzYik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGFya2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG4gICAgICAgICAgICBkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuICAgICAgICAgICAgZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcbiAgICAgICAgfSxcblxuICAgICAgICBsaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG4gICAgICAgICAgICBkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuICAgICAgICAgICAgZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcbiAgICAgICAgfSxcblxuICAgICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gYnIgLSBzcjtcbiAgICAgICAgICAgIGlmIChkciA8IDApXG4gICAgICAgICAgICAgICAgZHIgPSAtZHI7XG4gICAgICAgICAgICBkZyA9IGJnIC0gc2c7XG4gICAgICAgICAgICBpZiAoZGcgPCAwKVxuICAgICAgICAgICAgICAgIGRnID0gLWRnO1xuICAgICAgICAgICAgZGIgPSBiYiAtIHNiO1xuICAgICAgICAgICAgaWYgKGRiIDwgMClcbiAgICAgICAgICAgICAgICBkYiA9IC1kYjtcbiAgICAgICAgfSxcblxuICAgICAgICBleGNsdXNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuICAgICAgICAgICAgZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuICAgICAgICAgICAgZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuICAgICAgICB9LFxuXG4gICAgICAgIGh1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcbiAgICAgICAgICAgIHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2V0U2F0KGJyLCBiZywgYmIsIGdldFNhdChzciwgc2csIHNiKSk7XG4gICAgICAgICAgICBzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkciA9IG1pbihiciArIHNyLCAyNTUpO1xuICAgICAgICAgICAgZGcgPSBtaW4oYmcgKyBzZywgMjU1KTtcbiAgICAgICAgICAgIGRiID0gbWluKGJiICsgc2IsIDI1NSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHIgPSBtYXgoYnIgLSBzciwgMCk7XG4gICAgICAgICAgICBkZyA9IG1heChiZyAtIHNnLCAwKTtcbiAgICAgICAgICAgIGRiID0gbWF4KGJiIC0gc2IsIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZHIgPSAoYnIgKyBzcikgLyAyO1xuICAgICAgICAgICAgZGcgPSAoYmcgKyBzZykgLyAyO1xuICAgICAgICAgICAgZGIgPSAoYmIgKyBzYikgLyAyO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyID0gMjU1IC0gYWJzKDI1NSAtIHNyIC0gYnIpO1xuICAgICAgICAgICAgZGcgPSAyNTUgLSBhYnMoMjU1IC0gc2cgLSBiZyk7XG4gICAgICAgICAgICBkYiA9IDI1NSAtIGFicygyNTUgLSBzYiAtIGJiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFtcbiAgICAgICAgJ3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JywgJ3NvdXJjZS1hdG9wJyxcbiAgICAgICAgJ2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0JyxcbiAgICAgICAgJ2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXG4gICAgXSwgZnVuY3Rpb24obW9kZSkge1xuICAgICAgICB0aGlzW21vZGVdID0gdHJ1ZTtcbiAgICB9LCB7fSk7XG5cbiAgICB2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcbiAgICBCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcbiAgICAgICAgdmFyIGRhcmtlbiA9IG1vZGUgPT09ICdkYXJrZW4nLFxuICAgICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnIzMwMCcgOiAnI2EwMCc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcbiAgICAgICAgICAgIGlmIChjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID09PSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjYTAwJyA6ICcjMzAwJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICAgICAgICAgICAgb2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gIT09IGRhcmtlbiA/IDE3MCA6IDUxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuICAgIH0pO1xuICAgIENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblxuICAgIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuICAgICAgICAgICAgbm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG4gICAgICAgIGlmIChub3JtYWwgfHwgbmF0aXZlTW9kZXNbbW9kZV0pIHtcbiAgICAgICAgICAgIGRzdENvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgZHN0Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgICBkc3RDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICBpZiAoIW5vcm1hbClcbiAgICAgICAgICAgICAgICBkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG4gICAgICAgICAgICBkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG4gICAgICAgICAgICBkc3RDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzID0gbW9kZXNbbW9kZV07XG4gICAgICAgICAgICBpZiAoIXByb2Nlc3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksXG4gICAgICAgICAgICAgICAgICAgIHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCksXG4gICAgICAgICAgICAgICAgZHN0ID0gZHN0RGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgIHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHNyID0gc3JjW2ldO1xuICAgICAgICAgICAgICAgIGJyID0gZHN0W2ldO1xuICAgICAgICAgICAgICAgIHNnID0gc3JjW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBiZyA9IGRzdFtpICsgMV07XG4gICAgICAgICAgICAgICAgc2IgPSBzcmNbaSArIDJdO1xuICAgICAgICAgICAgICAgIGJiID0gZHN0W2kgKyAyXTtcbiAgICAgICAgICAgICAgICBzYSA9IHNyY1tpICsgM107XG4gICAgICAgICAgICAgICAgYmEgPSBkc3RbaSArIDNdO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuICAgICAgICAgICAgICAgICAgICBhMiA9IDEgLSBhMTtcbiAgICAgICAgICAgICAgICBkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcbiAgICAgICAgICAgICAgICBkc3RbaSArIDFdID0gYTEgKiBkZyArIGEyICogYmc7XG4gICAgICAgICAgICAgICAgZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuICAgICAgICAgICAgICAgIGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIFNWR1N0eWxlcyA9IEJhc2UuZWFjaCh7XG4gICAgZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcbiAgICBzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcbiAgICBzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG4gICAgc3Ryb2tlQ2FwOiBbJ3N0cm9rZS1saW5lY2FwJywgJ3N0cmluZyddLFxuICAgIHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuICAgIHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG4gICAgICAgIHRydWU6ICdub25lJyxcbiAgICAgICAgZmFsc2U6ICdub24tc2NhbGluZy1zdHJva2UnXG4gICAgfSwgZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZSBcbiAgICAgICAgICAgICAgICAmJiAoaXRlbSBpbnN0YW5jZW9mIFBhdGhJdGVtXG4gICAgICAgICAgICAgICAgICAgIHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuICAgICAgICAgICAgICAgICAgICB8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuICAgIH1dLFxuICAgIG1pdGVyTGltaXQ6IFsnc3Ryb2tlLW1pdGVybGltaXQnLCAnbnVtYmVyJ10sXG4gICAgZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcbiAgICBkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuICAgIGZvbnRGYW1pbHk6IFsnZm9udC1mYW1pbHknLCAnc3RyaW5nJ10sXG4gICAgZm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcbiAgICBmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG4gICAganVzdGlmaWNhdGlvbjogWyd0ZXh0LWFuY2hvcicsICdsb29rdXAnLCB7XG4gICAgICAgIGxlZnQ6ICdzdGFydCcsXG4gICAgICAgIGNlbnRlcjogJ21pZGRsZScsXG4gICAgICAgIHJpZ2h0OiAnZW5kJ1xuICAgIH1dLFxuICAgIG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcbiAgICBibGVuZE1vZGU6IFsnbWl4LWJsZW5kLW1vZGUnLCAnc3RyaW5nJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcbiAgICB2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuICAgICAgICBsb29rdXAgPSBlbnRyeVsyXTtcbiAgICB0aGlzW2tleV0gPSB7XG4gICAgICAgIHR5cGU6IGVudHJ5WzFdLFxuICAgICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgICBhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuICAgICAgICB0b1NWRzogbG9va3VwLFxuICAgICAgICBmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXNbdmFsdWVdID0gbmFtZTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICBleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuICAgICAgICBnZXQ6ICdnZXQnICsgcGFydCxcbiAgICAgICAgc2V0OiAnc2V0JyArIHBhcnRcbiAgICB9O1xufSwge30pO1xuXG52YXIgU1ZHTmFtZXNwYWNlcyA9IHtcbiAgICBocmVmOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJ1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb3JtYXR0ZXI7XG5cbiAgICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGF0dHJzW2tleV0sXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbCA9IGZvcm1hdHRlci5udW1iZXIodmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwga2V5LCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSB7XG4gICAgICAgIHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyksIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG4gICAgICAgIHZhciBhdHRycyA9IG5ldyBCYXNlKCksXG4gICAgICAgICAgICB0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5zaGlmdGxlc3MoKTtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG4gICAgICAgICAgICBhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG4gICAgICAgICAgICBhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG4gICAgICAgICAgICB0cmFucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcbiAgICAgICAgICAgIGlmIChkZWNvbXBvc2VkICYmICFkZWNvbXBvc2VkLnNoZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICYmICF0cmFucy5pc1plcm8oKSlcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuICAgICAgICAgICAgICAgIGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgnc2NhbGUoJyArIGZvcm1hdHRlci5wb2ludChzY2FsZSkgKycpJyk7XG4gICAgICAgICAgICAgICAgYXR0cnMudHJhbnNmb3JtID0gcGFydHMuam9pbignICcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcbiAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCdnJywgYXR0cnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNDbGlwTWFzaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuICAgICAgICAgICAgc2l6ZSA9IGl0ZW0uZ2V0U2l6ZSgpO1xuICAgICAgICBhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuICAgICAgICBhdHRycy55IC09IHNpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgYXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICBhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgYXR0cnMuaHJlZiA9IGl0ZW0udG9EYXRhVVJMKCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdpbWFnZScsIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF0Y2hTaGFwZXMpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IGl0ZW0udG9TaGFwZShmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc2hhcGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChpdGVtLmlzUG9seWdvbigpKSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuICAgICAgICAgICAgICAgIGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdsaW5lJztcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzZWdtZW50c1swXS5fcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQ7XG4gICAgICAgICAgICAgICAgYXR0cnMuc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IGZpcnN0LngsXG4gICAgICAgICAgICAgICAgICAgIHkxOiBmaXJzdC55LFxuICAgICAgICAgICAgICAgICAgICB4MjogbGFzdC54LFxuICAgICAgICAgICAgICAgICAgICB5MjogbGFzdC55XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gJ3BhdGgnO1xuICAgICAgICAgICAgYXR0cnMuZCA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG4gICAgICAgIHZhciB0eXBlID0gaXRlbS5fdHlwZSxcbiAgICAgICAgICAgIHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcbiAgICAgICAgICAgIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgIHR5cGUgPSAncmVjdCc7IFxuICAgICAgICAgICAgdmFyIHNpemUgPSBpdGVtLl9zaXplLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgIGF0dHJzLnggLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgYXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGlmIChyYWRpdXMuaXNaZXJvKCkpXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFkaXVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICBhdHRycy5yID0gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcbiAgICAgICAgICAgICAgICBhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuICAgICAgICB2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgIGF0dHJzLmQgPSBkYXRhO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgncGF0aCcsIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRQbGFjZWRTeW1ib2woaXRlbSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcbiAgICAgICAgICAgIHN5bWJvbCA9IGl0ZW0uZ2V0U3ltYm9sKCksXG4gICAgICAgICAgICBzeW1ib2xOb2RlID0gZ2V0RGVmaW5pdGlvbihzeW1ib2wsICdzeW1ib2wnKSxcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBzeW1ib2wuZ2V0RGVmaW5pdGlvbigpLFxuICAgICAgICAgICAgYm91bmRzID0gZGVmaW5pdGlvbi5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFzeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBzeW1ib2xOb2RlID0gY3JlYXRlRWxlbWVudCgnc3ltYm9sJywge1xuICAgICAgICAgICAgICAgIHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzeW1ib2xOb2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBzZXREZWZpbml0aW9uKHN5bWJvbCwgc3ltYm9sTm9kZSwgJ3N5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmhyZWYgPSAnIycgKyBzeW1ib2xOb2RlLmlkO1xuICAgICAgICBhdHRycy54ICs9IGJvdW5kcy54O1xuICAgICAgICBhdHRycy55ICs9IGJvdW5kcy55O1xuICAgICAgICBhdHRycy53aWR0aCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLndpZHRoKTtcbiAgICAgICAgYXR0cnMuaGVpZ2h0ID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3VzZScsIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuICAgICAgICB2YXIgZ3JhZGllbnROb2RlID0gZ2V0RGVmaW5pdGlvbihjb2xvciwgJ2NvbG9yJyk7XG4gICAgICAgIGlmICghZ3JhZGllbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuICAgICAgICAgICAgICAgIHJhZGlhbCA9IGdyYWRpZW50Ll9yYWRpYWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCkudHJhbnNmb3JtKCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLnRyYW5zZm9ybSgpLFxuICAgICAgICAgICAgICAgIGF0dHJzO1xuICAgICAgICAgICAgaWYgKHJhZGlhbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICBjeDogb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgICAgICAgcjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IGNvbG9yLmdldEhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5meSA9IGhpZ2hsaWdodC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHgxOiBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgeTE6IG9yaWdpbi55LFxuICAgICAgICAgICAgICAgICAgICB4MjogZGVzdGluYXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgeTI6IGRlc3RpbmF0aW9uLnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG4gICAgICAgICAgICBncmFkaWVudE5vZGUgPSBjcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycyk7XG4gICAgICAgICAgICB2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpO1xuICAgICAgICAgICAgICAgIGF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0b3AuX3JhbXBQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgJ3N0b3AtY29sb3InOiBzdG9wQ29sb3IudG9DU1ModHJ1ZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYSA8IDEpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgndGV4dCcsIGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpKTtcbiAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uX2NvbnRlbnQ7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBleHBvcnRlcnMgPSB7XG4gICAgICAgIEdyb3VwOiBleHBvcnRHcm91cCxcbiAgICAgICAgTGF5ZXI6IGV4cG9ydEdyb3VwLFxuICAgICAgICBSYXN0ZXI6IGV4cG9ydFJhc3RlcixcbiAgICAgICAgUGF0aDogZXhwb3J0UGF0aCxcbiAgICAgICAgU2hhcGU6IGV4cG9ydFNoYXBlLFxuICAgICAgICBDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcbiAgICAgICAgUGxhY2VkU3ltYm9sOiBleHBvcnRQbGFjZWRTeW1ib2wsXG4gICAgICAgIFBvaW50VGV4dDogZXhwb3J0VGV4dFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuICAgICAgICB2YXIgYXR0cnMgPSB7fSxcbiAgICAgICAgICAgIHBhcmVudCA9ICFpc1Jvb3QgJiYgaXRlbS5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoaXRlbS5fbmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgYXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuXG4gICAgICAgIEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuICAgICAgICAgICAgICAgIHR5cGUgPSBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbVtnZXRdKCk7XG4gICAgICAgICAgICBpZiAoZW50cnkuZXhwb3J0RmlsdGVyXG4gICAgICAgICAgICAgICAgICAgID8gZW50cnkuZXhwb3J0RmlsdGVyKGl0ZW0sIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2VudHJ5LmF0dHJpYnV0ZSArICctb3BhY2l0eSddID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ2NvbG9yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUuZ3JhZGllbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRHcmFkaWVudCh2YWx1ZSwgaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZS50b0NTUyh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ2FycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlLmpvaW4oJywnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGUgPT09ICdsb29rdXAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG4gICAgICAgICAgICBkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuICAgICAgICBpZiAoIWl0ZW0uX3Zpc2libGUpXG4gICAgICAgICAgICBhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgcmV0dXJuIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpO1xuICAgIH1cblxuICAgIHZhciBkZWZpbml0aW9ucztcbiAgICBmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9ucylcbiAgICAgICAgICAgIGRlZmluaXRpb25zID0geyBpZHM6IHt9LCBzdmdzOiB7fSB9O1xuICAgICAgICByZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICBnZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBpZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuICAgICAgICBub2RlLmlkID0gdHlwZSArICctJyArIGlkO1xuICAgICAgICBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF0gPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN2ZyA9IG5vZGUsXG4gICAgICAgICAgICBkZWZzID0gbnVsbDtcbiAgICAgICAgaWYgKGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICBzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbml0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYXNTdHJpbmdcbiAgICAgICAgICAgICAgICA/IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKVxuICAgICAgICAgICAgICAgIDogc3ZnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cG9ydFNWRyhpdGVtLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgICAgdmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcbiAgICAgICAgICAgIG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBvbkV4cG9ydCA9IG9wdGlvbnMub25FeHBvcnQ7XG4gICAgICAgICAgICBpZiAob25FeHBvcnQpXG4gICAgICAgICAgICAgICAgbm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YSAgIT09ICd7fScpXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgSXRlbS5pbmplY3Qoe1xuICAgICAgICBleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydERlZmluaXRpb25zKGV4cG9ydFNWRyh0aGlzLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFByb2plY3QuaW5qZWN0KHtcbiAgICAgICAgZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHZpZXcuZ2V0Vmlld1NpemUoKSxcbiAgICAgICAgICAgICAgICBub2RlID0gY3JlYXRlRWxlbWVudCgnc3ZnJywge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMScsXG4gICAgICAgICAgICAgICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAgICAgICAgICAgICAneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLFxuICAgICAgICAgICAgICAgIG1hdHJpeCA9IHZpZXcuX21hdHJpeDtcbiAgICAgICAgICAgIGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSlcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudCgnZycsIGdldFRyYW5zZm9ybShtYXRyaXgpKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhsYXllcnNbaV0sIG9wdGlvbnMsIHRydWUpKTtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCkge1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1tuYW1lXSxcbiAgICAgICAgICAgIHZhbHVlID0gbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSlcbiAgICAgICAgICAgICAgICA6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdudWxsJylcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGFsbG93TnVsbFxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBpc1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAwXG4gICAgICAgICAgICAgICAgOiBpc1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsKSB7XG4gICAgICAgIHggPSBnZXRWYWx1ZShub2RlLCB4LCBmYWxzZSwgYWxsb3dOdWxsKTtcbiAgICAgICAgeSA9IGdldFZhbHVlKG5vZGUsIHksIGZhbHNlLCBhbGxvd051bGwpO1xuICAgICAgICByZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcbiAgICAgICAgICAgICAgICA6IG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCkge1xuICAgICAgICB3ID0gZ2V0VmFsdWUobm9kZSwgdywgZmFsc2UsIGFsbG93TnVsbCk7XG4gICAgICAgIGggPSBnZXRWYWx1ZShub2RlLCBoLCBmYWxzZSwgYWxsb3dOdWxsKTtcbiAgICAgICAgcmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBuZXcgU2l6ZSh3LCBoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICdub25lJ1xuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUZsb2F0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGUgPT09ICdhcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlID09PSAnY29sb3InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZSA9PT0gJ2xvb2t1cCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBsb29rdXBbdmFsdWVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG4gICAgICAgIHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICAgIGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG4gICAgICAgICAgICBpdGVtID0gbmV3IEdyb3VwKCksXG4gICAgICAgICAgICBwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcbiAgICAgICAgICAgIGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW107XG4gICAgICAgIGlmICghaXNDbGlwKSB7XG4gICAgICAgICAgICBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG4gICAgICAgICAgICBwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG4gICAgICAgICAgICAgICAgY2hpbGQ7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxXG4gICAgICAgICAgICAgICAgICAgICYmIChjaGlsZCA9IGltcG9ydFNWRyhjaGlsZE5vZGUsIG9wdGlvbnMsIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgIGlmIChpc0NsaXApXG4gICAgICAgICAgICBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0ucmVkdWNlKCksIG5vZGUsIGlzUm9vdCk7XG4gICAgICAgIHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcbiAgICAgICAgaWYgKGlzQ2xpcCB8fCB0eXBlID09PSAnZGVmcycpIHtcbiAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICBpdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMilcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb29yZHNbaV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwb2x5Z29uJylcbiAgICAgICAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkJyksXG4gICAgICAgICAgICBwYXJhbSA9IHsgcGF0aERhdGE6IGRhdGEgfTtcbiAgICAgICAgcmV0dXJuIChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG4gICAgICAgICAgICAgICAgPyBuZXcgQ29tcG91bmRQYXRoKHBhcmFtKVxuICAgICAgICAgICAgICAgIDogbmV3IFBhdGgocGFyYW0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydEdyYWRpZW50KG5vZGUsIHR5cGUpIHtcbiAgICAgICAgdmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgIGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50JyxcbiAgICAgICAgICAgIGdyYWRpZW50O1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgc3RvcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQ7XG4gICAgICAgIGlmIChpc1JhZGlhbCkge1xuICAgICAgICAgICAgb3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG4gICAgICAgICAgICBoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaW1wb3J0ZXJzID0ge1xuICAgICAgICAnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaW1wb3J0U1ZHKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnOiBpbXBvcnRHcm91cCxcbiAgICAgICAgc3ZnOiBpbXBvcnRHcm91cCxcbiAgICAgICAgY2xpcHBhdGg6IGltcG9ydEdyb3VwLFxuICAgICAgICBwb2x5Z29uOiBpbXBvcnRQb2x5LFxuICAgICAgICBwb2x5bGluZTogaW1wb3J0UG9seSxcbiAgICAgICAgcGF0aDogaW1wb3J0UGF0aCxcbiAgICAgICAgbGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuICAgICAgICByYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpKTtcbiAgICAgICAgICAgIHJhc3Rlci5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKHNpemUpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLmFkZChzaXplLmRpdmlkZSgyKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByYXN0ZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZnM6IGltcG9ydEdyb3VwLFxuXG4gICAgICAgIHVzZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbaWRdLFxuICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBkZWZpbml0aW9uIGluc3RhbmNlb2YgU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRlZmluaXRpb24ucGxhY2UocG9pbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmluaXRpb24uY2xvbmUoKS50cmFuc2xhdGUocG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjaXJjbGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2hhcGUuQ2lyY2xlKGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpLFxuICAgICAgICAgICAgICAgICAgICBnZXRWYWx1ZShub2RlLCAncicpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbGxpcHNlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXBlLkVsbGlwc2Uoe1xuICAgICAgICAgICAgICAgIGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG4gICAgICAgICAgICAgICAgcmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWN0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5JyksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKHBvaW50LCBzaXplKSwgcmFkaXVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsaW5lOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGguTGluZShnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlLCAneCcsICd5JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuICAgICAgICAgICAgdGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICB2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICAgICAgICAgIHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgICAgIG1hdHJpeC5jb25jYXRlbmF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBNYXRyaXgodlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICBtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0sIHZbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICAgIG1hdHJpeC5zY2FsZSh2KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICAgICAgICBtYXRyaXguc2tldyh2WzBdLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICAgICAgICBtYXRyaXguc2tldygwLCB2WzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuICAgICAgICB2YXIgY29sb3IgPSBpdGVtW25hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcidcbiAgICAgICAgICAgICAgICA6ICdnZXRTdHJva2VDb2xvciddKCk7XG4gICAgICAgIGlmIChjb2xvcilcbiAgICAgICAgICAgIGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICBpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBpdGVtW2VudHJ5LmdldF0oKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3IpXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2V0UG9zaXRpb24odHJ1ZSkubmVnYXRlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCB7XG4gICAgICAgIGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChpdGVtLnNldE5hbWUpXG4gICAgICAgICAgICAgICAgaXRlbS5zZXROYW1lKHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAnY2xpcC1wYXRoJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjbGlwID0gZ2V0RGVmaW5pdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAgPSBjbGlwLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgY2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuICAgICAgICB0cmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuICAgICAgICB2aXNpYmlsaXR5OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgaXRlbS5zZXRWaXNpYmxlKHZhbHVlID09PSAndmlzaWJsZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICBpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnNldENvbG9yKVxuICAgICAgICAgICAgICAgIGl0ZW0uc2V0Q29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgICdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uX2NvbG9yKVxuICAgICAgICAgICAgICAgIGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGVyY2VudGFnZSA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcbiAgICAgICAgICAgIGl0ZW0uc2V0UmFtcFBvaW50KHBlcmNlbnRhZ2VcbiAgICAgICAgICAgICAgICAgICAgPyBwZXJjZW50YWdlWzFdIC8gMTAwXG4gICAgICAgICAgICAgICAgICAgIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcbiAgICAgICAgICAgICAgICBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gc2l6ZSA/IHJlY3QuZ2V0U2l6ZSgpLmRpdmlkZShzaXplKSA6IDEsXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpKS5zY2FsZShzY2FsZSk7XG4gICAgICAgICAgICAgICAgaXRlbS50cmFuc2Zvcm0obWF0cml4LmludmVydGVkKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpemUpXG4gICAgICAgICAgICAgICAgICAgIHJlY3Quc2V0U2l6ZShzaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBpdGVtLl9kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwICYmICFyZWN0LmNvbnRhaW5zKGdyb3VwLmdldEJvdW5kcygpKSkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gbmV3IFNoYXBlLlJlY3RhbmdsZShyZWN0KS50cmFuc2Zvcm0oZ3JvdXAuX21hdHJpeCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFkZENoaWxkKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuICAgICAgICB2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcbiAgICAgICAgICAgIHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXZhbHVlXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA6IHZhbHVlID09PSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgbm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG4gICAgICAgICAgICBwYXJlbnQ6ICFpc1Jvb3QgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZS5wYXJlbnROb2RlKSB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgaXRlbSA9IEJhc2UucGljayhhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSwgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICB2YXIgZGVmaW5pdGlvbnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzojfCkoW14pJ10rKS8pO1xuICAgICAgICByZXR1cm4gbWF0Y2ggJiYgZGVmaW5pdGlvbnNbbWF0Y2hbMV1dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIGlzUm9vdCkge1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgb25Mb2FkOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IHNvdXJjZSxcbiAgICAgICAgICAgIHNjb3BlID0gcGFwZXI7XG5cbiAgICAgICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soc3ZnKSB7XG4gICAgICAgICAgICBwYXBlciA9IHNjb3BlO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbXBvcnRTVkcoc3ZnLCBvcHRpb25zLCBpc1Jvb3QpLFxuICAgICAgICAgICAgICAgIG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkLFxuICAgICAgICAgICAgICAgIHZpZXcgPSBzY29wZS5wcm9qZWN0ICYmIHNjb3BlLmdldFZpZXcoKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgICAgICAgICAgb25Mb2FkLmNhbGwodGhpcywgaXRlbSk7XG4gICAgICAgICAgICB2aWV3LnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmICEvXi4qPC8udGVzdChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSHR0cC5yZXF1ZXN0KCdnZXQnLCBzb3VyY2UsIG9uTG9hZENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvbkxvYWRDYWxsYmFjayhyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgbm9kZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc291cmNlLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuICAgICAgICBpZiAoIW5vZGUubm9kZU5hbWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgICAgICB2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyksXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNjb3BlLnNldHRpbmdzLFxuICAgICAgICAgICAgcHJldkFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG4gICAgICAgIHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG4gICAgICAgIGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHx8IG51bGw7XG4gICAgICAgIHNldHRpbmdzLmFwcGx5TWF0cml4ID0gcHJldkFwcGx5TWF0cml4O1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICcjZG9jdW1lbnQnICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcbiAgICAgICAgICAgICAgICBpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG4gICAgICAgICAgICB2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0O1xuICAgICAgICAgICAgaWYgKG9uSW1wb3J0KVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBvbkltcG9ydChub2RlLCBpdGVtLCBvcHRpb25zKSB8fCBpdGVtO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kU2hhcGVzICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0udG9QYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICBpdGVtLl9kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSb290KVxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgSXRlbS5pbmplY3Qoe1xuICAgICAgICBpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZENoaWxkKGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFByb2plY3QuaW5qZWN0KHtcbiAgICAgICAgaW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5wYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBCYXNlOiBCYXNlLFxuICAgIE51bWVyaWNhbDogTnVtZXJpY2FsLFxuICAgIEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgncGFwZXInLCBwYXBlcik7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkgeyBcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xufVxuXG5yZXR1cm4gcGFwZXI7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCJ2YXIgcGFwZXIgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzJyk7XG5cbmZ1bmN0aW9uIENvbnRvdXIoIGFyZ3MgKSB7XG5cdHBhcGVyLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIGFyZ3MgKTtcblxuXHR0aGlzLm5vZGVzID0gdGhpcy5zZWdtZW50cztcbn1cblxuQ29udG91ci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcGVyLlBhdGgucHJvdG90eXBlKTtcbkNvbnRvdXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udG91cjtcblxuQ29udG91ci5wcm90b3R5cGUuYWRkTm9kZXMgPSBwYXBlci5QYXRoLnByb3RvdHlwZS5hZGRTZWdtZW50cztcblxuQ29udG91ci5wcm90b3R5cGUucHJlcGFyZU9UID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0dHlwZTogJ00nLFxuXHRcdHg6IE1hdGgucm91bmQoIHRoaXMuZmlyc3RTZWdtZW50LnBvaW50LnggKSB8fCAwLFxuXHRcdHk6IE1hdGgucm91bmQoIHRoaXMuZmlyc3RTZWdtZW50LnBvaW50LnkgKSB8fCAwXG5cdH0pO1xuXG5cdHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24oIGN1cnZlICkge1xuXHRcdGlmICggY3VydmUuaXNMaW5lYXIoKSApIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdMJyxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdDJyxcblx0XHRcdFx0eDE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS54ICsgY3VydmUuaGFuZGxlMS54ICkgfHwgMCxcblx0XHRcdFx0eTE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS55ICsgY3VydmUuaGFuZGxlMS55ICkgfHwgMCxcblx0XHRcdFx0eDI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi54ICsgY3VydmUuaGFuZGxlMi54ICkgfHwgMCxcblx0XHRcdFx0eTI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi55ICsgY3VydmUuaGFuZGxlMi55ICkgfHwgMCxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRvdXI7IiwidmFyIG9wZW50eXBlID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9vcGVudHlwZS5qcycpLFxuXHRHbHlwaCA9IHJlcXVpcmUoJy4vR2x5cGguanMnKTtcblxuZnVuY3Rpb24gRm9udCggYXJncyApIHtcblx0aWYgKCAhYXJncyApIHtcblx0XHRhcmdzID0ge307XG5cdH1cblxuXHRpZiAoICFhcmdzLnN0eWxlTmFtZSApIHtcblx0XHRhcmdzLnN0eWxlTmFtZSA9ICdSZWd1bGFyJztcblx0fVxuXG5cdGlmICggIWFyZ3MudW5pdHNQZXJFbSApIHtcblx0XHRhcmdzLnVuaXRzUGVyRW0gPSAxMDI0O1xuXHR9XG5cblx0dGhpcy5vdCA9IG5ldyBvcGVudHlwZS5Gb250KCBhcmdzICk7XG5cblx0dGhpcy5nbHlwaHMgPSBbXTtcblx0dGhpcy5nbHlwaE1hcCA9IHt9O1xuXHR0aGlzLmNoYXJNYXAgPSB7fTtcblx0dGhpcy5hbHRNYXAgPSB7fTtcblx0dGhpcy5fc3Vic2V0ID0gZmFsc2U7XG5cblx0dGhpcy5hZGRHbHlwaChuZXcgR2x5cGgoe1xuXHRcdG5hbWU6ICcubm90ZGVmJyxcblx0XHR1bmljb2RlOiAwXG5cdH0pKTtcbn1cblxuRm9udC5wcm90b3R5cGUuYWRkR2x5cGggPSBmdW5jdGlvbiggZ2x5cGggKSB7XG5cdHRoaXMuZ2x5cGhzLnB1c2goIGdseXBoICk7XG5cdHRoaXMuZ2x5cGhNYXBbZ2x5cGgubmFtZV0gPSBnbHlwaDtcblxuXHQvLyBidWlsZCB0aGUgZGVmYXVsdCBjbWFwXG5cdC8vIGlmIG11bHRpcGxlIGdseXBocyBzaGFyZSB0aGUgc2FtZSB1bmljb2RlLCB1c2UgdGhlIGdseXBoIHdoZXJlIHVuaWNvZGUgYW5kIG5hbWUgYXJlIGVxdWFsXG5cdGlmICggIXRoaXMuY2hhck1hcFtnbHlwaC51bmljb2RlXSB8fFxuXHRcdFx0KCBnbHlwaC5uYW1lLmxlbmd0aCA9PT0gMSAmJiBnbHlwaC5uYW1lLmNoYXJDb2RlQXQoMCkgPT09IGdseXBoLnVuaWNvZGUgKSApIHtcblxuXHRcdHRoaXMuY2hhck1hcFtnbHlwaC51bmljb2RlXSA9IGdseXBoO1xuXHR9XG5cblx0Ly8gYnVpbGQgdGhlIGFsdGVybmF0ZXMgbWFwXG5cdGlmICggIXRoaXMuYWx0TWFwW2dseXBoLnVuaWNvZGVdICkge1xuXHRcdHRoaXMuYWx0TWFwW2dseXBoLnVuaWNvZGVdID0gW107XG5cdH1cblx0dGhpcy5hbHRNYXBbZ2x5cGgudW5pY29kZV0ucHVzaCggZ2x5cGggKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkZvbnQucHJvdG90eXBlLmFkZEdseXBocyA9IGZ1bmN0aW9uKCBnbHlwaHMgKSB7XG5cdGdseXBocy5mb3JFYWNoKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHR0aGlzLmFkZEdseXBoKGdseXBoKTtcblxuXHR9LCB0aGlzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRm9udC5wcm90b3R5cGUsICdzdWJzZXQnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YnNldDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggc2V0ICkge1xuXHRcdGlmICggc2V0ID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiAoIHRoaXMuX3N1YnNldCA9IGZhbHNlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICggdGhpcy5fc3Vic2V0ID0gKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnID8gc2V0LnNwbGl0KCcnKSA6IHNldClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oZSwgaSwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiBhcnIubGFzdEluZGV4T2YoZSkgPT09IGk7XG5cdFx0XHR9KVxuXHRcdFx0Lm1hcChmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHJldHVybiBlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHR9KVxuXHRcdFx0LnNvcnQoKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5Gb250LnByb3RvdHlwZS5nZXRHbHlwaFN1YnNldCA9IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdGlmICggc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy5zdWJzZXQgPSBzZXQ7XG5cdH1cblxuXHQvLyByZXVzZSBsYXN0IHN1YnNldCBpZiBwb3NzaWJsZVxuXHRpZiAoIHRoaXMuX2xhc3RTdWJzZXQgJiYgdGhpcy5fbGFzdFN1YnNldFswXSA9PT0gKCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RTdWJzZXRbMV07XG5cdH1cblxuXHQvLyBtZW1vaXplIGxhc3Qgc3Vic2V0XG5cdHRoaXMuX2xhc3RTdWJzZXQgPSBbXG5cdFx0KCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCksXG5cdFx0dGhpcy5nbHlwaHMuZmlsdGVyKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHRcdGlmICggdGhpcy5fc3Vic2V0ID09PSBmYWxzZSAmJiAoIGdseXBoLnVuaWNvZGUgIT09IGZhbHNlIHx8IGdseXBoLnVuaWNvZGVzLmxlbmd0aCApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLl9zdWJzZXQuaW5kZXhPZiggZ2x5cGgudW5pY29kZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IGhhbmRsZSBtdWx0aXBsZSB1bmljb2Rlc1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSwgdGhpcylcblx0XTtcblxuXHRyZXR1cm4gdGhpcy5fbGFzdFN1YnNldFsxXTtcbn07XG5cbkZvbnQucHJvdG90eXBlLnByZXBhcmVPVCA9IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdHRoaXMub3QuZ2x5cGhzID0gdGhpcy5nZXRHbHlwaFN1YnNldCggc2V0ICkubWFwKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHRyZXR1cm4gZ2x5cGgucHJlcGFyZU9UKCk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKCB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuZG9jdW1lbnQgKSB7XG5cblx0dmFyIF9VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwsXG5cdFx0cnVsZUluZGV4O1xuXHRGb250LnByb3RvdHlwZS5hZGRUb0ZvbnRzID0gZG9jdW1lbnQuZm9udHMgP1xuXHRcdC8vIENTUyBmb250IGxvYWRpbmcsIGxpZ2h0bmluZyBmYXN0XG5cdFx0ZnVuY3Rpb24oIGJ1ZmZlciApIHtcblx0XHRcdHZhciBmb250ZmFjZSA9IG5ldyBGb250RmFjZShcblx0XHRcdFx0dGhpcy5vdC5mYW1pbHlOYW1lLFxuXHRcdFx0XHRidWZmZXIgfHwgdGhpcy5vdC50b0J1ZmZlcigpXG5cdFx0XHQpO1xuXG5cdFx0XHRkb2N1bWVudC5mb250cy5hZGQoIGZvbnRmYWNlICk7XG5cblx0XHRcdGlmICggdGhpcy5sYXN0Rm9udEZhY2UgKSB7XG5cdFx0XHRcdGRvY3VtZW50LmZvbnRzLmRlbGV0ZSggdGhpcy5sYXN0Rm9udEZhY2UgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5sYXN0Rm9udEZhY2UgPSBmb250ZmFjZTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTpcblx0XHRmdW5jdGlvbiggYnVmZmVyICkge1xuXHRcdFx0dmFyIHVybCA9IF9VUkwuY3JlYXRlT2JqZWN0VVJMKFxuXHRcdFx0XHRuZXcgQmxvYihcblx0XHRcdFx0XHRbIG5ldyBEYXRhVmlldyggYnVmZmVyIHx8wqB0aGlzLm90LnRvQnVmZmVyKCkgKSBdLFxuXHRcdFx0XHRcdHt0eXBlOiAnZm9udC9vcGVudHlwZSd9XG5cdFx0XHRcdClcblx0XHRcdCk7XG5cblx0XHRcdGlmICggcnVsZUluZGV4ICkge1xuXHRcdFx0XHRkb2N1bWVudC5zdHlsZVNoZWV0c1swXS5kZWxldGVSdWxlKCBydWxlSW5kZXggKTtcblx0XHRcdH1cblxuXHRcdFx0cnVsZUluZGV4ID0gZG9jdW1lbnQuc3R5bGVTaGVldHNbMF0uaW5zZXJ0UnVsZShcblx0XHRcdFx0J0Bmb250LWZhY2UgeyBmb250LWZhbWlseTogXCInICsgdGhpcy5vdC5mYW1pbHlOYW1lICsgJ1wiOyBzcmM6IHVybCgnICsgdXJsICsgJyk7IH0nLFxuXHRcdFx0XHRydWxlSW5kZXggfHzCoGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdLmNzc1J1bGVzLmxlbmd0aFxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRGb250LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cblx0XHRyZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cubG9jYXRpb24gPSByZWFkZXIucmVzdWx0O1xuXHRcdH07XG5cblx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChuZXcgQmxvYihcblx0XHRcdFsgbmV3IERhdGFWaWV3KCBidWZmZXIgfHwgdGhpcy5vdC50b0J1ZmZlcigpICkgXSxcblx0XHRcdHt0eXBlOiAnZm9udC9vcGVudHlwZSd9XG5cdFx0KSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZvbnQ7IiwidmFyIG9wZW50eXBlID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9vcGVudHlwZS5qcycpLFxuXHRwYXBlciA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMnKTtcblxuZnVuY3Rpb24gR2x5cGgoIGFyZ3MgKSB7XG5cdHBhcGVyLkdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseSggdGhpcyApO1xuXG5cdGlmICggYXJncy51bmljb2RlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0YXJncy51bmljb2RlID0gYXJncy5uYW1lLmNoYXJDb2RlQXQoMCk7XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBhcmdzLnVuaWNvZGUgPT09ICdzdHJpbmcnICkge1xuXHRcdGFyZ3MudW5pY29kZSA9IGFyZ3MudW5pY29kZS5jaGFyQ29kZUF0KDApO1xuXHR9XG5cblx0dGhpcy5uYW1lID0gYXJncy5uYW1lO1xuXHR0aGlzLnVuaWNvZGUgPSBhcmdzLnVuaWNvZGU7XG5cblx0dGhpcy5vdCA9IG5ldyBvcGVudHlwZS5HbHlwaCggYXJncyApO1xuXHR0aGlzLm90LnBhdGggPSBuZXcgb3BlbnR5cGUuUGF0aCgpO1xuXG5cdHRoaXMuY29udG91cnMgPSBbXTtcblx0dGhpcy5hbmNob3JzID0gW107XG5cdHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXHR0aGlzLnBhcmVudEFuY2hvcnMgPSBbXTtcbn1cblxuR2x5cGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXBlci5Hcm91cC5wcm90b3R5cGUpO1xuR2x5cGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2x5cGg7XG5cbkdseXBoLnByb3RvdHlwZS5hZGRDb250b3VyID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdHRoaXMuYWRkQ2hpbGQoIGl0ZW0gKTtcblx0dGhpcy5jb250b3Vycy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHR0aGlzLmFkZENoaWxkKCBpdGVtICk7XG5cdHRoaXMuY29tcG9uZW50cy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZEFuY2hvciA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHR0aGlzLmFuY2hvcnMucHVzaCggaXRlbSApO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkdseXBoLnByb3RvdHlwZS5hZGRQYXJlbnRBbmNob3IgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0dGhpcy5wYXJlbnRBbmNob3JzLnB1c2goIGl0ZW0gKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUucHJlcGFyZU9UID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdGlmICggIXBhdGggKSB7XG5cdFx0dGhpcy5vdC5wYXRoLmNvbW1hbmRzID0gW107XG5cdFx0cGF0aCA9IHRoaXMub3QucGF0aDtcblx0fVxuXG5cdHRoaXMuY29udG91cnMuZm9yRWFjaChmdW5jdGlvbiggY29udG91ciApIHtcblx0XHRjb250b3VyLnByZXBhcmVPVCggdGhpcy5vdC5wYXRoICk7XG5cdH0sIHRoaXMpO1xuXG5cdHJldHVybiB0aGlzLm90O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaDsiLCJ2YXIgb3BlbnR5cGUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJyksXG5cdHBhcGVyID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItY29yZS5qcycpLFxuXHRGb250ID0gcmVxdWlyZSgnLi9Gb250LmpzJyksXG5cdEdseXBoID0gcmVxdWlyZSgnLi9HbHlwaC5qcycpLFxuXHRDb250b3VyID0gcmVxdWlyZSgnLi9Db250b3VyLmpzJyk7XG5cbmZ1bmN0aW9uIHBsdW1pbigpIHt9XG5cbnBsdW1pbi5vcGVudHlwZSA9IG9wZW50eXBlO1xucGx1bWluLnBhcGVyID0gcGFwZXI7XG5wbHVtaW4uRm9udCA9IEZvbnQ7XG5wbHVtaW4uR2x5cGggPSBHbHlwaDtcbnBsdW1pbi5Db250b3VyID0gQ29udG91cjtcbnBsdW1pbi5Ob2RlID0gcGFwZXIuU2VnbWVudDtcbnBsdW1pbi5Qb2ludCA9IHBhcGVyLlBvaW50O1xucGx1bWluLk1hdHJpeCA9IHBhcGVyLk1hdHJpeDtcbnBsdW1pbi5zZXR1cCA9IHBhcGVyLnNldHVwLmJpbmQocGFwZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdW1pbjsiXX0=
