!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.plumin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/node_modules/es6-collections/index.js":[function(require,module,exports){
(function (global){
(function (exports) {'use strict';
  //shared pointer
  var i;
  //shortcuts
  var defineProperty = Object.defineProperty, is = Object.is;


  //Polyfill global objects
  if (typeof WeakMap == 'undefined') {
    exports.WeakMap = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakMap#clear():
      clear: sharedClear,
      // WeakMap#get(key:void*):void*
      get: sharedGet,
      // WeakMap#has(key:void*):boolean
      has: mapHas,
      // WeakMap#set(key:void*, value:void*):void
      set: sharedSet
    }, true);
  }

  if (typeof Map == 'undefined') {
    exports.Map = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      //:was Map#get(key:void*[, d3fault:void*]):void*
      // Map#has(key:void*):boolean
      has: mapHas,
      // Map#get(key:void*):boolean
      get: sharedGet,
      // Map#set(key:void*, value:void*):void
      set: sharedSet,
      // Map#keys(void):Array === not in specs
      keys: sharedKeys,
      // Map#values(void):Array === not in specs
      values: sharedValues,
      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
      forEach: sharedForEach,
      // Map#clear():
      clear: sharedClear
    });
  }

  if (typeof Set == 'undefined') {
    exports.Set = createCollection({
      // Set#has(value:void*):boolean
      has: setHas,
      // Set#add(value:void*):boolean
      add: sharedAdd,
      // Set#delete(key:void*):boolean
      'delete': sharedDelete,
      // Set#clear():
      clear: sharedClear,
      // Set#values(void):Array === not in specs
      values: sharedValues,
      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
      forEach: sharedSetIterate
    });
  }

  if (typeof WeakSet == 'undefined') {
    exports.WeakSet = createCollection({
      // WeakSet#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakSet#add(value:void*):boolean
      add: sharedAdd,
      // WeakSet#clear():
      clear: sharedClear,
      // WeakSet#has(value:void*):boolean
      has: setHas
    }, true);
  }


  /**
   * ES6 collection constructor
   * @return {Function} a collection class
   */
  function createCollection(proto, objectOnly){
    function Collection(a){
      if (!this || this.constructor !== Collection) return new Collection(a);
      this._keys = [];
      this._values = [];
      this.objectOnly = objectOnly;

      //parse initial iterable argument passed
      if (a) init.call(this, a);
    }

    //define size for non object-only collections
    if (!objectOnly) {
      defineProperty(proto, 'size', {
        get: sharedSize
      });
    }

    //set prototype
    proto.constructor = Collection;
    Collection.prototype = proto;

    return Collection;
  }


  /** parse initial iterable argument passed */
  function init(a){
    var i;
    //init Set argument, like `[1,2,3,{}]`
    if (this.add)
      a.forEach(this.add, this);
    //init Map argument like `[[1,2], [{}, 4]]`
    else
      a.forEach(function(a){this.set(a[0],a[1])}, this);
  }


  /** delete */
  function sharedDelete(key) {
    if (this.has(key)) {
      this._keys.splice(i, 1);
      this._values.splice(i, 1);
    }
    // Aurora here does it while Canary doesn't
    return -1 < i;
  };

  function sharedGet(key) {
    return this.has(key) ? this._values[i] : undefined;
  }

  function has(list, key) {
    if (this.objectOnly && key !== Object(key))
      throw new TypeError("Invalid value used as weak collection key");
    //NaN or 0 passed
    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key););
    else i = list.indexOf(key);
    return -1 < i;
  }

  function setHas(value) {
    return has.call(this, this._values, value);
  }

  function mapHas(value) {
    return has.call(this, this._keys, value);
  }

  /** @chainable */
  function sharedSet(key, value) {
    this.has(key) ?
      this._values[i] = value
      :
      this._values[this._keys.push(key) - 1] = value
    ;
    return this;
  }

  /** @chainable */
  function sharedAdd(value) {
    if (!this.has(value)) this._values.push(value);
    return this;
  }

  function sharedClear() {
    this._values.length = 0;
  }

  /** keys, values, and iterate related methods */
  function sharedValues() {
    return this._values.slice();
  }

  function sharedKeys() {
    return this._keys.slice();
  }

  function sharedSize() {
    return this._values.length;
  }

  function sharedForEach(callback, context) {
    var self = this;
    var values = self._values.slice();
    self._keys.slice().forEach(function(key, n){
      callback.call(context, values[n], key, self);
    });
  }

  function sharedSetIterate(callback, context) {
    var self = this;
    self._values.slice().forEach(function(value){
      callback.call(context, value, value, self);
    });
  }

})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window );

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js":[function(require,module,exports){
// Run-time checking of preconditions.

'use strict';

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function (predicate, message) {
    if (!predicate) {
        throw new Error(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js":[function(require,module,exports){
// Drawing utility functions.

'use strict';

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js":[function(require,module,exports){
// Glyph encoding

'use strict';

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

// This is the encoding used for fonts created from scratch.
// It loops through all glyphs and finds the appropriate unicode value.
// Since it's linear time, other encodings will be faster.
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function (c) {
    var code, glyphs, i, glyph, j;
    code = c.charCodeAt(0);
    glyphs = this.font.glyphs;
    if (glyphs) {
        for (i = 0; i < glyphs.length; i += 1) {
            glyph = glyphs[i];
            for (j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

function CmapEncoding(cmap) {
    this.cmap = cmap;
}

CmapEncoding.prototype.charToGlyphIndex = function (c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

CffEncoding.prototype.charToGlyphIndex = function (s) {
    var code, charName;
    code = s.charCodeAt(0);
    charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

function GlyphNames(post) {
    var i;
    switch (post.version) {
    case 1:
        this.names = exports.standardNames.slice();
        break;
    case 2:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] < exports.standardNames.length) {
                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
            } else {
                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
            }
        }
        break;
    case 2.5:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
        }
        break;
    }
}

GlyphNames.prototype.nameToGlyphIndex = function (name) {
    return this.names.indexOf(name);
};

GlyphNames.prototype.glyphIndexToName = function (gid) {
    return this.names[gid];
};

function addGlyphNames(font) {
    var glyphIndexMap, charCodes, i, c, glyphIndex, glyph;
    glyphIndexMap = font.tables.cmap.glyphIndexMap;
    charCodes = Object.keys(glyphIndexMap);
    for (i = 0; i < charCodes.length; i += 1) {
        c = charCodes[i];
        glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs[glyphIndex];
        glyph.addUnicode(parseInt(c));
    }
    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs[i];
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js":[function(require,module,exports){
// The Font object

'use strict';

var path = require('./path');
var sfnt = require('./tables/sfnt');
var encoding = require('./encoding');

// A Font represents a loaded OpenType font file.
// It contains a set of glyphs and methods to draw text on a drawing context,
// or to get a path representing the text.
function Font(options) {
    options = options || {};
    // OS X will complain if the names are empty, so we put a single space everywhere by default.
    this.familyName = options.familyName || ' ';
    this.styleName = options.styleName || ' ';
    this.designer = options.designer || ' ';
    this.designerURL = options.designerURL || ' ';
    this.manufacturer = options.manufacturer || ' ';
    this.manufacturerURL = options.manufacturerURL || ' ';
    this.license = options.license || ' ';
    this.licenseURL = options.licenseURL || ' ';
    this.version = options.version || 'Version 0.1';
    this.description = options.description || ' ';
    this.copyright = options.copyright || ' ';
    this.trademark = options.trademark || ' ';
    this.unitsPerEm = options.unitsPerEm || 1000;
    this.supported = true;
    this.glyphs = options.glyphs || [];
    this.encoding = new encoding.DefaultEncoding(this);
    this.tables = {};
}

// Check if the font has a glyph for the given character.
Font.prototype.hasChar = function (c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

// Convert the given character to a single glyph index.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyphIndex = function (s) {
    return this.encoding.charToGlyphIndex(s);
};

// Convert the given character to a single Glyph object.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyph = function (c) {
    var glyphIndex, glyph;
    glyphIndex = this.charToGlyphIndex(c);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

// Convert the given text to a list of Glyph objects.
// Note that there is no strict one-to-one mapping between characters and
// glyphs, so the list of returned glyphs can be larger or smaller than the
// length of the given string.
Font.prototype.stringToGlyphs = function (s) {
    var i, c, glyphs;
    glyphs = [];
    for (i = 0; i < s.length; i += 1) {
        c = s[i];
        glyphs.push(this.charToGlyph(c));
    }
    return glyphs;
};

Font.prototype.nameToGlyphIndex = function (name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

Font.prototype.nameToGlyph = function (name) {
    var glyphIndex, glyph;
    glyphIndex = this.nametoGlyphIndex(name);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

Font.prototype.glyphIndexToName = function (gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }
    return this.glyphNames.glyphIndexToName(gid);
};

// Retrieve the value of the kerning pair between the left glyph (or its index)
// and the right glyph (or its index). If no kerning pair is found, return 0.
// The kerning value gets added to the advance width when calculating the spacing
// between glyphs.
Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

// Helper function that invokes the given callback for each glyph in the given text.
// The callback gets `(glyph, x, y, fontSize, options)`.
Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    var kerning, fontScale, glyphs, i, glyph, kerningValue;
    if (!this.supported) {
        return;
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || {};
    kerning = options.kerning === undefined ? true : options.kerning;
    fontScale = 1 / this.unitsPerEm * fontSize;
    glyphs = this.stringToGlyphs(text);
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }
        if (kerning && i < glyphs.length - 1) {
            kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
    }
};

// Create a Path object that represents the given text.
//
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
//
// Returns a Path object.
Font.prototype.getPath = function (text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        var path = glyph.getPath(x, y, fontSize);
        fullPath.extend(path);
    });
    return fullPath;
};

// Draw the text on the given drawing context.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

// Draw the points of all glyphs in the text.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawPoints(ctx, x, y, fontSize);
    });
};

// Draw lines indicating important font measurements for all glyphs in the text.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawMetrics(ctx, x, y, fontSize);
    });
};

// Validate
Font.prototype.validate = function () {
    var warnings = [];
    var font = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertStringAttribute(attrName) {
        assert(font[attrName] && font[attrName].trim().length > 0, 'No ' + attrName + ' specified.');
    }

    // Identification information
    assertStringAttribute('familyName');
    assertStringAttribute('weightName');
    assertStringAttribute('manufacturer');
    assertStringAttribute('copyright');
    assertStringAttribute('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
Font.prototype.toTables = function () {
    return sfnt.fontToTable(this);
};

Font.prototype.toBuffer = function () {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }
    return buffer;
};

// Initiate a download of the OpenType font.
Font.prototype.download = function () {
    var fileName = this.familyName.replace(/\s/g, '') + '-' + this.styleName + '.otf';
    var buffer = this.toBuffer();

    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function (fs) {
        fs.root.getFile(fileName, {create: true}, function (fileEntry) {
            fileEntry.createWriter(function (writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], {type: 'font/opentype'});
                writer.write(blob);

                 writer.addEventListener('writeend', function () {
                    // Navigating to the file will download it.
                    location.href = fileEntry.toURL();
                 }, false);
            });
        });
    }, function (err) {
        throw err;
    });
};

exports.Font = Font;

},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/sfnt":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js":[function(require,module,exports){
// The Glyph object

'use strict';

var check = require('./check');
var draw = require('./draw');
var path = require('./path');

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
function Glyph(options) {
    this.font = options.font || null;
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    this.xMin = options.xMin || 0;
    this.yMin = options.yMin || 0;
    this.xMax = options.xMax || 0;
    this.yMax = options.yMax || 0;
    this.advanceWidth = options.advanceWidth || 0;
    this.path = options.path || null;
}

Glyph.prototype.addUnicode = function (unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }
    this.unicodes.push(unicode);
};

// Convert the glyph to a Path we can draw on a drawing context.
//
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.getPath = function (x, y, fontSize) {
    var scale, p, commands, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    scale = 1 / this.font.unitsPerEm * fontSize;
    p = new path.Path();
    commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                               x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                      x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }
    return p;
};

// Split the glyph into contours.
// This function is here for backwards compatibility, and to
// provide raw access to the TrueType glyph outlines.
Glyph.prototype.getContours = function () {
    var contours, currentContour, i, pt;
    if (this.points === undefined) {
        return [];
    }
    contours = [];
    currentContour = [];
    for (i = 0; i < this.points.length; i += 1) {
        pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
Glyph.prototype.getMetrics = function () {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: 0
    };
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

// Draw the glyph on the given context.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.draw = function (ctx, x, y, fontSize) {
    this.getPath(x, y, fontSize).draw(ctx);
};

// Draw the points of the glyph.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var j, PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
    }

    var scale, i, blueCircles, redCircles, path, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;

    blueCircles = [];
    redCircles = [];
    path = this.path;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }
        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }
        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

// Draw lines indicating important font measurements.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);
    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (this.xMin * scale), -10000, x + (this.xMin * scale), 10000);
    draw.line(ctx, x + (this.xMax * scale), -10000, x + (this.xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-this.yMin * scale), 10000, y + (-this.yMin * scale));
    draw.line(ctx, -10000, y + (-this.yMax * scale), 10000, y + (-this.yMax * scale));
    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (this.advanceWidth * scale), -10000, x + (this.advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./draw":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/draw.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js":[function(require,module,exports){
(function (process){
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2014 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */

'use strict';

var encoding = require('./encoding');
var _font = require('./font');
var glyph = require('./glyph');
var parse = require('./parse');
var path = require('./path');

var cmap = require('./tables/cmap');
var cff = require('./tables/cff');
var glyf = require('./tables/glyf');
var gpos = require('./tables/gpos');
var head = require('./tables/head');
var hhea = require('./tables/hhea');
var hmtx = require('./tables/hmtx');
var kern = require('./tables/kern');
var loca = require('./tables/loca');
var maxp = require('./tables/maxp');
var _name = require('./tables/name');
var os2 = require('./tables/os2');
var post = require('./tables/post');

// File loaders /////////////////////////////////////////////////////////

// Convert a Node.js Buffer to an ArrayBuffer
function toArrayBuffer(buffer) {
    var i,
        arrayBuffer = new ArrayBuffer(buffer.length),
        data = new Uint8Array(arrayBuffer);

    for (i = 0; i < buffer.length; i += 1) {
        data[i] = buffer[i];
    }

    return arrayBuffer;
}

function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function (err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, toArrayBuffer(buffer));
    });
}

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }
        return callback(null, request.response);
    };
    request.send();
}

// Public API ///////////////////////////////////////////////////////////

// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
// If the file could not be parsed (most likely because it contains Postscript outlines)
// we return an empty Font object with the `supported` flag set to `false`.
function parseBuffer(buffer) {
    var font, data, version, numTables, i, p, tag, offset, hmtxOffset, glyfOffset, locaOffset,
        cffOffset, kernOffset, gposOffset, indexToLocFormat, numGlyphs, locaTable,
        shortVersion;
    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.

    font = new _font.Font();
    data = new DataView(buffer, 0);

    version = parse.getFixed(data, 0);
    if (version === 1.0) {
        font.outlinesFormat = 'truetype';
    } else {
        version = parse.getTag(data, 0);
        if (version === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType version ' + version);
        }
    }

    numTables = parse.getUShort(data, 4);

    // Offset into the table records.
    p = 12;
    for (i = 0; i < numTables; i += 1) {
        tag = parse.getTag(data, p);
        offset = parse.getULong(data, p + 8);
        switch (tag) {
        case 'cmap':
            font.tables.cmap = cmap.parse(data, offset);
            font.encoding = new encoding.CmapEncoding(font.tables.cmap);
            if (!font.encoding) {
                font.supported = false;
            }
            break;
        case 'head':
            font.tables.head = head.parse(data, offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
        case 'hhea':
            font.tables.hhea = hhea.parse(data, offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
        case 'hmtx':
            hmtxOffset = offset;
            break;
        case 'maxp':
            font.tables.maxp = maxp.parse(data, offset);
            font.numGlyphs = numGlyphs = font.tables.maxp.numGlyphs;
            break;
        case 'name':
            font.tables.name = _name.parse(data, offset);
            font.familyName = font.tables.name.fontFamily;
            font.styleName = font.tables.name.fontSubfamily;
            break;
        case 'OS/2':
            font.tables.os2 = os2.parse(data, offset);
            break;
        case 'post':
            font.tables.post = post.parse(data, offset);
            font.glyphNames = new encoding.GlyphNames(font.tables.post);
            break;
        case 'glyf':
            glyfOffset = offset;
            break;
        case 'loca':
            locaOffset = offset;
            break;
        case 'CFF ':
            cffOffset = offset;
            break;
        case 'kern':
            kernOffset = offset;
            break;
        case 'GPOS':
            gposOffset = offset;
            break;
        }
        p += 16;
    }

    if (glyfOffset && locaOffset) {
        shortVersion = indexToLocFormat === 0;
        locaTable = loca.parse(data, locaOffset, numGlyphs, shortVersion);
        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
        encoding.addGlyphNames(font);
    } else if (cffOffset) {
        cff.parse(data, cffOffset, font);
        encoding.addGlyphNames(font);
    } else {
        font.supported = false;
    }

    if (font.supported) {
        if (kernOffset) {
            font.kerningPairs = kern.parse(data, kernOffset);
        } else {
            font.kerningPairs = {};
        }
        if (gposOffset) {
            gpos.parse(data, gposOffset, font);
        }
    }

    return font;
}

// Asynchronously load the font from a URL or a filesystem. When done, call the callback
// with two arguments `(err, font)`. The `err` will be null on success,
// the `font` is a Font object.
//
// We use the node.js callback convention so that
// opentype.js can integrate with frameworks like async.js.
function load(url, callback) {
    var loader = typeof process === 'undefined' || !process.browser ? loadFromFile : loadFromUrl;
    loader(url, function (err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font = parseBuffer(arrayBuffer);
        if (!font.supported) {
            return callback('Font is not supported (is this a Postscript font?)');
        }
        return callback(null, font);
    });
}

exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.parse = parseBuffer;
exports.load = load;

}).call(this,require('_process'))
},{"./encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","./font":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/font.js","./glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","./parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","./path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","./tables/cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./tables/cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./tables/glyf":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js","./tables/gpos":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js","./tables/head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./tables/hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./tables/hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./tables/kern":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js","./tables/loca":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js","./tables/maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./tables/name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./tables/os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./tables/post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js","_process":"/home/louisremi/Workspace/plumin.js/node_modules/browserify/node_modules/process/browser.js","fs":false}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js":[function(require,module,exports){
// Parsing utility functions

'use strict';

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
exports.getUShort = function (dataView, offset) {
    return dataView.getUint16(offset, false);
};

exports.getCard16 = exports.getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function (dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function (dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function (dataView, offset) {
    var decimal, fraction;
    decimal = dataView.getInt16(offset, false);
    fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function (dataView, offset) {
    var tag = '', i;
    for (i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }
    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function (dataView, offset, offSize) {
    var i, v;
    v = 0;
    for (i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function (dataView, startOffset, endOffset) {
    var bytes, i;
    bytes = [];
    for (i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }
    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function (bytes) {
    var s, i;
    s = '';
    for (i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }
    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function () {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function () {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function () {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function () {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function () {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function (count) {
    var offsets = new Array(count),
        dataView = this.data,
        offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = exports.getUShort(dataView, offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};

Parser.prototype.parseString = function (length) {
    var dataView = this.data,
        offset = this.offset + this.relativeOffset,
        string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }
    return string;
};

Parser.prototype.parseTag = function () {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v / 65536;
};

Parser.prototype.parseVersion = function() {
    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);
    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function (type, amount) {
    if (amount === undefined) {
        amount = 1;
    }
    this.relativeOffset += typeOffsets[type] * amount;
};

exports.Parser = Parser;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js":[function(require,module,exports){
// Geometric objects

'use strict';

// A bzier path containing a set of path commands similar to a SVG path.
// Paths can be drawn on a context using `draw`.
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

Path.prototype.moveTo = function (x, y) {
    this.commands.push({type: 'M', x: x, y: y});
};

Path.prototype.lineTo = function (x, y) {
    this.commands.push({type: 'L', x: x, y: y});
};

Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {
    this.commands.push({type: 'C', x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y});
};

Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {
    this.commands.push({type: 'Q', x1: x1, y1: y1, x: x, y: y});
};

Path.prototype.close = Path.prototype.closePath = function () {
    this.commands.push({type: 'Z'});
};

// Add the given path or list of commands to the commands of this path.
Path.prototype.extend = function (pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};

// Draw the path to a 2D context.
Path.prototype.draw = function (ctx) {
    var i, cmd;
    ctx.beginPath();
    for (i = 0; i < this.commands.length; i += 1) {
        cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

exports.Path = Path;

},{}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js":[function(require,module,exports){
// Table metadata

'use strict';

var check = require('./check');
var encode = require('./types').encode;
var sizeOf = require('./types').sizeOf;

function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

Table.prototype.sizeOf = function () {
    var v = 0;
    for (var i = 0; i < this.fields.length; i += 1) {
        var field = this.fields[i];
        var value = this[field.name];
        if (value === undefined) {
            value = field.value;
        }
        if (typeof value.sizeOf === 'function') {
            v += value.sizeOf();
        } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);
            v += sizeOfFunction(value);
        }
    }
    return v;
};

Table.prototype.encode = function () {
    return encode.TABLE(this);
};

exports.Table = Table;

},{"./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","./types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js":[function(require,module,exports){
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

'use strict';

var encoding = require('../encoding');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');
var table = require('../table');

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets, objects, count, endOffset, offsetSize, objectOffset, pos, i, value;
    offsets = [];
    objects = [];
    count = parse.getCard16(data, start);
    if (count !== 0) {
        offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    for (i = 0; i < offsets.length - 1; i += 1) {
        value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }
        objects.push(value);
    }
    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s, eof, lookup, b, n1, n2;
    s = '';
    eof = 15;
    lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        b = parser.parseByte();
        n1 = b >> 4;
        n2 = b & 15;

        if (n1 === eof) {
            break;
        }
        s += lookup[n1];

        if (n2 === eof) {
            break;
        }
        s += lookup[n2];
    }
    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1, b2, b3, b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) {
        return parseFloatOperand(parser);
    }
    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o, key, values, i, value;
    o = {};
    for (i = 0; i < entries.length; i += 1) {
        key = entries[i][0];
        values = entries[i][1];
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }
        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }
        o[key] = value;
    }
    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    var parser, entries, operands, op;
    start = start !== undefined ? start : 0;
    parser = new parse.Parser(data, start);
    entries = [];
    operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        op = parser.parseByte();
        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }
    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }
    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var i, m, value, newDict;
    newDict = {};
    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (i = 0; i < meta.length; i += 1) {
        m = meta[i];
        value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }
        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }
        newDict[m.name] = value;
    }
    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict;
    dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict;
    dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var parser, format, charset, i, sid, count;
    parser = new parse.Parser(data, start);
    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    charset = ['.notdef'];

    format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var enc, parser, format, nCodes, i, code, nRanges, first, nLeft, j;
    enc = {};
    parser = new parse.Parser(data, start);
    format = parser.parseCard8();
    if (format === 0) {
        nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            first = parser.parseCard8();
            nLeft = parser.parseCard8();
            for (j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }
    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(code, font, index) {
    var p, glyph, stack, nStems, haveWidth, width, x, y, c1x, c1y, c2x, c2y, v;
    p = new path.Path();
    stack = [];
    nStems = 0;
    haveWidth = false;
    width = font.defaultWidthX;
    x = y = 0;

    function parseStems() {
        var hasWidthArg;
        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var i, b1, b2, b3, b4, codeIndex, subrCode;
        i = 0;
        while (i < code.length) {
            v = code[i];
            i += 1;
            switch (v) {
            case 1: // hstem
                parseStems();
                break;
            case 3: // vstem
                parseStems();
                break;
            case 4: // vmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                p.moveTo(x, y);
                break;
            case 5: // rlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 6: // hlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 7: // vlineto
                while (stack.length > 0) {
                    y += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    x += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 8: // rrcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 10: // callsubr
                codeIndex = stack.pop() + font.subrsBias;
                subrCode = font.subrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 11: // return
                return;
            case 12: // escape
                v = code[i];
                i += 1;
                break;
            case 14: // endchar
                if (stack.length > 0 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                p.closePath();
                break;
            case 18: // hstemhm
                parseStems();
                break;
            case 19: // hintmask
            case 20: // cntrmask
                parseStems();
                i += (nStems + 7) >> 3;
                break;
            case 21: // rmoveto
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 22: // hmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 23: // vstemhm
                parseStems();
                break;
            case 24: // rcurveline
                while (stack.length > 2) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
            case 25: // rlinecurve
                while (stack.length > 6) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
            case 26: // vvcurveto
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 27: // hhcurveto
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 28: // shortint
                b1 = code[i];
                b2 = code[i + 1];
                stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                i += 2;
                break;
            case 29: // callgsubr
                codeIndex = stack.pop() + font.gsubrsBias;
                subrCode = font.gsubrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 30: // vhcurveto
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 31: // hvcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            default:
                if (v < 32) {
                    console.log('Glyph ' + index + ': unknown operator ' + v);
                } else if (v < 247) {
                    stack.push(v - 139);
                } else if (v < 251) {
                    b1 = code[i];
                    i += 1;
                    stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                    b1 = code[i];
                    i += 1;
                    stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                    b1 = code[i];
                    b2 = code[i + 1];
                    b3 = code[i + 2];
                    b4 = code[i + 3];
                    i += 4;
                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                }
            }
        }
    }

    parse(code);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.path = p;
    glyph.advanceWidth = width;
    return glyph;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }
    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    var header, nameIndex, topDictIndex, stringIndex, globalSubrIndex, topDict, privateDictOffset, privateDict,
        subrOffset, subrIndex, charString, charStringsIndex, charset, i;
    font.tables.cff = {};
    header = parseCFFHeader(data, start);
    nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    privateDictOffset = start + topDict['private'][1];
    privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        subrOffset = privateDictOffset + privateDict.subrs;
        subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }
    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = [];
    for (i = 0; i < font.nGlyphs; i += 1) {
        charString = charStringsIndex.objects[i];
        font.glyphs.push(parseCFFCharstring(charString, font, i));
    }
}


// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var i, sid;
    // Is the string in the CFF standard strings?
    i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }
    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }
    return sid;
}

function makeHeader() {
    return new table.Table('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Table('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }
    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {}, i, entry, value;
    for (i = 0; i < meta.length; i += 1) {
        entry = meta[i];
        value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }
            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }
    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Table('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Table('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Table('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }
    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Table('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Table('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }
    return t;
}

function glyphToOps(glyph) {
    var ops = [], path = glyph.path, x, y, i, cmd, dx, dy, dx1, dy1, dx2, dy2;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    x = 0;
    y = 0;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.type === 'M') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'L') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Q') {
            // FIXME: Add support for quad curves
            throw new Error('Writing quad curves is currently not supported.');
        } else if (cmd.type === 'C') {
            dx1 = cmd.x1 - x;
            dy1 = cmd.y1 - y;
            dx2 = cmd.x2 - cmd.x1;
            dy2 = cmd.y2 - cmd.y1;
            dx = cmd.x - cmd.x2;
            dy = cmd.y - cmd.y2;
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Z') {
            // Contours are closed automatically.
        }
    }
    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Table('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }
    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Table('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makePrivateDictIndex(privateDict) {
    var t = new table.Table('Private DICT INDEX', [
        {name: 'privateDicts', type: 'INDEX', value: []}
    ]);
    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'TABLE'},
        {name: 'nameIndex', type: 'TABLE'},
        {name: 'topDictIndex', type: 'TABLE'},
        {name: 'stringIndex', type: 'TABLE'},
        {name: 'globalSubrIndex', type: 'TABLE'},
        {name: 'charsets', type: 'TABLE'},
        {name: 'charStringsIndex', type: 'TABLE'},
        {name: 'privateDictIndex', type: 'TABLE'}
    ]);

    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyphNames.push(glyphs[i].name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    var privateDict = makePrivateDict(privateAttrs, strings);
    t.privateDictIndex = makePrivateDictIndex(privateDict);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    attrs.encoding = 0; // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js":[function(require,module,exports){
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var version, numTables, offset, platformId, encodingId, format, segCount,
        endCountParser, startCountParser, idDeltaParser, idRangeOffsetParser, glyphIndexOffset,
        endCount, startCount, i, c, idDelta, idRangeOffset, p, glyphIndex;
    var cmap = {};
    cmap.version = version = parse.getUShort(data, start);
    check.argument(version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numtables = numTables = parse.getUShort(data, start + 2);
    offset = -1;
    for (i = 0; i < numTables; i += 1) {
        platformId = parse.getUShort(data, start + 4 + (i * 8));
        encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }
    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    p = new parse.Parser(data, start + offset);
    cmap.format = format = p.parseUShort();
    check.argument(format === 4, 'Only format 4 cmap tables are supported.');
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    // segCount is stored x 2.
    cmap.segCount = segCount = p.parseUShort() >> 1;
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};

    endCountParser = new parse.Parser(data, start + offset + 14);
    startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        endCount = endCountParser.parseUShort();
        startCount = startCountParser.parseUShort();
        idDelta = idDeltaParser.parseShort();
        idRangeOffset = idRangeOffsetParser.parseUShort();
        for (c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;
                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i, j, glyph;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        for (j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }
    }
    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

     // Set up parallel segment arrays.
    var endCounts = [],
        startCounts = [],
        idDeltas = [],
        idRangeOffsets = [],
        glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }
    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;
    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/glyf.js":[function(require,module,exports){
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

'use strict';

var check = require('../check');
var _glyph = require('../glyph');
var parse = require('../parse');
var path = require('../path');

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }
        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }
    return v;
}

// Parse a TrueType glyph.
function parseGlyph(data, start, index, font) {
    var p, glyph, flag, i, j, flags,
        endPointIndices, numberOfCoordinates, repeatCount, points, point, px, py,
        component, moreComponents;
    p = new parse.Parser(data, start);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.numberOfContours = p.parseShort();
    glyph.xMin = p.parseShort();
    glyph.yMin = p.parseShort();
    glyph.xMax = p.parseShort();
    glyph.yMax = p.parseShort();
    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                repeatCount = p.parseByte();
                for (j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }
        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            points = [];
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }
                px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            component = {
                glyphIndex: p.parseUShort(),
                 xScale: 1,
                 scale01: 0,
                 scale10: 0,
                 yScale: 1,
                 dx: 0,
                 dy: 0
             };
            if ((flags & 1) > 0) {
                // The arguments are words
                component.dx = p.parseShort();
                component.dy = p.parseShort();
            } else {
                // The arguments are bytes
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            }
            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }
    return glyph;
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints, i, pt, newPt;
    newPoints = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}


function getContours(points) {
    var contours, currentContour, i, pt;
    contours = [];
    currentContour = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p, contours, i, realFirstPoint, j, contour, pt, firstPt,
        prevPt, midPt, curvePt, lastPt;
    p = new path.Path();
    if (!points) {
        return p;
    }
    contours = getContours(points);
    for (i = 0; i < contours.length; i += 1) {
        contour = contours[i];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }
            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }
        p.moveTo(firstPt.x, firstPt.y);

        for (j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            pt = contour[j];
            prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }
        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }
    p.closePath();
    return p;
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs, i, j, offset, nextOffset, glyph,
        component, componentGlyph, transformedPoints;
    glyphs = [];
    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        offset = loca[i];
        nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(parseGlyph(data, start + offset, i, font));
        } else {
            glyphs.push(new _glyph.Glyph({font: font, index: i}));
        }
    }
    // Go over the glyphs again, resolving the composite glyphs.
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        if (glyph.isComposite) {
            for (j = 0; j < glyph.components.length; j += 1) {
                component = glyph.components[j];
                componentGlyph = glyphs[component.glyphIndex];
                if (componentGlyph.points) {
                    transformedPoints = transformPoints(componentGlyph.points, component);
                    glyph.points = glyph.points.concat(transformedPoints);
                }
            }
        }
        glyph.path = getPath(glyph.points);
    }
    return glyphs;
}

exports.parse = parseGlyfTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../glyph":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/glyph.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../path":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/path.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/gpos.js":[function(require,module,exports){
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start),
        n = p.parseUShort(),
        list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }
    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort(),
        count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    }
    else if (format === 2) {
        var i, begin, end, index, coverage = [];
        for (; count--;) {
            begin = p.parseUShort();
            end = p.parseUShort();
            index = p.parseUShort();
            for (i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }
        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort(),
            glyphCount = p.parseUShort(),
            classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    }
    else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort(),
            startGlyphs = [],
            endGlyphs = [],
            classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }
        return function(glyphID) {
            var l, c, r;
            l = 0;
            r = startGlyphs.length - 1;
            while (l < r) {
                c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }
            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }
            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    var format, coverageOffset, coverage, valueFormat1, valueFormat2,
        sharedPairSets, firstGlyph, secondGlyph, value1, value2;
    // This part is common to format 1 and format 2 subtables
    format = p.parseUShort();
    coverageOffset = p.parseUShort();
    coverage = parseCoverageTable(data, start+coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    valueFormat1 = p.parseUShort();
    valueFormat2 = p.parseUShort();
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount, pairSetOffsets, pairSetOffset, sharedPairSet, pairValueCount, pairSet;
        pairSetCount = p.parseUShort();
        pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            pairSetOffset = pairSetOffsets[firstGlyph];
            sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }
            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }
        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    }
    else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset, classDef2Offset, class1Count, class2Count, i, j,
            getClass1, getClass2, kerningMatrix, kerningRow, covered;
        classDef1Offset = p.parseUShort();
        classDef2Offset = p.parseUShort();
        class1Count = p.parseUShort();
        class2Count = p.parseUShort();
        getClass1 = parseClassDefTable(data, start+classDef1Offset);
        getClass2 = parseClassDefTable(data, start+classDef2Offset);

        // Parse kerning values by class pair.
        kerningMatrix = [];
        for (i = 0; i < class1Count; i++) {
            kerningRow = kerningMatrix[i] = [];
            for (j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        covered = {};
        for(i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return null;
            var class1 = getClass1(leftGlyph),
                class2 = getClass2(rightGlyph),
                kerningRow = kerningMatrix[class1];
            return kerningRow ? kerningRow[class2] : null;
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var table, lookupType, lookupFlag, useMarkFilteringSet, subTableCount, subTableOffsets, subtables, i;
    lookupType = p.parseUShort();
    lookupFlag = p.parseUShort();
    useMarkFilteringSet = lookupFlag & 0x10;
    subTableCount = p.parseUShort();
    subTableOffsets = p.parseOffset16List(subTableCount);
    table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        subtables = [];
        for (i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }
            return 0;
        };
    }
    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p, tableVersion, lookupListOffset, scriptList, i, featureList, lookupCount,
        lookupTableOffsets, lookupListAbsoluteOffset, table;

    p = new parse.Parser(data, start);
    tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    scriptList = parseTaggedListTable(data, start+p.parseUShort());
    // 'kern' is the feature we are looking for.
    featureList = parseTaggedListTable(data, start+p.parseUShort());

    // LookupList
    lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    lookupCount = p.parseUShort();
    lookupTableOffsets = p.parseOffset16List(lookupCount);
    lookupListAbsoluteOffset = start + lookupListOffset;
    for (i = 0; i < lookupCount; i++) {
        table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js":[function(require,module,exports){
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

'use strict';

var check = require('../check');
var parse = require('../parse');
var table = require('../table');

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {},
        p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();     // 50
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: 0},
        {name: 'modified', type: 'LONGDATETIME', value: 0},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js":[function(require,module,exports){
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {},
        p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js":[function(require,module,exports){
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var p, i, glyph, advanceWidth, leftSideBearing;
    p = new parse.Parser(data, start);
    for (i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        glyph = glyphs[i];
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }
    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;




},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/kern.js":[function(require,module,exports){
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

'use strict';

var check = require('../check');
var parse = require('../parse');

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var pairs, p, tableVersion, subTableVersion, nPairs,
        i, leftIndex, rightIndex, value;
    pairs = {};
    p = new parse.Parser(data, start);
    tableVersion = p.parseUShort();
    check.argument(tableVersion === 0, 'Unsupported kern table version.');
    // Skip nTables.
    p.skip('uShort', 1);
    subTableVersion = p.parseUShort();
    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subTableLength, subTableCoverage
    p.skip('uShort', 2);
    nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (i = 0; i < nPairs; i += 1) {
        leftIndex = p.parseUShort();
        rightIndex = p.parseUShort();
        value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

exports.parse = parseKernTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/loca.js":[function(require,module,exports){
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

'use strict';

var parse = require('../parse');

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p, parseFn, glyphOffsets, glyphOffset, i;
    p = new parse.Parser(data, start);
    parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    glyphOffsets = [];
    for (i = 0; i < numGlyphs + 1; i += 1) {
        glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}

exports.parse = parseLocaTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js":[function(require,module,exports){
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {},
        p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js":[function(require,module,exports){
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

'use strict';

var encode = require('../types').encode;
var parse = require('../parse');
var table = require('../table');

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'licence',                // 13
    'licenceURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

// Parse the naming `name` table
// Only Windows Unicode English names are supported.
// Format 1 additional fields are not supported
function parseNameTable(data, start) {
    var name = {},
        p = new parse.Parser(data, start);
    name.format = p.parseUShort();
    var count = p.parseUShort(),
        stringOffset = p.offset + p.parseUShort();
    var platformID, encodingID, languageID, nameID, property, byteLength,
        offset, str, i, j, codePoints;
    var unknownCount = 0;
    for(i = 0; i < count; i++) {
        platformID = p.parseUShort();
        encodingID = p.parseUShort();
        languageID = p.parseUShort();
        nameID = p.parseUShort();
        property = nameTableNames[nameID];
        byteLength = p.parseUShort();
        offset = p.parseUShort();
        // platformID - encodingID - languageID standard combinations :
        // 1 - 0 - 0 : Macintosh, Roman, English
        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {
            codePoints = [];
            var length = byteLength/2;
            for(j = 0; j < length; j++, offset += 2) {
                codePoints[j] = parse.getShort(data, stringOffset+offset);
            }
            str = String.fromCharCode.apply(null, codePoints);
            if (property) {
                name[property] = str;
            }
            else {
                unknownCount++;
                name['unknown'+unknownCount] = str;
            }
        }

    }
    if (name.format === 1) {
        name.langTagCount = p.parseUShort();
    }
    return name;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Table('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

function addMacintoshNameRecord(t, recordID, s, offset) {
    // Macintosh, Roman, English
    var stringBytes = encode.STRING(s);
    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
    t.strings.push(stringBytes);
    offset += stringBytes.length;
    return offset;
}

function addWindowsNameRecord(t, recordID, s, offset) {
    // Windows, Unicode BMP (UCS-2), US English
    var utf16Bytes = encode.UTF16(s);
    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
    t.strings.push(utf16Bytes);
    offset += utf16Bytes.length;
    return offset;
}

function makeNameTable(options) {
    var i, s;
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: 0},
        {name: 'stringOffset', type: 'USHORT', value: 0}
    ]);
    t.records = [];
    t.strings = [];
    var offset = 0;
    // Add Macintosh records first
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addMacintoshNameRecord(t, i, s, offset);
        }
    }
    // Then add Windows records
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addWindowsNameRecord(t, i, s, offset);
        }
    }

    t.count = t.records.length;
    t.stringOffset = 6 + t.count * 12;
    for (i = 0; i < t.records.length; i += 1) {
        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});
    }
    for (i = 0; i < t.strings.length; i += 1) {
        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});
    }
    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","../types":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js":[function(require,module,exports){
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

'use strict';

var parse = require('../parse');
var table = require('../table');

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {},
        p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 0},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 0},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 0},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseOS2Table;
exports.make = makeOS2Table;

},{"../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js":[function(require,module,exports){
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

'use strict';

var encoding = require('../encoding');
var parse = require('../parse');
var table = require('../table');

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {},
        p = new parse.Parser(data, start),
        i, nameLength;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
    case 1:
        post.names = encoding.standardNames.slice();
        break;
    case 2:
        post.numberOfGlyphs = p.parseUShort();
        post.glyphNameIndex = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.glyphNameIndex[i] = p.parseUShort();
        }
        post.names = [];
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
        }
        break;
    case 2.5:
        post.numberOfGlyphs = p.parseUShort();
        post.offset = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.offset[i] = p.parseChar();
        }
        break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;

},{"../encoding":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/encoding.js","../parse":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/parse.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/sfnt.js":[function(require,module,exports){
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

'use strict';

var check = require('../check');
var table = require('../table');

var cmap = require('./cmap');
var cff = require('./cff');
var head = require('./head');
var hhea = require('./hhea');
var hmtx = require('./hmtx');
var maxp = require('./maxp');
var _name = require('./name');
var os2 = require('./os2');
var post = require('./post');

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }
    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }
    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Table('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function (r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs[glyphIndex];
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}

// Return the smallest and largest unicode values of the characters in this font.
// For most fonts the smallest value would be 20 (space).
function charCodeBounds(glyphs) {
    var minCode, maxCode;
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        if (glyph.unicode >= 20) {
            if (minCode === undefined) {
                minCode = glyph.unicode;
            } else if (glyph.unicode < minCode) {
                minCode = glyph.unicode;
            }
            if (maxCode === undefined) {
                maxCode = glyph.unicode;
            } else if (glyph.unicode > maxCode) {
                maxCode = glyph.unicode;
            }
        }
    }
    return [minCode, maxCode];
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }
    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs[i];
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = globals.yMax;
    globals.descender = globals.yMin;

    var headTable = head.make({
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax
    });

    var hheaTable = hhea.make({
        // Adding a little here makes OS X Quick Look happy
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var codeBounds = charCodeBounds(font.glyphs);
    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: 500, // Medium FIXME Make this configurable
        usWidthClass: 5, // Medium (normal) FIXME Make this configurable
        usFirstCharIndex: codeBounds[0],
        usLastCharIndex: codeBounds[1],
        ulUnicodeRange1: 0x00000001, // Basic Latin
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.ascender,
        usWinDescent: -globals.descender,
        ulCodePageRange1: 0x00000001, // Basic Latin
        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });


    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var fullName = font.familyName + ' ' + font.styleName;
    var postScriptName = font.familyName.replace(/\s/g, '') + '-' + font.styleName;
    var nameTable = _name.make({
        copyright: font.copyright,
        fontFamily: font.familyName,
        fontSubfamily: font.styleName,
        uniqueID: font.manufacturer + ':' + fullName,
        fullName: fullName,
        version: font.version,
        postScriptName: postScriptName,
        trademark: font.trademark,
        manufacturer: font.manufacturer,
        designer: font.designer,
        description: font.description,
        manufacturerURL: font.manufacturerURL,
        designerURL: font.designerURL,
        license: font.license,
        licenseURL: font.licenseURL,
        preferredFamily: font.familyName,
        preferredSubfamily: font.styleName
    });
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.version,
        fullName: fullName,
        familyName: font.familyName,
        weightName: font.styleName,
        postScriptName: postScriptName
    });
    // Order the tables according to the the OpenType specification 1.4.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];

    var sfntTable = makeSfntTable(tables);

    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    headTable.checkSumAdjustment = 0xB1B0AFBA - checkSum;

    // Build the font again, now with the proper checkSum.
    sfntTable = makeSfntTable(tables);

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;

},{"../check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js","../table":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/table.js","./cff":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cff.js","./cmap":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/cmap.js","./head":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/head.js","./hhea":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hhea.js","./hmtx":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/hmtx.js","./maxp":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/maxp.js","./name":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/name.js","./os2":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/os2.js","./post":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/tables/post.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/types.js":[function(require,module,exports){
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

'use strict';

var polyfill = require('../node_modules/es6-collections');
var check = require('./check');

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

var decode = {};
var encode = {};
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function () {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

// Convert an 8-bit unsigned integer to a list of 1 byte.
encode.BYTE = function (v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};

sizeOf.BYTE = constant(1);

// Convert a 8-bit signed integer to a list of 1 byte.
encode.CHAR = function (v) {
    return [v.charCodeAt(0)];
};

sizeOf.BYTE = constant(1);

// Convert an ASCII string to a list of bytes.
encode.CHARARRAY = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.CHARARRAY = function (v) {
    return v.length;
};

// Convert a 16-bit unsigned integer to a list of 2 bytes.
encode.USHORT = function (v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.USHORT = constant(2);

// Convert a 16-bit signed integer to a list of 2 bytes.
encode.SHORT = function (v) {
    // Two's complement
    if (v >= LIMIT16){
        v = - ( 2 * LIMIT16 - v);
    }
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.SHORT = constant(2);

// Convert a 24-bit unsigned integer to a list of 3 bytes.
encode.UINT24 = function (v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.UINT24 = constant(3);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.ULONG = function (v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.ULONG = constant(4);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.LONG = function (v) {
     // Two's complement
    if (v >= LIMIT32){
        v = - ( 2 * LIMIT32 - v);
    }
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;


// FIXME Implement LONGDATETIME
encode.LONGDATETIME = function () {
    return [0, 0, 0, 0, 0, 0, 0, 0];
};

sizeOf.LONGDATETIME = constant(8);

// Convert a 4-char tag to a list of 4 bytes.
encode.TAG = function (v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
encode.NUMBER = function (v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131 ) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

sizeOf.NUMBER = function (v) {
    return encode.NUMBER(v).length;
};

// Convert a signed number between -32768 and +32767 to a three-byte value.
// This ensures we always use three bytes, but is not the most compact format.
encode.NUMBER16 = function (v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER16 = constant(2);

// Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
// This is useful if you want to be sure you always use four bytes,
// at the expense of wasting a few bytes for smaller numbers.
encode.NUMBER32 = function (v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER32 = constant(4);

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

// Convert a ASCII string to a list of UTF16 bytes.
encode.UTF16 = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(0);
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.UTF16 = function (v) {
    return v.length * 2;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
encode.INDEX = function (l) {
    var offSize, offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
        dataSize, i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    offset = 1; // First offset is always 1.
    offsets = [offset];
    data = [];
    dataSize = 0;
    for (i = 0; i < l.length; i += 1) {
        v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        dataSize += v.length;
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    encodedOffsets = [];
    offSize = (1 + Math.floor(Math.log(dataSize)/Math.log(2)) / 8) | 0;
    offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

sizeOf.INDEX = function (v) {
    return encode.INDEX(v).length;
};

// Convert an object to a CFF DICT structure.
// The keys should be numeric.
// The values should be objects containing name / type / value.
encode.DICT = function (m) {
    var d = [],
        keys = Object.keys(m),
        length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

sizeOf.DICT = function (m) {
    return encode.DICT(m).length;
};

encode.OPERATOR = function (v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

encode.OPERAND = function (v, type) {
    var d, i;
    d = [];
    if (Array.isArray(type)) {
        for (i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else {
            // FIXME Add support for booleans
            d = d.concat(encode.NUMBER(v));
        }
    }
    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

var cwm = new WeakMap();
// Convert a list of CharString operations to bytes.
encode.CHARSTRING = function (ops) {
    if ( cwm.has( ops ) ) {
        return cwm.get( ops );
    }

    var d = [],
        length = ops.length,
        op,
        i;

    for (i = 0; i < length; i += 1) {
        op = ops[i];
        d = d.concat( encode[op.type](op.value) );
    }

    cwm.set( ops, d );

    return d;
};

sizeOf.CHARSTRING = function (ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

// Convert an object containing name / type / value to bytes.
encode.OBJECT = function (v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

// Convert a table object to bytes.
// A table contains a list of fields containing the metadata (name, type and default value).
// The table itself has the field values set as attributes.
encode.TABLE = function (table) {
    var d = [],
        length = table.fields.length,
        i;

    for (i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        var bytes = encodingFunction(value);
        d = d.concat(bytes);
    }
    return d;
};

// Merge in a list of bytes.
encode.LITERAL = function (v) {
    return v;
};

sizeOf.LITERAL = function (v) {
    return v.length;
};


exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

},{"../node_modules/es6-collections":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/node_modules/es6-collections/index.js","./check":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/check.js"}],"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-worker.js":[function(require,module,exports){
/*!
 * Paper.js v0.9.21 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Sat Nov 22 19:23:35 2014 -0800
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && (!exclude || !exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var orig = props._filtering || props;
			for (var key in orig) {
				if (orig.hasOwnProperty(key) && !(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			function checkKeys(o1, o2) {
				for (var i in o1)
					if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
						return false;
				return true;
			}
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				if (obj1.length !== obj2.length)
					return false;
				for (var i = 0, l = obj1.length; i < l; i++) {
					if (!Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			if (obj1 && typeof obj1 === 'object'
					&& obj2 && typeof obj2 === 'object') {
				if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
					return false;
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)
							&& !Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				for (var i in obj)
					if (obj.hasOwnProperty(i))
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data) {
			var res = json;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (!isDictionary) {
					if (_data.dictionary && json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
				}
				res = [];
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data));
				if (isDictionary) {
					_data.dictionary = res[0];
				} else if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var entry = this._eventTypes[type];
			if (entry) {
				var handlers = this._callbacks = this._callbacks || {};
				handlers = handlers[type] = handlers[type] || [];
				if (handlers.indexOf(func) === -1) {
					handlers.push(func);
					if (entry.install && handlers.length == 1)
						entry.install.call(this, type);
				}
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (entry && handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false
					&& event && event.stop) {
				event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var entry = this._eventTypes[type],
					func = entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;

	},

	version: '0.9.21',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		cos = Math.cos,
		PI = Math.PI,
		TOLERANCE = 10e-6,
		EPSILON = 10e-12;

	function setupRoots(roots, min, max) {
		var unbound = min === undefined,
			minE = min - EPSILON,
			maxE = max + EPSILON,
			count = 0;
		return function(root) {
			if (unbound || root > minE && root < maxE)
				roots[count++] = root < min ? min : root > max ? max : root;
			return count;
		};
	}

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var add = setupRoots(roots, min, max);

			if (abs(a) < EPSILON) {
				if (abs(b) >= EPSILON)
					return add(-c / b);
				return abs(c) < EPSILON ? -1 : 0;
			}
			var p = b / (2 * a);
			var q = c / a;
			var p2 = p * p;
			if (p2 < q - EPSILON)
				return 0;
			var s = p2 > q ? sqrt(p2 - q) : 0,
				count = add(s - p);
			if (s > 0)
				count = add(-s - p);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			if (abs(a) < EPSILON)
				return Numerical.solveQuadratic(b, c, d, roots, min, max);

			b /= a;
			c /= a;
			d /= a;
			var add = setupRoots(roots, min, max),
				bb = b * b,
				p = (bb - 3 * c) / 9,
				q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
				ppp = p * p * p,
				D = q * q - ppp;
			b /= 3;
			if (abs(D) < EPSILON) {
				if (abs(q) < EPSILON)
					return add(-b);
				var sqp = sqrt(p),
					snq = q > 0 ? 1 : -1;
				add(-snq * 2 * sqp - b);
				return add(snq * sqp - b);
			}
			if (D < 0) {
				var sqp = sqrt(p),
					phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
					t = -2 * sqp,
					o = 2 * PI / 3;
				add(t * cos(phi) - b);
				add(t * cos(phi + o) - b);
				return add(t * cos(phi - o) - b);
			}
			var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
			return add(A + p / A - b);
		}
	};
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isColinear: function(point) {
		return Math.abs(this.cross(point)) < 0.00001;
	},

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 0.00001;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function() {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = avx * bvy - avy * bvx;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy;
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			if (Numerical.isZero(vx))
				return x - px;
			var m = vy / vx,
				b = py - m * px;
			return (y - (m * x) - b) / Math.sqrt(m * m + 1);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	addChild: function(child) {
		if (child instanceof Layer) {
			Base.splice(this.layers, [child]);
			if (!this._activeLayer)
				this._activeLayer = child;
		} else if (child instanceof Item) {
			(this._activeLayer
				|| this.addChild(new Layer(Item.NO_INSERT))).addChild(child);
		} else {
			child = null;
		}
		return child;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = Symbol._id = (Symbol._id || 0) + 1;
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = Item._id = (Item._id || 0) + 1;
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, parent: true }, true);
		return hasProps;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getClassName: function() {
		return this._class;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments);
		this._position = undefined;
	},

	_pivot: null,

	getRegistration: '#getPivot',
	setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		var cacheParent = this._parent || this._parentSymbol;
		if (cacheParent) {
			var id = cacheItem._id,
				ref = cacheParent._boundsCache = cacheParent._boundsCache || {
					ids: {},
					list: []
				};
			if (!ref.ids[id]) {
				ref.list.push(cacheItem);
				ref.ids[id] = cacheItem;
			}
		}
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function(matrix) {
		this._matrix.initialize(matrix);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(transform) {
		if (this._applyMatrix = this._canApplyMatrix && !!transform)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert) {
		copy.setStyle(this._style);
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				copy.addChild(this._children[i].clone(false), true);
		}
		if (insert || insert === undefined)
			copy.insertAbove(this);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide', '_applyMatrix'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		copy._matrix.initialize(this._matrix);
		copy._data = this._data ? Base.clone(this._data) : null;
		copy.setSelected(this._selected);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(),
				_matrix || item._matrix).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.00001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		if (typeof name === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param) {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect =	bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: rect,
					overlapping: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param.items,
				inside = param.inside,
				overlapping = param.overlapping;
			matrix = inside && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (inside) {
					var bounds = child.getBounds(childMatrix);
					if (!inside.intersects(bounds))
						continue;
					if (!(inside && inside.contains(bounds)) && !(overlapping
							&& overlapping.intersects(child, childMatrix)))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = this.insertChildren(index, [item], _preserve);
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insert: function(above, item, _preserve) {
		if (!item._parent)
			return null;
		var index = item._index + (above ? 1 : 0);
		if (item._parent === this._parent && index > this._index)
			index--;
		return item._parent.insertChild(index, this, _preserve);
	},

	insertAbove: function(item, _preserve) {
		return this._insert(true, item, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return this._insert(false, item, _preserve);
	},

	sendToBack: function() {
		return this._parent.insertChild(0, this);
	},

	bringToFront: function() {
		return this._parent.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
				&& (!_matrix.isIdentity() || matrix);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2;
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notify) {
		if (this._parent)
			return _remove.base.call(this, notify);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			project._needsUpdate = true;
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insert: function _insert(above, item, _preserve) {
		if (item instanceof Layer && !item._parent) {
			this._remove(true, true);
			Base.splice(item._project.layers, [this],
					item._index + (above ? 1 : 0), 0);
			this._setProject(item._project, true);
			return this;
		}
		return _insert.base.call(this, above, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.setStyle(this._style);
		path.transform(this._matrix);
		if (insert || insert === undefined)
			path.insertAbove(this);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rect' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size)
			this._size = new Size();
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setCanvas(copyCanvas);
		}
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size.equals(size)) {
			var element = this.getElement();
			this.setCanvas(CanvasProvider.getCanvas(size));
			if (element)
				this.getContext(true).drawImage(element, 0, 0,
						size.width, size.height);
		}
	},

	getWidth: function() {
		return this._size.width;
	},

	getHeight: function() {
		return this._size.height;
	},

	isEmpty: function() {
		return this._size.width === 0 && this._size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
		} else {
			this._image = image;
			this._canvas = null;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

	},

	getElement: function() {
		return this._canvas || this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		ctx.drawImage(this.getElement(),
				-this._size.width / 2, -this._size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isLinear() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	isLinear: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	setLinear: function(linear) {
		if (linear) {
			this._handleIn.set(0, 0);
			this._handleOut.set(0, 0);
		} else {
		}
	},

	isColinear: function(segment) {
		var next1 = this.getNext(),
			next2 = segment.getNext();
		return this._handleOut.isZero() && next1._handleIn.isZero()
				&& segment._handleOut.isZero() && next2._handleIn.isZero()
				&& next1._point.subtract(this._point).isColinear(
					next2._point.subtract(segment._point));
	},

	isOrthogonal: function() {
		var prev = this.getPrevious(),
			next = this.getNext();
		return prev._handleOut.isZero() && this._handleIn.isZero()
			&& this._handleOut.isZero() && next._handleIn.isZero()
			&& this._point.subtract(prev._point).isOrthogonal(
					next._point.subtract(this._point));
	},

	isArc: function() {
		var next = this.getNext(),
			handle1 = this._handleOut,
			handle2 = next._handleIn,
			kappa = 0.5522847498307936;
		if (handle1.isOrthogonal(handle2)) {
			var from = this._point,
				to = next._point,
				corner = new Line(from, handle1, true).intersect(
						new Line(to, handle2, true), true);
			return corner && Numerical.isZero(handle1.getLength() /
					corner.subtract(from).getLength() - kappa)
				&& Numerical.isZero(handle2.getLength() /
					corner.subtract(to).getLength() - kappa);
		}
		return false;
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	isLinear: function() {
		return this._segment1._handleOut.isZero()
				&& this._segment2._handleIn.isZero();
	},

	isHorizontal: function() {
		return this.isLinear() && Numerical.isZero(
				this._segment1._point._y - this._segment2._point._y);
	},

	getIntersections: function(curve) {
		return Curve.getIntersections(this.getValues(), curve.getValues(),
				this, curve, []);
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.00001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this;
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	evaluate: function(v, t, type) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.00001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance && c1x === p1x && c1y === p1y
						|| t > 1 - tolerance && c2x === p2x && c2y === p2y) {
					x = c2x - c1x;
					y = c2y - c1y;
				} else if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by;
					return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.00001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
			sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
			tx, ty;
		for (var cx = 0;  sx == -1 || cx < sx;) {
			if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
				for (var cy = 0; sy == -1 || cy < sy;) {
					if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
						if (sx == -1) tx = ty;
						else if (sy == -1) ty = tx;
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx == -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return v;
	},

	isLinear: function(v) {
		var isZero = Numerical.isZero;
		return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.00001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve.evaluate(values, isParameter
					? offset : Curve.getParameterAt(values, offset, 0), index);
		};
		this[name] = function(parameter) {
			return Curve.evaluate(this.getValues(), parameter, index);
		};
	},
{
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		if (!isParameter)
			offset = this.getParameterAt(offset);
		return offset >= 0 && offset <= 1 && new CurveLocation(this, offset);
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(
						Curve.evaluate(values, t, 0), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.00001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.evaluate(values, minT, 0);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

}),
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (Math.abs(offset) >= rangeLength)
				return forward ? b : a;
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 16,
					0.00001);
		}
	};
}, new function() {
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 20)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.00001,
			hullEpsilon = 1e-9,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin <= hullEpsilon && recursion > 3) {
			tMinNew = (tMax + tMin) / 2;
			tMaxNew = tMinNew;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return false;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.8 && tDiff > 0.8) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.evaluate(v2, t2, 0),
						curve1, t1, Curve.evaluate(v1, t1, 0));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		} else {
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		var tProxy,
			tVal = null,
			px, py,
			qx, qy;
		for (var i = 0, l = hullBottom.length - 1; i < l; i++) {
			py = hullBottom[i][1];
			qy = hullBottom[i + 1][1];
			if (py < qy) {
				tProxy = null;
			} else if (qy <= dMax) {
				px = hullBottom[i][0];
				qx = hullBottom[i + 1][0];
				tProxy = px + (dMax - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		if (hullTop[0][1] <= dMax)
			tProxy = hullTop[0][0];
		for (var i = 0, l = hullTop.length - 1; i < l; i++) {
			py = hullTop[i][1];
			qy = hullTop[i + 1][1];
			if (py >= dMin) {
				tVal = tProxy;
			} else if (py > qy) {
				tVal = null;
			} else if (qy >= dMin) {
				px = hullTop[i][0];
				qx = hullTop[i + 1][0];
				tVal = px + (dMin  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		return tVal;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.evaluate(rvc, tc, 0).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, curve1, curve2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, curve1, curve2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
		this._curve = curve;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
		this._parameter = parameter;
		this._point = point;
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function(_uncached) {
		if (!this._curve || _uncached) {
			this._curve = this._segment1.getCurve();
			if (this._curve.getParameterOf(this._point) == null)
				this._curve = this._segment2.getPrevious().getCurve();
		}
		return this._curve;
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			var param = this._parameter2;
			this._intersection = intersection = new CurveLocation(
					this._curve2, param, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getOffset: function() {
		var path = this.getPath();
		return path ? path._getOffset(this) : this.getCurveOffset();
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getParameter: function(_uncached) {
		if ((this._parameter == null || _uncached) && this._point) {
			var curve = this.getCurve(_uncached);
			this._parameter = curve && curve.getParameterOf(this._point);
		}
		return this._parameter;
	},

	getPoint: function(_uncached) {
		if ((!this._point || _uncached) && this._parameter != null) {
			var curve = this.getCurve(_uncached);
			this._point = curve && curve.getPointAt(this._parameter, true);
		}
		return this._point;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(true);
		return curve && curve.divide(this.getParameter(true), true);
	},

	split: function() {
		var curve = this.getCurve(true);
		return curve && curve.split(this.getParameter(true), true);
	},

	equals: function(loc) {
		var isZero = Numerical.isZero;
		return this === loc
				|| loc
					&& this._curve === loc._curve
					&& this._curve2 === loc._curve2
					&& isZero(this._parameter - loc._parameter)
					&& isZero(this._parameter2 - loc._parameter2)
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
}, Base.each(['getTangent', 'getNormal', 'getCurvature'], function(name) {
	var get = name + 'At';
	this[name] = function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve[get](parameter, true);
	};
}, {}));

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _matrix, _expand) {
		if (this === path)
			path = null;
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
				: matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			MIN = 1e-11,
			MAX = 1 - 1e-11;
		if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= MAX) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= MIN && t <= MAX;
						}
				);
			}
		}
		var last = locations.length - 1;
		for (var i = last; i >= 0; i--) {
			var loc = locations[i],
				next = loc._curve.getNext(),
				next2 = loc._curve2.getNext();
			if (next && loc._parameter >= MAX) {
				loc._parameter = 0;
				loc._curve = next;
			}
			if (next2 && loc._parameter2 >= MAX) {
				loc._parameter2 = 0;
				loc._curve2 = next2;
			}
		}

		function compare(loc1, loc2) {
			var path1 = loc1.getPath(),
				path2 = loc2.getPath();
			return path1 === path2
					? (loc1.getIndex() + loc1.getParameter())
							- (loc2.getIndex() + loc2.getParameter())
					: path1._id - path2._id;
		}

		if (last > 0) {
			locations.sort(compare);
			for (var i = last; i >= 1; i--) {
				if (locations[i].equals(locations[i === 0 ? last : i - 1])) {
					locations.splice(i, 1);
					last--;
				}
			}
		}
		if (_expand) {
			for (var i = last; i >= 0; i--)
				locations.push(locations[i].getIntersection());
			locations.sort(compare);
		}
		return locations;
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				if (move && previous && previous !== 'z')
					this.closePath(true);
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[0], +coords[1]),
							+coords[2], +coords[4], +coords[3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (this._curves && !(flags & 16)) {
				for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isPolygon: function() {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if (!this._segments[i].isLinear())
				return false;
		}
		return true;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.evaluate(pos, 0)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.00001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else if (index > 0) {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (last1._point.equals(last2._point))
				path.reverse();
			var first1,
				first2 = path.getFirstSegment();
			if (last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				first1 = this.getFirstSegment();
				if (first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isColinear(i, j) {
			return segments[i].isColinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (this.isPolygon() && segments.length === 4
				&& isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			shape.setStyle(this._style);
			if (insert || insert === undefined)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset;
			return curves[index].getLocationAt(offset - index, true);
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}), new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() {

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					EPSILON = 1e-11,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < EPSILON)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++) {
			var v = Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]);
			for (var j = 2; j < 8; j += 2)
				sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
		}
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isColinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().normalize(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : mx, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
}, new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	function computeBoolean(path1, path2, operator, subtract) {
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (!_path1.isClockwise())
			_path1.reverse();
		if (_path2 && !(subtract ^ _path2.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, null, true));

		var chain = [],
			windings = [],
			lengths = [],
			segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = windings.length = lengths.length = 0;
			var totalLength = 0,
				startSeg = segment;
			do {
				chain.push(segment);
				lengths.push(totalLength += segment.getCurve().getLength());
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * Math.random(),
					amount = lengths.length,
					k = 0;
				do {
					if (lengths[k] >= length) {
						if (k > 0)
							length -= lengths[k - 1];
						break;
					}
				} while (++k < amount);
				var curve = chain[k].getCurve(),
					point = curve.getPointAt(length),
					hor = curve.isHorizontal(),
					path = curve._path;
				if (path._parent instanceof CompoundPath)
					path = path._parent;
				windings[j] = subtract && _path2
						&& (path === _path1 && _path2._getWinding(point, hor)
						|| path === _path2 && !_path1._getWinding(point, hor))
						? 0
						: getWinding(point, monoCurves, hor);
			}
			windings.sort();
			var winding = windings[1];
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j]._winding = winding;
		}
		var result = new CompoundPath();
		result.addChildren(tracePaths(segments, operator), true);
		_path1.remove();
		if (_path2)
			_path2.remove();
		result = result.reduce();
		result.setStyle(path1._style);
		return result;
	}

	function splitPath(intersections) {
		var TOLERANCE = 0.00001,
			linearSegments;

		function resetLinear() {
			for (var i = 0, l = linearSegments.length; i < l; i++) {
				var segment = linearSegments[i];
				segment._handleOut.set(0, 0);
				segment._handleIn.set(0, 0);
			}
		}

		for (var i = intersections.length - 1, curve, prevLoc; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prevLoc && prevLoc._curve === loc._curve
					&& prevLoc._parameter > 0) {
				t /= prevLoc._parameter;
			} else {
				if (linearSegments)
					resetLinear();
				curve = loc._curve;
				linearSegments = curve.isLinear() && [];
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
			} else {
				segment = t < TOLERANCE
					? curve._segment1
					: t > 1 - TOLERANCE
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			if (linearSegments)
				linearSegments.push(segment);
			prevLoc = loc;
		}
		if (linearSegments)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var TOLERANCE = 0.00001,
			x = point.x,
			y = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs,
			MAX = 1 - TOLERANCE;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = y - TOLERANCE,
				yAfter = y + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y0 = Curve.evaluate(values, roots[j], 0).y;
						if (y0 < yBefore && y0 > yTop) {
							yTop = y0;
						} else if (y0 > yAfter && y0 < yBottom) {
							yBottom = y0;
						}
					}
				}
			}
			yTop = (yTop + y) / 2;
			yBottom = (yBottom + y) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(x, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(x, yBottom), curves);
		} else {
			var xBefore = x - TOLERANCE,
				xAfter = x + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding,
					next = curve.next;
				if (winding && (winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
					&& Curve.solveCubic(values, 1, y, roots, 0,
						!next.winding && next.values[1] === y ? 1 : MAX) === 1){
					var t = roots[0],
						x0 = Curve.evaluate(values, t, 0).x,
						slope = Curve.evaluate(values, t, 1).y;
					if (abs(slope) < TOLERANCE && !Curve.isLinear(values)
							|| t < TOLERANCE && slope * Curve.evaluate(
								curve.previous.values, t, 1).y < 0) {
						if (testContains && x0 >= xBefore && x0 <= xAfter) {
							++windLeft;
							++windRight;
						}
					} else if (x0 <= xBefore) {
						windLeft += winding;
					} else if (x0 >= xAfter) {
						windRight += winding;
					}
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		operator = operator || function() {
			return true;
		};
		var paths = [],
			ZERO = 1e-3,
			ONE = 1 - 1e-3;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false,
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? ZERO : ONE, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(ONE, true),
							t4 = c4.getTangentAt(ZERO, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isPolygon() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1 || w === 0;
			}, false);
		},

		intersect: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 2;
			}, false);
		},

		subtract: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1;
			}, true);
		},

		exclude: function(path) {
			return new Group([this.subtract(path), path.subtract(this)]);
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					TOLERANCE = 0.00001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE,
						1 - TOLERANCE);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		this.addChildren(children);
		var clockwise = children[0].isClockwise();
		for (var i = 1, l = children.length; i < l; i++) {
			var point = children[i].getInteriorPoint(),
				counters = 0;
			for (var j = i - 1; j >= 0; j--) {
				if (children[j].contains(point))
					counters++;
			}
			children[i].setClockwise(counters % 2 === 0 && clockwise);
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 0.00001) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	evaluate: function(offset, type) {
		var param = this.getParameterAt(offset);
		return Curve.evaluate(this.curves[param.index], param.value, type);
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset) {
			return this.evaluate(offset, index);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		this.points = [];
		var segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				this.points.push(point);
				prev = point;
			}
		}
		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length;
		this.segments = length > 0 ? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());
		return this.segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-11,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1);
		epsilon *= segLength;
		if (alpha1 < epsilon || alpha2 < epsilon) {
			alpha1 = alpha2 = segLength / 3;
		}

		return [pt1, pt1.add(tan1.normalize(alpha1)),
				pt2.add(tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.00001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				value = parser.call(this, value);
				if (value != null) {
					this._components[index] = value;
					this._changed();
				}
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (type === 'gradient')
				this._id = Color._id = (Color._id || 0) + 1;
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = Gradient._id = (Gradient._id || 0) + 1;
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old != value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
					this._values[key] = value;
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = 1;
		this._id = 'view-' + View._id++;
		size = new Size(element.width, element.height);
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			return new CanvasView(project, element);
		}
	}
}, new function() {
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		this._eventCounters = {};
		this._pixelRatio = 1;
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var width = size.width,
			height = size.height,
			pixelRatio = this._pixelRatio,
			element = this._element,
			style = element.style;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			style.width = width + 'px';
			style.height = height + 'px';
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var ctx = this._context,
			prevFont = ctx.font;
		ctx.font = size + ' serif';
		size = parseFloat(ctx.font);
		ctx.font = prevFont;
		return size;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		var project = this._project;
		if (!project || !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() {

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			return { getContext: function() {} };
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		if (options.matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (item.isPolygon()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data  !== '{}')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			prevApplyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = prevApplyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot)
			definitions = {};
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

},{}],"/home/louisremi/Workspace/plumin.js/src/Contour.js":[function(require,module,exports){
var paper = require('../node_modules/paper/dist/paper-worker.js');

function Contour( args ) {
	paper.Path.prototype.constructor.call( this, args );

	this.nodes = this.segments;
}

Contour.prototype = Object.create(paper.Path.prototype);
Contour.prototype.constructor = Contour;

Contour.prototype.addNodes = paper.Path.prototype.addSegments;

Contour.prototype.prepareOT = function( path ) {
	path.commands.push({
		type: 'M',
		x: Math.round( this.firstSegment.point.x ) || 0,
		y: Math.round( this.firstSegment.point.y ) || 0
	});

	this.curves.forEach(function( curve ) {
		if ( curve.isLinear() ) {
			path.commands.push({
				type: 'L',
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});

		} else {
			path.commands.push({
				type: 'C',
				x1: Math.round( curve.point1.x + curve.handle1.x ) || 0,
				y1: Math.round( curve.point1.y + curve.handle1.y ) || 0,
				x2: Math.round( curve.point2.x + curve.handle2.x ) || 0,
				y2: Math.round( curve.point2.y + curve.handle2.y ) || 0,
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});
		}
	});

	return path;
};

module.exports = Contour;
},{"../node_modules/paper/dist/paper-worker.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-worker.js"}],"/home/louisremi/Workspace/plumin.js/src/Font.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	Glyph = require('./Glyph.js');

function Font( args ) {
	if ( !args.styleName ) {
		args.styleName = 'Regular';
	}

	if ( !args.unitsPerEm ) {
		args.unitsPerEm = 1024;
	}

	this.ot = new opentype.Font( args );

	this.glyphs = [];
	this.glyphMap = {};
	this._subset = false;

	this.addGlyph(new Glyph({
		name: '.notdef',
		unicode: 0
	}));
}

Font.prototype.addGlyph = function( glyph ) {
	this.glyphs.push( glyph );
	this.glyphMap[glyph.name] = glyph;

	return this;
};

Font.prototype.addGlyphs = function( glyphs ) {
	glyphs.forEach(function( glyph ) {
		this.addGlyph(glyph);

	}, this);

	return this;
};

Object.defineProperty( Font.prototype, 'subset', {
	get: function() {
		return this._subset;
	},
	set: function( set ) {
		if ( set === false ) {
			return ( this._subset = false );
		}

		return ( this._subset = (typeof set === 'string' ? set.split('') : set)
			.filter(function(e, i, arr) {
				return arr.lastIndexOf(e) === i;
			})
			.map(function(e) {
				return e.charCodeAt(0);
			})
			.sort()
		);
	}
});

Font.prototype.getGlyphSubset = function( set ) {
	if ( set !== undefined ) {
		this.subset = set;
	}

	// reuse last subset if possible
	if ( this._lastSubset && this._lastSubset[0] === ( this._subset || [] ).join() ) {
		return this._lastSubset[1];
	}

	// memoize last subset
	this._lastSubset = [
		( this._subset || [] ).join(),
		this.glyphs.filter(function( glyph ) {
			if ( this._subset === false && ( glyph.unicode !== false || glyph.unicodes.length ) ) {
				return true;
			}

			if ( this._subset.indexOf( glyph.unicode ) !== -1 ) {
				return true;
			}

			// TODO: handle multiple unicodes

			return false;
		}, this)
	];

	return this._lastSubset[1];
};

Font.prototype.prepareOT = function( set ) {
	this.ot.glyphs = this.getGlyphSubset( set ).map(function( glyph ) {
		return glyph.prepareOT();
	});

	return this;
};

if ( window.document ) {
	var _URL = window.URL || window.webkitURL,
		ruleIndex;
	Font.prototype.addToFonts = document.fonts ?
		// CSS font loading, lightning fast
		function( buffer ) {
			var fontface = new FontFace(
				this.ot.familyName,
				buffer || this.ot.toBuffer()
			);

			document.fonts.add( fontface );

			if ( this.lastFontFace ) {
				document.fonts.delete( this.lastFontFace );
			}

			this.lastFontFace = fontface;

			return this;
		}:
		function( buffer ) {
			var url = _URL.createObjectURL(
				new Blob(
					[ new DataView( buffer ||this.ot.toBuffer() ) ],
					{type: 'font/opentype'}
				)
			);

			if ( ruleIndex ) {
				document.styleSheets[0].deleteRule( ruleIndex );
			}

			ruleIndex = document.styleSheets[0].insertRule(
				'@font-face { font-family: "' + this.ot.familyName + '"; src: url(' + url + '); }',
				ruleIndex ||document.styleSheets[0].cssRules.length
			);

			return this;
		};
}

Font.prototype.download = function( buffer ) {
	var reader = new FileReader();

	reader.onloadend = function() {
		window.location = reader.result;
	};

	reader.readAsDataURL(new Blob(
		[ new DataView( buffer || this.ot.toBuffer() ) ],
		{type: 'font/opentype'}
	));

	return this;
};

module.exports = Font;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js"}],"/home/louisremi/Workspace/plumin.js/src/Glyph.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-worker.js');

function Glyph( args ) {
	paper.Group.prototype.constructor.apply( this );

	if ( args.unicode === undefined ) {
		args.unicode = args.name.charCodeAt(0);
	}

	if ( typeof args.unicode === 'string' ) {
		args.unicode = args.unicode.charCodeAt(0);
	}

	this.ot = new opentype.Glyph( args );
	this.ot.path = new opentype.Path();

	this.contours = [];
	this.anchors = [];
	this.components = [];
	this.parentAnchors = [];
}

Glyph.prototype = Object.create(paper.Group.prototype);
Glyph.prototype.constructor = Glyph;

Glyph.prototype.addContour = function( item ) {
	this.addChild( item );
	this.contours.push( item );
	return this;
};

Glyph.prototype.addComponent = function( item ) {
	this.addChild( item );
	this.components.push( item );
	return this;
};

Glyph.prototype.addAnchor = function( item ) {
	this.anchors.push( item );
	return this;
};

Glyph.prototype.addParentAnchor = function( item ) {
	this.parentAnchors.push( item );
	return this;
};

Glyph.prototype.prepareOT = function( path ) {
	if ( !path ) {
		this.ot.path.commands = [];
		path = this.ot.path;
	}

	this.contours.forEach(function( contour ) {
		contour.prepareOT( this.ot.path );
	}, this);

	return this.ot;
};

module.exports = Glyph;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-worker.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-worker.js"}],"/home/louisremi/Workspace/plumin.js/src/plumin.js":[function(require,module,exports){
var opentype = require('../node_modules/opentype.js/src/opentype.js'),
	paper = require('../node_modules/paper/dist/paper-worker.js'),
	Font = require('./Font.js'),
	Glyph = require('./Glyph.js'),
	Contour = require('./Contour.js'),
	utils = require('./utils.js');

function plumin() {}

plumin.opentype = opentype;
plumin.paper = paper;
plumin.Font = Font;
plumin.Glyph = Glyph;
plumin.Contour = Contour;
plumin.Node = paper.Segment;
plumin.Point = paper.Point;
plumin.Matrix = paper.Matrix;
plumin.utils = utils;
plumin.setup = paper.setup.bind(paper);

module.exports = plumin;
},{"../node_modules/opentype.js/src/opentype.js":"/home/louisremi/Workspace/plumin.js/node_modules/opentype.js/src/opentype.js","../node_modules/paper/dist/paper-worker.js":"/home/louisremi/Workspace/plumin.js/node_modules/paper/dist/paper-worker.js","./Contour.js":"/home/louisremi/Workspace/plumin.js/src/Contour.js","./Font.js":"/home/louisremi/Workspace/plumin.js/src/Font.js","./Glyph.js":"/home/louisremi/Workspace/plumin.js/src/Glyph.js","./utils.js":"/home/louisremi/Workspace/plumin.js/src/utils.js"}],"/home/louisremi/Workspace/plumin.js/src/utils.js":[function(require,module,exports){
(function (global){
// Object.mixin polyfill for IE9+
if ( !global.Object.mixin ) {
	global.Object.mixin = function( target, source ) {
		var props = Object.getOwnPropertyNames(source),
			p,
			descriptor,
			length = props.length;

		for (p = 0; p < length; p++) {
			descriptor = Object.getOwnPropertyDescriptor(source, props[p]);
			Object.defineProperty(target, props[p], descriptor);
		}

		return target;
	};
}

module.exports.mixin = global.Object.mixin;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},["/home/louisremi/Workspace/plumin.js/src/plumin.js"])("/home/louisremi/Workspace/plumin.js/src/plumin.js")
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL25vZGVfbW9kdWxlcy9lczYtY29sbGVjdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2NoZWNrLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9kcmF3LmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9lbmNvZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZm9udC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZ2x5cGguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGUuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9jZmYuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9jbWFwLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvZ2x5Zi5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dwb3MuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9oZWFkLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvaGhlYS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2htdHguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9rZXJuLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvbG9jYS5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL21heHAuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9uYW1lLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvb3MyLmpzIiwibm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvcG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL3NmbnQuanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItd29ya2VyLmpzIiwic3JjL0NvbnRvdXIuanMiLCJzcmMvRm9udC5qcyIsInNyYy9HbHlwaC5qcyIsInNyYy9wbHVtaW4uanMiLCJzcmMvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzU1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhbk11dGF0aW9uT2JzZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGNhbk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZUxpc3QgPSBxdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHF1ZXVlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgneWVzJywgJ25vJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4oZnVuY3Rpb24gKGV4cG9ydHMpIHsndXNlIHN0cmljdCc7XG4gIC8vc2hhcmVkIHBvaW50ZXJcbiAgdmFyIGk7XG4gIC8vc2hvcnRjdXRzXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgaXMgPSBPYmplY3QuaXM7XG5cblxuICAvL1BvbHlmaWxsIGdsb2JhbCBvYmplY3RzXG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuV2Vha01hcCA9IGNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgLy8gV2Vha01hcCNkZWxldGUoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICAnZGVsZXRlJzogc2hhcmVkRGVsZXRlLFxuICAgICAgLy8gV2Vha01hcCNjbGVhcigpOlxuICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuICAgICAgLy8gV2Vha01hcCNnZXQoa2V5OnZvaWQqKTp2b2lkKlxuICAgICAgZ2V0OiBzaGFyZWRHZXQsXG4gICAgICAvLyBXZWFrTWFwI2hhcyhrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgIGhhczogbWFwSGFzLFxuICAgICAgLy8gV2Vha01hcCNzZXQoa2V5OnZvaWQqLCB2YWx1ZTp2b2lkKik6dm9pZFxuICAgICAgc2V0OiBzaGFyZWRTZXRcbiAgICB9LCB0cnVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgTWFwID09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5NYXAgPSBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIC8vIFdlYWtNYXAjZGVsZXRlKGtleTp2b2lkKik6Ym9vbGVhblxuICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcbiAgICAgIC8vOndhcyBNYXAjZ2V0KGtleTp2b2lkKlssIGQzZmF1bHQ6dm9pZCpdKTp2b2lkKlxuICAgICAgLy8gTWFwI2hhcyhrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgIGhhczogbWFwSGFzLFxuICAgICAgLy8gTWFwI2dldChrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgIGdldDogc2hhcmVkR2V0LFxuICAgICAgLy8gTWFwI3NldChrZXk6dm9pZCosIHZhbHVlOnZvaWQqKTp2b2lkXG4gICAgICBzZXQ6IHNoYXJlZFNldCxcbiAgICAgIC8vIE1hcCNrZXlzKHZvaWQpOkFycmF5ID09PSBub3QgaW4gc3BlY3NcbiAgICAgIGtleXM6IHNoYXJlZEtleXMsXG4gICAgICAvLyBNYXAjdmFsdWVzKHZvaWQpOkFycmF5ID09PSBub3QgaW4gc3BlY3NcbiAgICAgIHZhbHVlczogc2hhcmVkVmFsdWVzLFxuICAgICAgLy8gTWFwI2ZvckVhY2goY2FsbGJhY2s6RnVuY3Rpb24sIGNvbnRleHQ6dm9pZCopOnZvaWQgPT0+IGNhbGxiYWNrLmNhbGwoY29udGV4dCwga2V5LCB2YWx1ZSwgbWFwT2JqZWN0KSA9PT0gbm90IGluIHNwZWNzYFxuICAgICAgZm9yRWFjaDogc2hhcmVkRm9yRWFjaCxcbiAgICAgIC8vIE1hcCNjbGVhcigpOlxuICAgICAgY2xlYXI6IHNoYXJlZENsZWFyXG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIFNldCA9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuU2V0ID0gY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICAvLyBTZXQjaGFzKHZhbHVlOnZvaWQqKTpib29sZWFuXG4gICAgICBoYXM6IHNldEhhcyxcbiAgICAgIC8vIFNldCNhZGQodmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIGFkZDogc2hhcmVkQWRkLFxuICAgICAgLy8gU2V0I2RlbGV0ZShrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG4gICAgICAvLyBTZXQjY2xlYXIoKTpcbiAgICAgIGNsZWFyOiBzaGFyZWRDbGVhcixcbiAgICAgIC8vIFNldCN2YWx1ZXModm9pZCk6QXJyYXkgPT09IG5vdCBpbiBzcGVjc1xuICAgICAgdmFsdWVzOiBzaGFyZWRWYWx1ZXMsXG4gICAgICAvLyBTZXQjZm9yRWFjaChjYWxsYmFjazpGdW5jdGlvbiwgY29udGV4dDp2b2lkKik6dm9pZCA9PT4gY2FsbGJhY2suY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgpID09PSBub3QgaW4gc3BlY3NcbiAgICAgIGZvckVhY2g6IHNoYXJlZFNldEl0ZXJhdGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgV2Vha1NldCA9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuV2Vha1NldCA9IGNyZWF0ZUNvbGxlY3Rpb24oe1xuICAgICAgLy8gV2Vha1NldCNkZWxldGUoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICAnZGVsZXRlJzogc2hhcmVkRGVsZXRlLFxuICAgICAgLy8gV2Vha1NldCNhZGQodmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIGFkZDogc2hhcmVkQWRkLFxuICAgICAgLy8gV2Vha1NldCNjbGVhcigpOlxuICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuICAgICAgLy8gV2Vha1NldCNoYXModmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIGhhczogc2V0SGFzXG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFUzYgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBjb2xsZWN0aW9uIGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uKHByb3RvLCBvYmplY3RPbmx5KXtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKGEpe1xuICAgICAgaWYgKCF0aGlzIHx8IHRoaXMuY29uc3RydWN0b3IgIT09IENvbGxlY3Rpb24pIHJldHVybiBuZXcgQ29sbGVjdGlvbihhKTtcbiAgICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgdGhpcy5vYmplY3RPbmx5ID0gb2JqZWN0T25seTtcblxuICAgICAgLy9wYXJzZSBpbml0aWFsIGl0ZXJhYmxlIGFyZ3VtZW50IHBhc3NlZFxuICAgICAgaWYgKGEpIGluaXQuY2FsbCh0aGlzLCBhKTtcbiAgICB9XG5cbiAgICAvL2RlZmluZSBzaXplIGZvciBub24gb2JqZWN0LW9ubHkgY29sbGVjdGlvbnNcbiAgICBpZiAoIW9iamVjdE9ubHkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHByb3RvLCAnc2l6ZScsIHtcbiAgICAgICAgZ2V0OiBzaGFyZWRTaXplXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvL3NldCBwcm90b3R5cGVcbiAgICBwcm90by5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb247XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIHJldHVybiBDb2xsZWN0aW9uO1xuICB9XG5cblxuICAvKiogcGFyc2UgaW5pdGlhbCBpdGVyYWJsZSBhcmd1bWVudCBwYXNzZWQgKi9cbiAgZnVuY3Rpb24gaW5pdChhKXtcbiAgICB2YXIgaTtcbiAgICAvL2luaXQgU2V0IGFyZ3VtZW50LCBsaWtlIGBbMSwyLDMse31dYFxuICAgIGlmICh0aGlzLmFkZClcbiAgICAgIGEuZm9yRWFjaCh0aGlzLmFkZCwgdGhpcyk7XG4gICAgLy9pbml0IE1hcCBhcmd1bWVudCBsaWtlIGBbWzEsMl0sIFt7fSwgNF1dYFxuICAgIGVsc2VcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLnNldChhWzBdLGFbMV0pfSwgdGhpcyk7XG4gIH1cblxuXG4gIC8qKiBkZWxldGUgKi9cbiAgZnVuY3Rpb24gc2hhcmVkRGVsZXRlKGtleSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLl9rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIC8vIEF1cm9yYSBoZXJlIGRvZXMgaXQgd2hpbGUgQ2FuYXJ5IGRvZXNuJ3RcbiAgICByZXR1cm4gLTEgPCBpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNoYXJlZEdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSA/IHRoaXMuX3ZhbHVlc1tpXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhcyhsaXN0LCBrZXkpIHtcbiAgICBpZiAodGhpcy5vYmplY3RPbmx5ICYmIGtleSAhPT0gT2JqZWN0KGtleSkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgY29sbGVjdGlvbiBrZXlcIik7XG4gICAgLy9OYU4gb3IgMCBwYXNzZWRcbiAgICBpZiAoa2V5ICE9IGtleSB8fCBrZXkgPT09IDApIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gJiYgIWlzKGxpc3RbaV0sIGtleSk7KTtcbiAgICBlbHNlIGkgPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICByZXR1cm4gLTEgPCBpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlcywgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIHRoaXMuX2tleXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBAY2hhaW5hYmxlICovXG4gIGZ1bmN0aW9uIHNoYXJlZFNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5oYXMoa2V5KSA/XG4gICAgICB0aGlzLl92YWx1ZXNbaV0gPSB2YWx1ZVxuICAgICAgOlxuICAgICAgdGhpcy5fdmFsdWVzW3RoaXMuX2tleXMucHVzaChrZXkpIC0gMV0gPSB2YWx1ZVxuICAgIDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAY2hhaW5hYmxlICovXG4gIGZ1bmN0aW9uIHNoYXJlZEFkZCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRDbGVhcigpIHtcbiAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKiBrZXlzLCB2YWx1ZXMsIGFuZCBpdGVyYXRlIHJlbGF0ZWQgbWV0aG9kcyAqL1xuICBmdW5jdGlvbiBzaGFyZWRWYWx1ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5zbGljZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5cy5zbGljZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZEZvckVhY2goY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZhbHVlcyA9IHNlbGYuX3ZhbHVlcy5zbGljZSgpO1xuICAgIHNlbGYuX2tleXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgbil7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHZhbHVlc1tuXSwga2V5LCBzZWxmKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZFNldEl0ZXJhdGUoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5fdmFsdWVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHZhbHVlLCB2YWx1ZSwgc2VsZik7XG4gICAgfSk7XG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyApO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBSdW4tdGltZSBjaGVja2luZyBvZiBwcmVjb25kaXRpb25zLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFByZWNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIGlzIHRydWUuXG4vLyBJZiBub3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5leHBvcnRzLmFyZ3VtZW50ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmFyZ3VtZW50O1xuIiwiLy8gRHJhd2luZyB1dGlsaXR5IGZ1bmN0aW9ucy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBEcmF3IGEgbGluZSBvbiB0aGUgZ2l2ZW4gY29udGV4dCBmcm9tIHBvaW50IGB4MSx5MWAgdG8gcG9pbnQgYHgyLHkyYC5cbmZ1bmN0aW9uIGxpbmUoY3R4LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbn1cblxuZXhwb3J0cy5saW5lID0gbGluZTtcbiIsIi8vIEdseXBoIGVuY29kaW5nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJycsICdwYXJhZ3JhcGgnLCAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG4gICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnQUUnLCAnJywgJ29yZGZlbWluaW5lJywgJycsICcnLCAnJyxcbiAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG4gICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICd0d29kb3RlbmxlYWRlcicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuICAgICdzZW1pY29sb24nLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJywgJ3F1ZXN0aW9uc21hbGwnLCAnJywgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICcnLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsICcnLCAnRG90YWNjZW50c21hbGwnLCAnJywgJycsICdNYWNyb25zbWFsbCcsICcnLCAnJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcbiAgICAnJywgJ3plcm9zdXBlcmlvcicsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJywgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLCAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxudmFyIHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLy8gVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG4vLyBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuLy8gU2luY2UgaXQncyBsaW5lYXIgdGltZSwgb3RoZXIgZW5jb2RpbmdzIHdpbGwgYmUgZmFzdGVyLlxuZnVuY3Rpb24gRGVmYXVsdEVuY29kaW5nKGZvbnQpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xufVxuXG5EZWZhdWx0RW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBjb2RlLCBnbHlwaHMsIGksIGdseXBoLCBqO1xuICAgIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcbiAgICBpZiAoZ2x5cGhzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIENtYXBFbmNvZGluZyhjbWFwKSB7XG4gICAgdGhpcy5jbWFwID0gY21hcDtcbn1cblxuQ21hcEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jaGFyQ29kZUF0KDApXSB8fCAwO1xufTtcblxuZnVuY3Rpb24gQ2ZmRW5jb2RpbmcoZW5jb2RpbmcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbn1cblxuQ2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBjb2RlLCBjaGFyTmFtZTtcbiAgICBjb2RlID0gcy5jaGFyQ29kZUF0KDApO1xuICAgIGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xufTtcblxuZnVuY3Rpb24gR2x5cGhOYW1lcyhwb3N0KSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICBjYXNlIDE6XG4gICAgICAgIHRoaXMubmFtZXMgPSBleHBvcnRzLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IGV4cG9ydHMuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gcG9zdC5uYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldIC0gZXhwb3J0cy5zdGFuZGFyZE5hbWVzLmxlbmd0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyLjU6XG4gICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBleHBvcnRzLnN0YW5kYXJkTmFtZXNbaSArIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuR2x5cGhOYW1lcy5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKTtcbn07XG5cbkdseXBoTmFtZXMucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbiAoZ2lkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNbZ2lkXTtcbn07XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCkge1xuICAgIHZhciBnbHlwaEluZGV4TWFwLCBjaGFyQ29kZXMsIGksIGMsIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgZ2x5cGguYWRkVW5pY29kZShwYXJzZUludChjKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZm9udC5jZmZFbmNvZGluZykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuY2ZmRW5jb2RpbmcuY2hhcnNldFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5jZmZTdGFuZGFyZFN0cmluZ3MgPSBjZmZTdGFuZGFyZFN0cmluZ3M7XG5leHBvcnRzLmNmZlN0YW5kYXJkRW5jb2RpbmcgPSBjZmZTdGFuZGFyZEVuY29kaW5nO1xuZXhwb3J0cy5jZmZFeHBlcnRFbmNvZGluZyA9IGNmZkV4cGVydEVuY29kaW5nO1xuZXhwb3J0cy5zdGFuZGFyZE5hbWVzID0gc3RhbmRhcmROYW1lcztcbmV4cG9ydHMuRGVmYXVsdEVuY29kaW5nID0gRGVmYXVsdEVuY29kaW5nO1xuZXhwb3J0cy5DbWFwRW5jb2RpbmcgPSBDbWFwRW5jb2Rpbmc7XG5leHBvcnRzLkNmZkVuY29kaW5nID0gQ2ZmRW5jb2Rpbmc7XG5leHBvcnRzLkdseXBoTmFtZXMgPSBHbHlwaE5hbWVzO1xuZXhwb3J0cy5hZGRHbHlwaE5hbWVzID0gYWRkR2x5cGhOYW1lcztcbiIsIi8vIFRoZSBGb250IG9iamVjdFxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG52YXIgc2ZudCA9IHJlcXVpcmUoJy4vdGFibGVzL3NmbnQnKTtcbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4vZW5jb2RpbmcnKTtcblxuLy8gQSBGb250IHJlcHJlc2VudHMgYSBsb2FkZWQgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gSXQgY29udGFpbnMgYSBzZXQgb2YgZ2x5cGhzIGFuZCBtZXRob2RzIHRvIGRyYXcgdGV4dCBvbiBhIGRyYXdpbmcgY29udGV4dCxcbi8vIG9yIHRvIGdldCBhIHBhdGggcmVwcmVzZW50aW5nIHRoZSB0ZXh0LlxuZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gT1MgWCB3aWxsIGNvbXBsYWluIGlmIHRoZSBuYW1lcyBhcmUgZW1wdHksIHNvIHdlIHB1dCBhIHNpbmdsZSBzcGFjZSBldmVyeXdoZXJlIGJ5IGRlZmF1bHQuXG4gICAgdGhpcy5mYW1pbHlOYW1lID0gb3B0aW9ucy5mYW1pbHlOYW1lIHx8ICcgJztcbiAgICB0aGlzLnN0eWxlTmFtZSA9IG9wdGlvbnMuc3R5bGVOYW1lIHx8ICcgJztcbiAgICB0aGlzLmRlc2lnbmVyID0gb3B0aW9ucy5kZXNpZ25lciB8fCAnICc7XG4gICAgdGhpcy5kZXNpZ25lclVSTCA9IG9wdGlvbnMuZGVzaWduZXJVUkwgfHwgJyAnO1xuICAgIHRoaXMubWFudWZhY3R1cmVyID0gb3B0aW9ucy5tYW51ZmFjdHVyZXIgfHwgJyAnO1xuICAgIHRoaXMubWFudWZhY3R1cmVyVVJMID0gb3B0aW9ucy5tYW51ZmFjdHVyZXJVUkwgfHwgJyAnO1xuICAgIHRoaXMubGljZW5zZSA9IG9wdGlvbnMubGljZW5zZSB8fCAnICc7XG4gICAgdGhpcy5saWNlbnNlVVJMID0gb3B0aW9ucy5saWNlbnNlVVJMIHx8ICcgJztcbiAgICB0aGlzLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gfHwgJ1ZlcnNpb24gMC4xJztcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbiB8fCAnICc7XG4gICAgdGhpcy5jb3B5cmlnaHQgPSBvcHRpb25zLmNvcHlyaWdodCB8fCAnICc7XG4gICAgdGhpcy50cmFkZW1hcmsgPSBvcHRpb25zLnRyYWRlbWFyayB8fCAnICc7XG4gICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2x5cGhzID0gb3B0aW9ucy5nbHlwaHMgfHwgW107XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5EZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy50YWJsZXMgPSB7fTtcbn1cblxuLy8gQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIGdseXBoIGluZGV4LlxuLy8gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbi8vIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIEdseXBoIG9iamVjdC5cbi8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4vLyB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBnbHlwaEluZGV4LCBnbHlwaDtcbiAgICBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgIGdseXBoID0gdGhpcy5nbHlwaHNbZ2x5cGhJbmRleF07XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdOyAvLyAubm90ZGVmXG4gICAgfVxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdpdmVuIHRleHQgdG8gYSBsaXN0IG9mIEdseXBoIG9iamVjdHMuXG4vLyBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gc3RyaWN0IG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kXG4vLyBnbHlwaHMsIHNvIHRoZSBsaXN0IG9mIHJldHVybmVkIGdseXBocyBjYW4gYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBpLCBjLCBnbHlwaHM7XG4gICAgZ2x5cGhzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYyA9IHNbaV07XG4gICAgICAgIGdseXBocy5wdXNoKHRoaXMuY2hhclRvR2x5cGgoYykpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xufTtcblxuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnbHlwaEluZGV4LCBnbHlwaDtcbiAgICBnbHlwaEluZGV4ID0gdGhpcy5uYW1ldG9HbHlwaEluZGV4KG5hbWUpO1xuICAgIGdseXBoID0gdGhpcy5nbHlwaHNbZ2x5cGhJbmRleF07XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdOyAvLyAubm90ZGVmXG4gICAgfVxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbkZvbnQucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbiAoZ2lkKSB7XG4gICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShnaWQpO1xufTtcblxuLy8gUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuLy8gYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cbi8vIFRoZSBrZXJuaW5nIHZhbHVlIGdldHMgYWRkZWQgdG8gdGhlIGFkdmFuY2Ugd2lkdGggd2hlbiBjYWxjdWxhdGluZyB0aGUgc3BhY2luZ1xuLy8gYmV0d2VlbiBnbHlwaHMuXG5Gb250LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbiAobGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMuZ2V0R3Bvc0tlcm5pbmdWYWx1ZTtcbiAgICByZXR1cm4gZ3Bvc0tlcm5pbmcgPyBncG9zS2VybmluZyhsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIDpcbiAgICAgICAgKHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDApO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG4vLyBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLlxuRm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXJuaW5nLCBmb250U2NhbGUsIGdseXBocywgaSwgZ2x5cGgsIGtlcm5pbmdWYWx1ZTtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGtlcm5pbmcgPSBvcHRpb25zLmtlcm5pbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmtlcm5pbmc7XG4gICAgZm9udFNjYWxlID0gMSAvIHRoaXMudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGdseXBocyA9IHRoaXMuc3RyaW5nVG9HbHlwaHModGV4dCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGdseXBoLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBrZXJuaW5nVmFsdWUgPSB0aGlzLmdldEtlcm5pbmdWYWx1ZShnbHlwaCwgZ2x5cGhzW2kgKyAxXSk7XG4gICAgICAgICAgICB4ICs9IGtlcm5pbmdWYWx1ZSAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENyZWF0ZSBhIFBhdGggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gdGV4dC5cbi8vXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbi8vXG4vLyBSZXR1cm5zIGEgUGF0aCBvYmplY3QuXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbiAoZ2x5cGgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ2x5cGguZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSk7XG4gICAgICAgIGZ1bGxQYXRoLmV4dGVuZChwYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vLyBEcmF3IHRoZSB0ZXh0IG9uIHRoZSBnaXZlbiBkcmF3aW5nIGNvbnRleHQuXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcbn07XG5cbi8vIERyYXcgdGhlIHBvaW50cyBvZiBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuLy8gT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbiAoZ2x5cGgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdQb2ludHMoY3R4LCB4LCB5LCBmb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vLyBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuLy8gQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4vLyBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4vLyBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd01ldHJpY3MoY3R4LCB4LCB5LCBmb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vLyBWYWxpZGF0ZVxuRm9udC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIGZvbnQgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFN0cmluZ0F0dHJpYnV0ZShhdHRyTmFtZSkge1xuICAgICAgICBhc3NlcnQoZm9udFthdHRyTmFtZV0gJiYgZm9udFthdHRyTmFtZV0udHJpbSgpLmxlbmd0aCA+IDAsICdObyAnICsgYXR0ck5hbWUgKyAnIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnZmFtaWx5TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnbWFudWZhY3R1cmVyJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdjb3B5cmlnaHQnKTtcbiAgICBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwLCAnTm8gdW5pdHNQZXJFbSBzcGVjaWZpZWQuJyk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG4vLyBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZm50LmZvbnRUb1RhYmxlKHRoaXMpO1xufTtcblxuRm9udC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNmbnRUYWJsZSA9IHRoaXMudG9UYWJsZXMoKTtcbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnRBcnJheVtpXSA9IGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbkZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgdGhpcy5zdHlsZU5hbWUgKyAnLm90Zic7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoKTtcblxuICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSA9IHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEZpbGVTeXN0ZW07XG4gICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKHdpbmRvdy5URU1QT1JBUlksIGJ1ZmZlci5ieXRlTGVuZ3RoLCBmdW5jdGlvbiAoZnMpIHtcbiAgICAgICAgZnMucm9vdC5nZXRGaWxlKGZpbGVOYW1lLCB7Y3JlYXRlOiB0cnVlfSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgZmlsZUVudHJ5LmNyZWF0ZVdyaXRlcihmdW5jdGlvbiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YVZpZXddLCB7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlKGJsb2IpO1xuXG4gICAgICAgICAgICAgICAgIHdyaXRlci5hZGRFdmVudExpc3RlbmVyKCd3cml0ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGluZyB0byB0aGUgZmlsZSB3aWxsIGRvd25sb2FkIGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuRm9udCA9IEZvbnQ7XG4iLCIvLyBUaGUgR2x5cGggb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xudmFyIGRyYXcgPSByZXF1aXJlKCcuL2RyYXcnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cbi8vIEEgR2x5cGggaXMgYW4gaW5kaXZpZHVhbCBtYXJrIHRoYXQgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjaGFyYWN0ZXIuXG4vLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cbi8vIEdseXBocyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIGZvbnQuXG4vL1xuLy8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuZnVuY3Rpb24gR2x5cGgob3B0aW9ucykge1xuICAgIHRoaXMuZm9udCA9IG9wdGlvbnMuZm9udCB8fCBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID0gb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZCA/IFtvcHRpb25zLnVuaWNvZGVdIDogW107XG4gICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluIHx8IDA7XG4gICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluIHx8IDA7XG4gICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4IHx8IDA7XG4gICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4IHx8IDA7XG4gICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aCB8fCAwO1xuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCBudWxsO1xufVxuXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uICh1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuICAgIHRoaXMudW5pY29kZXMucHVzaCh1bmljb2RlKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdseXBoIHRvIGEgUGF0aCB3ZSBjYW4gZHJhdyBvbiBhIGRyYXdpbmcgY29udGV4dC5cbi8vXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICh4LCB5LCBmb250U2l6ZSkge1xuICAgIHZhciBzY2FsZSwgcCwgY29tbWFuZHMsIGNtZDtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyh4ICsgKGNtZC54ICogc2NhbGUpLCB5ICsgKC1jbWQueSAqIHNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgcC5saW5lVG8oeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHNjYWxlKSwgeSArICgtY21kLnkxICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBwLmN1cnZlVG8oeCArIChjbWQueDEgKiBzY2FsZSksIHkgKyAoLWNtZC55MSAqIHNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54MiAqIHNjYWxlKSwgeSArICgtY21kLnkyICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xufTtcblxuLy8gU3BsaXQgdGhlIGdseXBoIGludG8gY29udG91cnMuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgdG9cbi8vIHByb3ZpZGUgcmF3IGFjY2VzcyB0byB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZXMuXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRvdXJzLCBjdXJyZW50Q29udG91ciwgaSwgcHQ7XG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xufTtcblxuLy8gQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG5HbHlwaC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgdmFyIHhDb29yZHMgPSBbXTtcbiAgICB2YXIgeUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgIT09ICdaJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54KTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54Mik7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWV0cmljcyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIGxlZnRTaWRlQmVhcmluZzogMFxuICAgIH07XG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLy8gRHJhdyB0aGUgZ2x5cGggb24gdGhlIGdpdmVuIGNvbnRleHQuXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB0aGlzLmdldFBhdGgoeCwgeSwgZm9udFNpemUpLmRyYXcoY3R4KTtcbn07XG5cbi8vIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIFRoZSBkcmF3aW5nIGNvbnRleHQuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIGZvbnRTaXplKSB7XG5cbiAgICBmdW5jdGlvbiBkcmF3Q2lyY2xlcyhsLCB4LCB5LCBzY2FsZSkge1xuICAgICAgICB2YXIgaiwgUElfU1EgPSBNYXRoLlBJICogMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSksIDIsIDAsIFBJX1NRLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSwgaSwgYmx1ZUNpcmNsZXMsIHJlZENpcmNsZXMsIHBhdGgsIGNtZDtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgIGJsdWVDaXJjbGVzID0gW107XG4gICAgcmVkQ2lyY2xlcyA9IFtdO1xuICAgIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsdWVDaXJjbGVzLnB1c2goe3g6IGNtZC54LCB5OiAtY21kLnl9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZC54MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MiwgeTogLWNtZC55Mn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICBkcmF3Q2lyY2xlcyhibHVlQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICBkcmF3Q2lyY2xlcyhyZWRDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG59O1xuXG4vLyBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzLlxuLy8gQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4vLyBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4vLyBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG4gICAgLy8gRHJhdyB0aGUgZ2x5cGggYm94XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAodGhpcy54TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAodGhpcy54TWluICogc2NhbGUpLCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLnhNYXggKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLnhNYXggKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXRoaXMueU1pbiAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXRoaXMueU1pbiAqIHNjYWxlKSk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5ICsgKC10aGlzLnlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC10aGlzLnlNYXggKiBzY2FsZSkpO1xuICAgIC8vIERyYXcgdGhlIGFkdmFuY2Ugd2lkdGhcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAodGhpcy5hZHZhbmNlV2lkdGggKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLmFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgMTAwMDApO1xufTtcblxuZXhwb3J0cy5HbHlwaCA9IEdseXBoO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIG9wZW50eXBlLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWJveC9vcGVudHlwZS5qc1xuLy8gKGMpIDIwMTQgRnJlZGVyaWsgRGUgQmxlc2VyXG4vLyBvcGVudHlwZS5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuLyogZ2xvYmFsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVWludDhBcnJheSwgWE1MSHR0cFJlcXVlc3QgICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9lbmNvZGluZycpO1xudmFyIF9mb250ID0gcmVxdWlyZSgnLi9mb250Jyk7XG52YXIgZ2x5cGggPSByZXF1aXJlKCcuL2dseXBoJyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG52YXIgY21hcCA9IHJlcXVpcmUoJy4vdGFibGVzL2NtYXAnKTtcbnZhciBjZmYgPSByZXF1aXJlKCcuL3RhYmxlcy9jZmYnKTtcbnZhciBnbHlmID0gcmVxdWlyZSgnLi90YWJsZXMvZ2x5ZicpO1xudmFyIGdwb3MgPSByZXF1aXJlKCcuL3RhYmxlcy9ncG9zJyk7XG52YXIgaGVhZCA9IHJlcXVpcmUoJy4vdGFibGVzL2hlYWQnKTtcbnZhciBoaGVhID0gcmVxdWlyZSgnLi90YWJsZXMvaGhlYScpO1xudmFyIGhtdHggPSByZXF1aXJlKCcuL3RhYmxlcy9obXR4Jyk7XG52YXIga2VybiA9IHJlcXVpcmUoJy4vdGFibGVzL2tlcm4nKTtcbnZhciBsb2NhID0gcmVxdWlyZSgnLi90YWJsZXMvbG9jYScpO1xudmFyIG1heHAgPSByZXF1aXJlKCcuL3RhYmxlcy9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL3RhYmxlcy9uYW1lJyk7XG52YXIgb3MyID0gcmVxdWlyZSgnLi90YWJsZXMvb3MyJyk7XG52YXIgcG9zdCA9IHJlcXVpcmUoJy4vdGFibGVzL3Bvc3QnKTtcblxuLy8gRmlsZSBsb2FkZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGEgTm9kZS5qcyBCdWZmZXIgdG8gYW4gQXJyYXlCdWZmZXJcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpLFxuICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRhW2ldID0gYnVmZmVyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZDogJyArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKCk7XG59XG5cbi8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbi8vIElmIHRoZSBmaWxlIGNvdWxkIG5vdCBiZSBwYXJzZWQgKG1vc3QgbGlrZWx5IGJlY2F1c2UgaXQgY29udGFpbnMgUG9zdHNjcmlwdCBvdXRsaW5lcylcbi8vIHdlIHJldHVybiBhbiBlbXB0eSBGb250IG9iamVjdCB3aXRoIHRoZSBgc3VwcG9ydGVkYCBmbGFnIHNldCB0byBgZmFsc2VgLlxuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGZvbnQsIGRhdGEsIHZlcnNpb24sIG51bVRhYmxlcywgaSwgcCwgdGFnLCBvZmZzZXQsIGhtdHhPZmZzZXQsIGdseWZPZmZzZXQsIGxvY2FPZmZzZXQsXG4gICAgICAgIGNmZk9mZnNldCwga2Vybk9mZnNldCwgZ3Bvc09mZnNldCwgaW5kZXhUb0xvY0Zvcm1hdCwgbnVtR2x5cGhzLCBsb2NhVGFibGUsXG4gICAgICAgIHNob3J0VmVyc2lvbjtcbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cblxuICAgIGZvbnQgPSBuZXcgX2ZvbnQuRm9udCgpO1xuICAgIGRhdGEgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCAwKTtcblxuICAgIHZlcnNpb24gPSBwYXJzZS5nZXRGaXhlZChkYXRhLCAwKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgdmVyc2lvbiAnICsgdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cbiAgICAvLyBPZmZzZXQgaW50byB0aGUgdGFibGUgcmVjb3Jkcy5cbiAgICBwID0gMTI7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdjbWFwJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgIGlmICghZm9udC5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIGZvbnQuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5oZWFkID0gaGVhZC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC51bml0c1BlckVtID0gZm9udC50YWJsZXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoaGVhJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmFzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5hc2NlbmRlcjtcbiAgICAgICAgICAgIGZvbnQuZGVzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXI7XG4gICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaG10eCc6XG4gICAgICAgICAgICBobXR4T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21heHAnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMubWF4cCA9IG1heHAucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gbnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5uYW1lID0gX25hbWUucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZmFtaWx5TmFtZSA9IGZvbnQudGFibGVzLm5hbWUuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGZvbnQuc3R5bGVOYW1lID0gZm9udC50YWJsZXMubmFtZS5mb250U3ViZmFtaWx5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09TLzInOlxuICAgICAgICAgICAgZm9udC50YWJsZXMub3MyID0gb3MyLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5wb3N0ID0gcG9zdC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5nbHlwaE5hbWVzID0gbmV3IGVuY29kaW5nLkdseXBoTmFtZXMoZm9udC50YWJsZXMucG9zdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ2x5Zic6XG4gICAgICAgICAgICBnbHlmT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xvY2EnOlxuICAgICAgICAgICAgbG9jYU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgIGNmZk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdrZXJuJzpcbiAgICAgICAgICAgIGtlcm5PZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnR1BPUyc6XG4gICAgICAgICAgICBncG9zT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSAxNjtcbiAgICB9XG5cbiAgICBpZiAoZ2x5Zk9mZnNldCAmJiBsb2NhT2Zmc2V0KSB7XG4gICAgICAgIHNob3J0VmVyc2lvbiA9IGluZGV4VG9Mb2NGb3JtYXQgPT09IDA7XG4gICAgICAgIGxvY2FUYWJsZSA9IGxvY2EucGFyc2UoZGF0YSwgbG9jYU9mZnNldCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuICAgICAgICBmb250LmdseXBocyA9IGdseWYucGFyc2UoZGF0YSwgZ2x5Zk9mZnNldCwgbG9jYVRhYmxlLCBmb250KTtcbiAgICAgICAgaG10eC5wYXJzZShkYXRhLCBobXR4T2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocyk7XG4gICAgICAgIGVuY29kaW5nLmFkZEdseXBoTmFtZXMoZm9udCk7XG4gICAgfSBlbHNlIGlmIChjZmZPZmZzZXQpIHtcbiAgICAgICAgY2ZmLnBhcnNlKGRhdGEsIGNmZk9mZnNldCwgZm9udCk7XG4gICAgICAgIGVuY29kaW5nLmFkZEdseXBoTmFtZXMoZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9udC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGtlcm5PZmZzZXQpIHtcbiAgICAgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShkYXRhLCBrZXJuT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdwb3NPZmZzZXQpIHtcbiAgICAgICAgICAgIGdwb3MucGFyc2UoZGF0YSwgZ3Bvc09mZnNldCwgZm9udCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9udDtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGEgZmlsZXN5c3RlbS4gV2hlbiBkb25lLCBjYWxsIHRoZSBjYWxsYmFja1xuLy8gd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBmb250KWAuIFRoZSBgZXJyYCB3aWxsIGJlIG51bGwgb24gc3VjY2Vzcyxcbi8vIHRoZSBgZm9udGAgaXMgYSBGb250IG9iamVjdC5cbi8vXG4vLyBXZSB1c2UgdGhlIG5vZGUuanMgY2FsbGJhY2sgY29udmVudGlvbiBzbyB0aGF0XG4vLyBvcGVudHlwZS5qcyBjYW4gaW50ZWdyYXRlIHdpdGggZnJhbWV3b3JrcyBsaWtlIGFzeW5jLmpzLlxuZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvYWRlciA9IHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhcHJvY2Vzcy5icm93c2VyID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG4gICAgbG9hZGVyKHVybCwgZnVuY3Rpb24gKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIGlmICghZm9udC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnRm9udCBpcyBub3Qgc3VwcG9ydGVkIChpcyB0aGlzIGEgUG9zdHNjcmlwdCBmb250PyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydHMuRm9udCA9IF9mb250LkZvbnQ7XG5leHBvcnRzLkdseXBoID0gZ2x5cGguR2x5cGg7XG5leHBvcnRzLlBhdGggPSBwYXRoLlBhdGg7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VCdWZmZXI7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cbmV4cG9ydHMuZ2V0Qnl0ZSA9IGZ1bmN0aW9uIGdldEJ5dGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xufTtcblxuZXhwb3J0cy5nZXRDYXJkOCA9IGV4cG9ydHMuZ2V0Qnl0ZTtcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRVU2hvcnQgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG59O1xuXG5leHBvcnRzLmdldENhcmQxNiA9IGV4cG9ydHMuZ2V0VVNob3J0O1xuXG4vLyBSZXRyaWV2ZSBhIHNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFNob3J0ID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG59O1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0VUxvbmcgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59O1xuXG4vLyBSZXRyaWV2ZSBhIDMyLWJpdCBzaWduZWQgZml4ZWQtcG9pbnQgbnVtYmVyICgxNi4xNikgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldEZpeGVkID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICB2YXIgZGVjaW1hbCwgZnJhY3Rpb247XG4gICAgZGVjaW1hbCA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xuICAgIGZyYWN0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIsIGZhbHNlKTtcbiAgICByZXR1cm4gZGVjaW1hbCArIGZyYWN0aW9uIC8gNjU1MzU7XG59O1xuXG4vLyBSZXRyaWV2ZSBhIDQtY2hhcmFjdGVyIHRhZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRhZ3MgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGFibGVzLlxuZXhwb3J0cy5nZXRUYWcgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciB0YWcgPSAnJywgaTtcbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA0OyBpICs9IDEpIHtcbiAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59O1xuXG4vLyBSZXRyaWV2ZSBhbiBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBPZmZzZXRzIGFyZSAxIHRvIDQgYnl0ZXMgaW4gbGVuZ3RoLCBkZXBlbmRpbmcgb24gdGhlIG9mZlNpemUgYXJndW1lbnQuXG5leHBvcnRzLmdldE9mZnNldCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG4gICAgdmFyIGksIHY7XG4gICAgdiA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG9mZlNpemU7IGkgKz0gMSkge1xuICAgICAgICB2IDw8PSA4O1xuICAgICAgICB2ICs9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn07XG5cbi8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuZXhwb3J0cy5nZXRCeXRlcyA9IGZ1bmN0aW9uIChkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHZhciBieXRlcywgaTtcbiAgICBieXRlcyA9IFtdO1xuICAgIGZvciAoaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn07XG5cbi8vIENvbnZlcnQgdGhlIGxpc3Qgb2YgYnl0ZXMgdG8gYSBzdHJpbmcuXG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICB2YXIgcywgaTtcbiAgICBzID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xufTtcblxudmFyIHR5cGVPZmZzZXRzID0ge1xuICAgIGJ5dGU6IDEsXG4gICAgdVNob3J0OiAyLFxuICAgIHNob3J0OiAyLFxuICAgIHVMb25nOiA0LFxuICAgIGZpeGVkOiA0LFxuICAgIGxvbmdEYXRlVGltZTogOCxcbiAgICB0YWc6IDRcbn07XG5cbi8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuLy8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cbmZ1bmN0aW9uIFBhcnNlcihkYXRhLCBvZmZzZXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCkgLyAxNjM4NDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSBleHBvcnRzLmdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTZMaXN0ID1cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpLFxuICAgICAgICBkYXRhVmlldyA9IHRoaXMuZGF0YSxcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2ldID0gZXhwb3J0cy5nZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhLFxuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQsXG4gICAgICAgIHN0cmluZyA9ICcnO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcbn07XG5cbi8vIExPTkdEQVRFVElNRSBpcyBhIDY0LWJpdCBpbnRlZ2VyLlxuLy8gSmF2YVNjcmlwdCBhbmQgdW5peCB0aW1lc3RhbXBzIHRyYWRpdGlvbmFsbHkgdXNlIDMyIGJpdHMsIHNvIHdlXG4vLyBvbmx5IHRha2UgdGhlIGxhc3QgMzIgYml0cy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGV4cG9ydHMuZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGV4cG9ydHMuZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdiAvIDY1NTM2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZlcnNpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFqb3IgPSBleHBvcnRzLmdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgLy8gSG93IHRvIGludGVycHJldCB0aGUgbWlub3IgdmVyc2lvbiBpcyB2ZXJ5IHZhZ3VlIGluIHRoZSBzcGVjLiAweDUwMDAgaXMgNSwgMHgxMDAwIGlzIDFcbiAgICAvLyBUaGlzIHJldHVybnMgdGhlIGNvcnJlY3QgbnVtYmVyIGlmIG1pbm9yID0gMHhOMDAwIHdoZXJlIE4gaXMgMC05XG4gICAgdmFyIG1pbm9yID0gZXhwb3J0cy5nZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyAyKTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyAweDEwMDAgLyAxMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICh0eXBlLCBhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW1vdW50ID0gMTtcbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSB0eXBlT2Zmc2V0c1t0eXBlXSAqIGFtb3VudDtcbn07XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwiLy8gR2VvbWV0cmljIG9iamVjdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuLy8gUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe3R5cGU6ICdNJywgeDogeCwgeTogeX0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe3R5cGU6ICdMJywgeDogeCwgeTogeX0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe3R5cGU6ICdDJywgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyLCB4OiB4LCB5OiB5fSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7dHlwZTogJ1EnLCB4MTogeDEsIHkxOiB5MSwgeDogeCwgeTogeX0pO1xufTtcblxuUGF0aC5wcm90b3R5cGUuY2xvc2UgPSBQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHt0eXBlOiAnWid9KTtcbn07XG5cbi8vIEFkZCB0aGUgZ2l2ZW4gcGF0aCBvciBsaXN0IG9mIGNvbW1hbmRzIHRvIHRoZSBjb21tYW5kcyBvZiB0aGlzIHBhdGguXG5QYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAocGF0aE9yQ29tbWFuZHMpIHtcbiAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcbiAgICAgICAgcGF0aE9yQ29tbWFuZHMgPSBwYXRoT3JDb21tYW5kcy5jb21tYW5kcztcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLy8gRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBpLCBjbWQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2U7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbiIsIi8vIFRhYmxlIG1ldGFkYXRhXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xudmFyIGVuY29kZSA9IHJlcXVpcmUoJy4vdHlwZXMnKS5lbmNvZGU7XG52YXIgc2l6ZU9mID0gcmVxdWlyZSgnLi90eXBlcycpLnNpemVPZjtcblxuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdiArPSB2YWx1ZS5zaXplT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCh0eXBlb2Ygc2l6ZU9mRnVuY3Rpb24gPT09ICdmdW5jdGlvbicsICdDb3VsZCBub3QgZmluZCBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkJyArIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgdiArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG4iLCIvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4uL2VuY29kaW5nJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cywgb2JqZWN0cywgY291bnQsIGVuZE9mZnNldCwgb2Zmc2V0U2l6ZSwgb2JqZWN0T2Zmc2V0LCBwb3MsIGksIHZhbHVlO1xuICAgIG9mZnNldHMgPSBbXTtcbiAgICBvYmplY3RzID0gW107XG4gICAgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMsIGVvZiwgbG9va3VwLCBiLCBuMSwgbjI7XG4gICAgcyA9ICcnO1xuICAgIGVvZiA9IDE1O1xuICAgIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIG4xID0gYiA+PiA0O1xuICAgICAgICBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbywga2V5LCB2YWx1ZXMsIGksIHZhbHVlO1xuICAgIG8gPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICB2YXIgcGFyc2VyLCBlbnRyaWVzLCBvcGVyYW5kcywgb3A7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGVudHJpZXMgPSBbXTtcbiAgICBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIG0sIHZhbHVlLCBuZXdEaWN0O1xuICAgIG5ld0RpY3QgPSB7fTtcbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge25hbWU6ICdmb250TWF0cml4Jywgb3A6IDEyMDcsIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSwgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX1cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgcGFyc2VyLCBmb3JtYXQsIGNoYXJzZXQsIGksIHNpZCwgY291bnQ7XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgZW5jLCBwYXJzZXIsIGZvcm1hdCwgbkNvZGVzLCBpLCBjb2RlLCBuUmFuZ2VzLCBmaXJzdCwgbkxlZnQsIGo7XG4gICAgZW5jID0ge307XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblJhbmdlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhjb2RlLCBmb250LCBpbmRleCkge1xuICAgIHZhciBwLCBnbHlwaCwgc3RhY2ssIG5TdGVtcywgaGF2ZVdpZHRoLCB3aWR0aCwgeCwgeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB2O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgc3RhY2sgPSBbXTtcbiAgICBuU3RlbXMgPSAwO1xuICAgIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHdpZHRoID0gZm9udC5kZWZhdWx0V2lkdGhYO1xuICAgIHggPSB5ID0gMDtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgaSwgYjEsIGIyLCBiMywgYjQsIGNvZGVJbmRleCwgc3VickNvZGU7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5zdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAxMjogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLnBhdGggPSBwO1xuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBnbHlwaDtcbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIHZhciBoZWFkZXIsIG5hbWVJbmRleCwgdG9wRGljdEluZGV4LCBzdHJpbmdJbmRleCwgZ2xvYmFsU3VickluZGV4LCB0b3BEaWN0LCBwcml2YXRlRGljdE9mZnNldCwgcHJpdmF0ZURpY3QsXG4gICAgICAgIHN1YnJPZmZzZXQsIHN1YnJJbmRleCwgY2hhclN0cmluZywgY2hhclN0cmluZ3NJbmRleCwgY2hhcnNldCwgaTtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHRvcERpY3RJbmRleC5vYmplY3RzWzBdKS5idWZmZXIpO1xuICAgIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0Wydwcml2YXRlJ11bMV07XG4gICAgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0Wydwcml2YXRlJ11bMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG5cbiAgICBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7IC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jb2RpbmcuY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7IC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgZm9udC5nbHlwaHMucHVzaChwYXJzZUNGRkNoYXJzdHJpbmcoY2hhclN0cmluZywgZm9udCwgaSkpO1xuICAgIH1cbn1cblxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIHNpZDtcbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICBpID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnTmFtZSBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0Lm5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5uYW1lcy5wdXNoKHtuYW1lOiAnbmFtZV8nICsgaSwgdHlwZTogJ05BTUUnLCB2YWx1ZTogZm9udE5hbWVzW2ldfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge30sIGksIGVudHJ5LCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gYXR0cnNbZW50cnkubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTdHJpbmcodmFsdWUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIGRvbid0IHVzZSBzdWJyb3V0aW5lcy5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdLCBwYXRoID0gZ2x5cGgucGF0aCwgeCwgeSwgaSwgY21kLCBkeCwgZHksIGR4MSwgZHkxLCBkeDIsIGR5MjtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG4gICAgICAgICAgICB4ID0gY21kLng7XG4gICAgICAgICAgICB5ID0gY21kLnk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcbiAgICAgICAgICAgIHggPSBjbWQueDtcbiAgICAgICAgICAgIHkgPSBjbWQueTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogQWRkIHN1cHBvcnQgZm9yIHF1YWQgY3VydmVzXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRpbmcgcXVhZCBjdXJ2ZXMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZHgxID0gY21kLngxIC0geDtcbiAgICAgICAgICAgIGR5MSA9IGNtZC55MSAtIHk7XG4gICAgICAgICAgICBkeDIgPSBjbWQueDIgLSBjbWQueDE7XG4gICAgICAgICAgICBkeTIgPSBjbWQueTIgLSBjbWQueTE7XG4gICAgICAgICAgICBkeCA9IGNtZC54IC0gY21kLngyO1xuICAgICAgICAgICAgZHkgPSBjbWQueSAtIGNtZC55MjtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuICAgICAgICAgICAgeCA9IGNtZC54O1xuICAgICAgICAgICAgeSA9IGNtZC55O1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHMucHVzaCh7bmFtZTogJ2VuZGNoYXInLCB0eXBlOiAnT1AnLCB2YWx1ZTogMTR9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhclN0cmluZ3MgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnUHJpdmF0ZSBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChQUklWQVRFX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdQcml2YXRlIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAncHJpdmF0ZURpY3RzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQucHJpdmF0ZURpY3RzID0gW3tuYW1lOiAncHJpdmF0ZURpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBwcml2YXRlRGljdH1dO1xuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlQ0ZGVGFibGUoZ2x5cGhzLCBvcHRpb25zKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ0NGRiAnLCBbXG4gICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdEluZGV4JywgdHlwZTogJ1RBQkxFJ31cbiAgICBdKTtcblxuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgdmFyIGF0dHJzID0ge1xuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBvcHRpb25zLmZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodDogb3B0aW9ucy53ZWlnaHROYW1lLFxuICAgICAgICBjaGFyc2V0OiA5OTksXG4gICAgICAgIGVuY29kaW5nOiAwLFxuICAgICAgICBjaGFyU3RyaW5nczogOTk5LFxuICAgICAgICBwcml2YXRlOiBbMCwgOTk5XVxuICAgIH07XG5cbiAgICB2YXIgcHJpdmF0ZUF0dHJzID0ge307XG5cbiAgICB2YXIgZ2x5cGhOYW1lcyA9IFtdO1xuICAgIC8vIFNraXAgZmlyc3QgZ2x5cGggKC5ub3RkZWYpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoc1tpXS5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG4gICAgdC5oZWFkZXIgPSBtYWtlSGVhZGVyKCk7XG4gICAgdC5uYW1lSW5kZXggPSBtYWtlTmFtZUluZGV4KFtvcHRpb25zLnBvc3RTY3JpcHROYW1lXSk7XG4gICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuICAgIHQuZ2xvYmFsU3VickluZGV4ID0gbWFrZUdsb2JhbFN1YnJJbmRleCgpO1xuICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG4gICAgdC5jaGFyU3RyaW5nc0luZGV4ID0gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKTtcbiAgICB2YXIgcHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnByaXZhdGVEaWN0SW5kZXggPSBtYWtlUHJpdmF0ZURpY3RJbmRleChwcml2YXRlRGljdCk7XG5cbiAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cbiAgICB0LnN0cmluZ0luZGV4ID0gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpO1xuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdC5oZWFkZXIuc2l6ZU9mKCkgK1xuICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQudG9wRGljdEluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5zdHJpbmdJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuICAgIGF0dHJzLmNoYXJzZXQgPSBzdGFydE9mZnNldDtcbiAgICBhdHRycy5lbmNvZGluZyA9IDA7IC8vIFdlIHVzZSB0aGUgQ0ZGIHN0YW5kYXJkIGVuY29kaW5nOyBwcm9wZXIgZW5jb2Rpbmcgd2lsbCBiZSBoYW5kbGVkIGluIGNtYXAuXG4gICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcbiAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cbiAgICAvLyBSZWNyZWF0ZSB0aGUgVG9wIERJQ1QgSU5ERVggd2l0aCB0aGUgY29ycmVjdCBvZmZzZXRzLlxuICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUNGRlRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUNGRlRhYmxlO1xuIiwiLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NtYXAuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIFRoZXJlIGFyZSBtYW55IGF2YWlsYWJsZSBmb3JtYXRzLCBidXQgd2Ugb25seSBzdXBwb3J0IHRoZSBXaW5kb3dzIGZvcm1hdCA0LlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHZlcnNpb24sIG51bVRhYmxlcywgb2Zmc2V0LCBwbGF0Zm9ybUlkLCBlbmNvZGluZ0lkLCBmb3JtYXQsIHNlZ0NvdW50LFxuICAgICAgICBlbmRDb3VudFBhcnNlciwgc3RhcnRDb3VudFBhcnNlciwgaWREZWx0YVBhcnNlciwgaWRSYW5nZU9mZnNldFBhcnNlciwgZ2x5cGhJbmRleE9mZnNldCxcbiAgICAgICAgZW5kQ291bnQsIHN0YXJ0Q291bnQsIGksIGMsIGlkRGVsdGEsIGlkUmFuZ2VPZmZzZXQsIHAsIGdseXBoSW5kZXg7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSB2ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudCh2ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtdGFibGVzID0gbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgb2Zmc2V0ID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG4gICAgICAgIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuICAgICAgICBpZiAocGxhdGZvcm1JZCA9PT0gMyAmJiAoZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAwKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY21hcCB0YWJsZSBpbiB0aGUgZm9udCB0aGF0IHdlIHN1cHBvcnQsIHNvIHJldHVybiBudWxsLlxuICAgICAgICAvLyBUaGlzIGZvbnQgd2lsbCBiZSBtYXJrZWQgYXMgdW5zdXBwb3J0ZWQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBjbWFwLmZvcm1hdCA9IGZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChmb3JtYXQgPT09IDQsICdPbmx5IGZvcm1hdCA0IGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGVuZENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE0KTtcbiAgICBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyKTtcbiAgICBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0KTtcbiAgICBpZFJhbmdlT2Zmc2V0UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA2KTtcbiAgICBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAoYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gaWRSYW5nZU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIHZhciBpLCBqLCBnbHlwaDtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxMn0sXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcblxuICAgIHQuc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50O1xuICAgIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdC5zZWdDb3VudFgyID0gc2VnQ291bnQgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHNlZ0NvdW50KSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXSxcbiAgICAgICAgc3RhcnRDb3VudHMgPSBbXSxcbiAgICAgICAgaWREZWx0YXMgPSBbXSxcbiAgICAgICAgaWRSYW5nZU9mZnNldHMgPSBbXSxcbiAgICAgICAgZ2x5cGhJZHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcbiAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGVuZENvdW50cyk7XG4gICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3Jlc2VydmVkUGFkJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoc3RhcnRDb3VudHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkRGVsdGFzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZFJhbmdlT2Zmc2V0cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZ2x5cGhJZHMpO1xuXG4gICAgdC5sZW5ndGggPSAxNCArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuICAgICAgICBzdGFydENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBnbHlwaElkcy5sZW5ndGggKiAyO1xuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VDbWFwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ21hcFRhYmxlO1xuIiwiLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9nbHlmLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IHJlcXVpcmUoJy4uL2NoZWNrJyk7XG52YXIgX2dseXBoID0gcmVxdWlyZSgnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL3BhdGgnKTtcblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZGF0YSwgc3RhcnQsIGluZGV4LCBmb250KSB7XG4gICAgdmFyIHAsIGdseXBoLCBmbGFnLCBpLCBqLCBmbGFncyxcbiAgICAgICAgZW5kUG9pbnRJbmRpY2VzLCBudW1iZXJPZkNvb3JkaW5hdGVzLCByZXBlYXRDb3VudCwgcG9pbnRzLCBwb2ludCwgcHgsIHB5LFxuICAgICAgICBjb21wb25lbnQsIG1vcmVDb21wb25lbnRzO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzLCBpLCBwdCwgbmV3UHQ7XG4gICAgbmV3UG9pbnRzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCwgY29udG91cnMsIGksIHJlYWxGaXJzdFBvaW50LCBqLCBjb250b3VyLCBwdCwgZmlyc3RQdCxcbiAgICAgICAgcHJldlB0LCBtaWRQdCwgY3VydmVQdCwgbGFzdFB0O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29udG91ciA9IGNvbnRvdXJzW2ldO1xuICAgICAgICBmaXJzdFB0ID0gY29udG91clswXTtcbiAgICAgICAgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gZmlyc3RQdDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCBpcyBzeW50aGVzaXplZCwgc28gZG9uJ3Qgc2tpcCB0aGUgcmVhbCBmaXJzdCBwb2ludC5cbiAgICAgICAgICAgIHJlYWxGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcC5tb3ZlVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuXG4gICAgICAgIGZvciAoaiA9IHJlYWxGaXJzdFBvaW50ID8gMSA6IDA7IGogPCBjb250b3VyLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICBwcmV2UHQgPSBqID09PSAwID8gZmlyc3RQdCA6IGNvbnRvdXJbaiAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2UHQub25DdXJ2ZSAmJiAhcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1pZFB0ID0geyB4OiAocHJldlB0LnggKyBwdC54KSAvIDIsIHk6IChwcmV2UHQueSArIHB0LnkpIC8gMiB9O1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhwcmV2UHQueCwgcHJldlB0LnksIG1pZFB0LngsIG1pZFB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91cyBwb2ludCBvZmYtY3VydmUsIHRoaXMgcG9pbnQgb24tY3VydmUuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFB0ICE9PSBsYXN0UHQpIHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGxhc3QgYW5kIGZpcnN0IHBvaW50c1xuICAgICAgICAgICAgaWYgKGN1cnZlUHQpIHtcbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC5saW5lVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMsIGksIGosIG9mZnNldCwgbmV4dE9mZnNldCwgZ2x5cGgsXG4gICAgICAgIGNvbXBvbmVudCwgY29tcG9uZW50R2x5cGgsIHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIGdseXBocyA9IFtdO1xuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChwYXJzZUdseXBoKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBpLCBmb250KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaX0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHbyBvdmVyIHRoZSBnbHlwaHMgYWdhaW4sIHJlc29sdmluZyB0aGUgY29tcG9zaXRlIGdseXBocy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRHbHlwaCA9IGdseXBoc1tjb21wb25lbnQuZ2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbHlwaC5wYXRoID0gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHbHlmVGFibGU7XG4iLCIvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBuID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIEZvcm1hdCAxIGlzIGEgc2ltcGxlIGxpc3Qgb2YgZ2x5cGggaWRzLFxuLy8gRm9ybWF0IDIgaXMgYSBsaXN0IG9mIHJhbmdlcy4gSXQgaXMgZXhwYW5kZWQgaW4gYSBsaXN0IG9mIGdseXBocywgbWF5YmUgbm90IHRoZSBiZXN0IGlkZWEuXG5mdW5jdGlvbiBwYXJzZUNvdmVyYWdlVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIGNvdW50ID0gIHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwLnBhcnNlVVNob3J0TGlzdChjb3VudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgaSwgYmVnaW4sIGVuZCwgaW5kZXgsIGNvdmVyYWdlID0gW107XG4gICAgICAgIGZvciAoOyBjb3VudC0tOykge1xuICAgICAgICAgICAgYmVnaW4gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBlbmQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBpbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3ZlcmFnZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBjbGFzcyB2YWx1ZSBmcm9tIGEgZ2x5cGggSUQuXG5mdW5jdGlvbiBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGb3JtYXQgMSBzcGVjaWZpZXMgYSByYW5nZSBvZiBjb25zZWN1dGl2ZSBnbHlwaCBpbmRpY2VzLCBvbmUgY2xhc3MgcGVyIGdseXBoIElELlxuICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGdseXBoQ291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzID0gcC5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihnbHlwaElEKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlc1tnbHlwaElEIC0gc3RhcnRHbHlwaF0gfHwgMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIEZvcm1hdCAyIGRlZmluZXMgbXVsdGlwbGUgZ3JvdXBzIG9mIGdseXBoIGluZGljZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgY2xhc3MuXG4gICAgICAgIHZhciByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgc3RhcnRHbHlwaHMgPSBbXSxcbiAgICAgICAgICAgIGVuZEdseXBocyA9IFtdLFxuICAgICAgICAgICAgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHZhciBsLCBjLCByO1xuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICByID0gc3RhcnRHbHlwaHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICAgICAgICAgIGMgPSAobCArIHIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaElEIDwgc3RhcnRHbHlwaHNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEdseXBoc1tsXSA8PSBnbHlwaElEICYmIGdseXBoSUQgPD0gZW5kR2x5cGhzW2xdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsdWVzW2xdIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgcGFpciBhZGp1c3RtZW50IHBvc2l0aW9uaW5nIHN1YnRhYmxlLCBmb3JtYXQgMSBvciBmb3JtYXQgMlxuLy8gVGhlIHN1YnRhYmxlIGlzIHJldHVybmVkIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwIGZ1bmN0aW9uLlxuZnVuY3Rpb24gcGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQsIGNvdmVyYWdlT2Zmc2V0LCBjb3ZlcmFnZSwgdmFsdWVGb3JtYXQxLCB2YWx1ZUZvcm1hdDIsXG4gICAgICAgIHNoYXJlZFBhaXJTZXRzLCBmaXJzdEdseXBoLCBzZWNvbmRHbHlwaCwgdmFsdWUxLCB2YWx1ZTI7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0K2NvdmVyYWdlT2Zmc2V0KTtcbiAgICAvLyB2YWx1ZUZvcm1hdCA0OiBYQWR2YW5jZSBvbmx5LCAxOiBYUGxhY2VtZW50IG9ubHksIDA6IG5vIFZhbHVlUmVjb3JkIGZvciBzZWNvbmQgZ2x5cGhcbiAgICAvLyBPbmx5IHZhbHVlRm9ybWF0MT00IGFuZCB2YWx1ZUZvcm1hdDI9MCBpcyBzdXBwb3J0ZWQuXG4gICAgdmFsdWVGb3JtYXQxID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhbHVlRm9ybWF0MiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAodmFsdWVGb3JtYXQxICE9PSA0IHx8IHZhbHVlRm9ybWF0MiAhPT0gMCkgcmV0dXJuO1xuICAgIHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIHZhciBwYWlyU2V0Q291bnQsIHBhaXJTZXRPZmZzZXRzLCBwYWlyU2V0T2Zmc2V0LCBzaGFyZWRQYWlyU2V0LCBwYWlyVmFsdWVDb3VudCwgcGFpclNldDtcbiAgICAgICAgcGFpclNldENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwYWlyU2V0ID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIG9mZnNldHMgdG8gUGFpclNldCB0YWJsZXMtZnJvbSBiZWdpbm5pbmcgb2YgUGFpclBvcyBzdWJ0YWJsZS1vcmRlcmVkIGJ5IENvdmVyYWdlIEluZGV4XG4gICAgICAgIHBhaXJTZXRPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChwYWlyU2V0Q291bnQpO1xuICAgICAgICBmb3IgKGZpcnN0R2x5cGggPSAwOyBmaXJzdEdseXBoIDwgcGFpclNldENvdW50OyBmaXJzdEdseXBoKyspIHtcbiAgICAgICAgICAgIHBhaXJTZXRPZmZzZXQgPSBwYWlyU2V0T2Zmc2V0c1tmaXJzdEdseXBoXTtcbiAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICBwYWlyVmFsdWVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgcGFpclZhbHVlQ291bnQtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDEpIHZhbHVlMSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHZhbHVlMSBpcyB0aGUgWEFkdmFuY2UgYW5kIHZhbHVlMiBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGFpclNldFtzZWNvbmRHbHlwaF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpclNldFtjb3ZlcmFnZVtmaXJzdEdseXBoXV0gPSBzaGFyZWRQYWlyU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlycyA9IHBhaXJTZXRbbGVmdEdseXBoXTtcbiAgICAgICAgICAgIGlmIChwYWlycykgcmV0dXJuIHBhaXJzW3JpZ2h0R2x5cGhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgLy8gUGFpciBQb3NpdGlvbmluZyBBZGp1c3RtZW50OiBGb3JtYXQgMlxuICAgICAgICB2YXIgY2xhc3NEZWYxT2Zmc2V0LCBjbGFzc0RlZjJPZmZzZXQsIGNsYXNzMUNvdW50LCBjbGFzczJDb3VudCwgaSwgaixcbiAgICAgICAgICAgIGdldENsYXNzMSwgZ2V0Q2xhc3MyLCBrZXJuaW5nTWF0cml4LCBrZXJuaW5nUm93LCBjb3ZlcmVkO1xuICAgICAgICBjbGFzc0RlZjFPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2xhc3MxQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzMkNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQrY2xhc3NEZWYxT2Zmc2V0KTtcbiAgICAgICAgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0K2NsYXNzRGVmMk9mZnNldCk7XG5cbiAgICAgICAgLy8gUGFyc2Uga2VybmluZyB2YWx1ZXMgYnkgY2xhc3MgcGFpci5cbiAgICAgICAga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3MxQ291bnQ7IGkrKykge1xuICAgICAgICAgICAga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIGNvdmVyZWQgPSB7fTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgY292ZXJhZ2UubGVuZ3RoOyBpKyspIGNvdmVyZWRbY292ZXJhZ2VbaV1dID0gMTtcblxuICAgICAgICAvLyBHZXQgdGhlIGtlcm5pbmcgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZ2x5cGggcGFpci5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkW2xlZnRHbHlwaF0pIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpLFxuICAgICAgICAgICAgICAgIGNsYXNzMiA9IGdldENsYXNzMihyaWdodEdseXBoKSxcbiAgICAgICAgICAgICAgICBrZXJuaW5nUm93ID0ga2VybmluZ01hdHJpeFtjbGFzczFdO1xuICAgICAgICAgICAgcmV0dXJuIGtlcm5pbmdSb3cgPyBrZXJuaW5nUm93W2NsYXNzMl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBMb29rdXBUYWJsZSAocHJlc2VudCBpbiBvZiBHUE9TLCBHU1VCLCBHREVGLCBCQVNFLCBKU1RGIHRhYmxlcykuXG5mdW5jdGlvbiBwYXJzZUxvb2t1cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGUsIGxvb2t1cFR5cGUsIGxvb2t1cEZsYWcsIHVzZU1hcmtGaWx0ZXJpbmdTZXQsIHN1YlRhYmxlQ291bnQsIHN1YlRhYmxlT2Zmc2V0cywgc3VidGFibGVzLCBpO1xuICAgIGxvb2t1cFR5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwRmxhZyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgc3ViVGFibGVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBzdWJUYWJsZU9mZnNldHMgPSBwLnBhcnNlT2Zmc2V0MTZMaXN0KHN1YlRhYmxlQ291bnQpO1xuICAgIHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgc3VidGFibGVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdWJUYWJsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKHBhcnNlUGFpclBvc1N1YlRhYmxlKGRhdGEsIHN0YXJ0ICsgc3ViVGFibGVPZmZzZXRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggZmluZHMgdGhlIGtlcm5pbmcgdmFsdWVzIGluIHRoZSBzdWJ0YWJsZXMuXG4gICAgICAgIHRhYmxlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN1YnRhYmxlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdWJ0YWJsZXNbaV0obGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbn1cblxuLy8gUGFyc2UgdGhlIGBHUE9TYCB0YWJsZSB3aGljaCBjb250YWlucywgYW1vbmcgb3RoZXIgdGhpbmdzLCBrZXJuaW5nIHBhaXJzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICB2YXIgcCwgdGFibGVWZXJzaW9uLCBsb29rdXBMaXN0T2Zmc2V0LCBzY3JpcHRMaXN0LCBpLCBmZWF0dXJlTGlzdCwgbG9va3VwQ291bnQsXG4gICAgICAgIGxvb2t1cFRhYmxlT2Zmc2V0cywgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0LCB0YWJsZTtcblxuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB0YWJsZVZlcnNpb24gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHUE9TIHRhYmxlIHZlcnNpb24uJyk7XG5cbiAgICAvLyBTY3JpcHRMaXN0IGFuZCBGZWF0dXJlTGlzdCAtIGlnbm9yZWQgZm9yIG5vd1xuICAgIHNjcmlwdExpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuICAgIC8vICdrZXJuJyBpcyB0aGUgZmVhdHVyZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgZmVhdHVyZUxpc3QgPSBwYXJzZVRhZ2dlZExpc3RUYWJsZShkYXRhLCBzdGFydCtwLnBhcnNlVVNob3J0KCkpO1xuXG4gICAgLy8gTG9va3VwTGlzdFxuICAgIGxvb2t1cExpc3RPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCA9IGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgbG9va3VwQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbG9va3VwVGFibGVPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChsb29rdXBDb3VudCk7XG4gICAgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ID0gc3RhcnQgKyBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb29rdXBDb3VudDsgaSsrKSB7XG4gICAgICAgIHRhYmxlID0gcGFyc2VMb29rdXBUYWJsZShkYXRhLCBsb29rdXBMaXN0QWJzb2x1dGVPZmZzZXQgKyBsb29rdXBUYWJsZU9mZnNldHNbaV0pO1xuICAgICAgICBpZiAodGFibGUubG9va3VwVHlwZSA9PT0gMiAmJiAhZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlKSBmb250LmdldEdwb3NLZXJuaW5nVmFsdWUgPSB0YWJsZS5nZXRLZXJuaW5nVmFsdWU7XG4gICAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHcG9zVGFibGU7XG4iLCIvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSByZXF1aXJlKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7ICAgICAvLyA1MFxuICAgIGhlYWQuZ2x5cGhEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udERpcmVjdGlvbkhpbnQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGVhZFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhlYWRUYWJsZTtcbiIsIi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGhlYVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhoZWFUYWJsZTtcbiIsIi8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaG10eC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgcCwgaSwgZ2x5cGgsIGFkdmFuY2VXaWR0aCwgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHZhciBhZHZhbmNlV2lkdGggPSBnbHlwaC5hZHZhbmNlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIbXR4VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSG10eFRhYmxlO1xuXG5cblxuIiwiLy8gVGhlIGBrZXJuYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuLy8gTm90ZSB0aGF0IHNvbWUgZm9udHMgdXNlIHRoZSBHUE9TIE9wZW5UeXBlIGxheW91dCB0YWJsZSB0byBzcGVjaWZ5IGtlcm5pbmcuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2tlcm4uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBhaXJzLCBwLCB0YWJsZVZlcnNpb24sIHN1YlRhYmxlVmVyc2lvbiwgblBhaXJzLFxuICAgICAgICBpLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgsIHZhbHVlO1xuICAgIHBhaXJzID0ge307XG4gICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBuVGFibGVzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgc3ViVGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YlRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJUYWJsZUxlbmd0aCwgc3ViVGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUtlcm5UYWJsZTtcbiIsIi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbG9jYS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCwgcGFyc2VGbiwgZ2x5cGhPZmZzZXRzLCBnbHlwaE9mZnNldCwgaTtcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUxvY2FUYWJsZTtcbiIsIi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuLy8gV2UgbmVlZCBpdCBqdXN0IHRvIGdldCB0aGUgbnVtYmVyIG9mIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbWF4cC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4cDtcbn1cblxuZnVuY3Rpb24gbWFrZU1heHBUYWJsZShudW1HbHlwaHMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdtYXhwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtR2x5cGhzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBudW1HbHlwaHN9XG4gICAgXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZU1heHBUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VNYXhwVGFibGU7XG4iLCIvLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbmFtZS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RlID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5lbmNvZGU7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gcmVxdWlyZSgnLi4vdGFibGUnKTtcblxuLy8gTmFtZUlEcyBmb3IgdGhlIG5hbWUgdGFibGUuXG52YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2VuY2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbmNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGVcbi8vIE9ubHkgV2luZG93cyBVbmljb2RlIEVuZ2xpc2ggbmFtZXMgYXJlIHN1cHBvcnRlZC5cbi8vIEZvcm1hdCAxIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBuYW1lID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBuYW1lLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIHByb3BlcnR5LCBieXRlTGVuZ3RoLFxuICAgICAgICBvZmZzZXQsIHN0ciwgaSwgaiwgY29kZVBvaW50cztcbiAgICB2YXIgdW5rbm93bkNvdW50ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGVuY29kaW5nSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lVGFibGVOYW1lc1tuYW1lSURdO1xuICAgICAgICBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIHBsYXRmb3JtSUQgLSBlbmNvZGluZ0lEIC0gbGFuZ3VhZ2VJRCBzdGFuZGFyZCBjb21iaW5hdGlvbnMgOlxuICAgICAgICAvLyAxIC0gMCAtIDAgOiBNYWNpbnRvc2gsIFJvbWFuLCBFbmdsaXNoXG4gICAgICAgIC8vIDMgLSAxIC0gMHg0MDkgOiBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBlbi1VU1xuICAgICAgICBpZiAocGxhdGZvcm1JRCA9PT0gMyAmJiBlbmNvZGluZ0lEID09PSAxICYmIGxhbmd1YWdlSUQgPT09IDB4NDA5KSB7XG4gICAgICAgICAgICBjb2RlUG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aC8yO1xuICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgbGVuZ3RoOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50c1tqXSA9IHBhcnNlLmdldFNob3J0KGRhdGEsIHN0cmluZ09mZnNldCtvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG5hbWVbcHJvcGVydHldID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkNvdW50Kys7XG4gICAgICAgICAgICAgICAgbmFtZVsndW5rbm93bicrdW5rbm93bkNvdW50XSA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmIChuYW1lLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICBuYW1lLmxhbmdUYWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lUmVjb3JkKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgbGVuZ3RoLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdOYW1lUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGVuY29kaW5nSUR9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIGFkZE1hY2ludG9zaE5hbWVSZWNvcmQodCwgcmVjb3JkSUQsIHMsIG9mZnNldCkge1xuICAgIC8vIE1hY2ludG9zaCwgUm9tYW4sIEVuZ2xpc2hcbiAgICB2YXIgc3RyaW5nQnl0ZXMgPSBlbmNvZGUuU1RSSU5HKHMpO1xuICAgIHQucmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKDEsIDAsIDAsIHJlY29yZElELCBzdHJpbmdCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHN0cmluZ0J5dGVzKTtcbiAgICBvZmZzZXQgKz0gc3RyaW5nQnl0ZXMubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGFkZFdpbmRvd3NOYW1lUmVjb3JkKHQsIHJlY29yZElELCBzLCBvZmZzZXQpIHtcbiAgICAvLyBXaW5kb3dzLCBVbmljb2RlIEJNUCAoVUNTLTIpLCBVUyBFbmdsaXNoXG4gICAgdmFyIHV0ZjE2Qnl0ZXMgPSBlbmNvZGUuVVRGMTYocyk7XG4gICAgdC5yZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgMHgwNDA5LCByZWNvcmRJRCwgdXRmMTZCeXRlcy5sZW5ndGgsIG9mZnNldCkpO1xuICAgIHQuc3RyaW5ncy5wdXNoKHV0ZjE2Qnl0ZXMpO1xuICAgIG9mZnNldCArPSB1dGYxNkJ5dGVzLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgcztcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnbmFtZScsIFtcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgdC5yZWNvcmRzID0gW107XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgLy8gQWRkIE1hY2ludG9zaCByZWNvcmRzIGZpcnN0XG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRNYWNpbnRvc2hOYW1lUmVjb3JkKHQsIGksIHMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlbiBhZGQgV2luZG93cyByZWNvcmRzXG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVUYWJsZU5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gb3B0aW9uc1tuYW1lVGFibGVOYW1lc1tpXV07XG4gICAgICAgICAgICBvZmZzZXQgPSBhZGRXaW5kb3dzTmFtZVJlY29yZCh0LCBpLCBzLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdC5jb3VudCA9IHQucmVjb3Jkcy5sZW5ndGg7XG4gICAgdC5zdHJpbmdPZmZzZXQgPSA2ICsgdC5jb3VudCAqIDEyO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0LnJlY29yZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHQucmVjb3Jkc1tpXX0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdC5zdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHQuc3RyaW5nc1tpXX0pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlTmFtZVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZU5hbWVUYWJsZTtcbiIsIi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBvczIgPSB7fSxcbiAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG9zMi52ZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi54QXZnQ2hhcldpZHRoID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2lkdGhDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuZnNUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0U2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIuc0ZhbWlseUNsYXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnBhbm9zZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBvczIucGFub3NlW2ldID0gcC5wYXJzZUJ5dGUoKTtcbiAgICB9XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG4gICAgICAgIG9zMi5zeEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzQnJlYWtDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3MyO1xufVxuXG5mdW5jdGlvbiBtYWtlT1MyVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMHgwMDAzfSxcbiAgICAgICAge25hbWU6ICd4QXZnQ2hhcldpZHRoJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2lkdGhDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZnNUeXBlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0U2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0UG9zaXRpb24nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0ZhbWlseUNsYXNzJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JGYW1pbHlUeXBlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiV2VpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlByb3BvcnRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU3Ryb2tlVmFyaWF0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkFybVN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTWlkbGluZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JYSGVpZ2h0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2FjaFZlbmRJRCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogJ1hYWFgnfSxcbiAgICAgICAge25hbWU6ICdmc1NlbGVjdGlvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNMYXN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0FzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvTGluZUdhcCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkFzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc0NhcEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0RlZmF1bHRDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNNYXhDb250ZXh0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VPUzJUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VPUzJUYWJsZTtcbiIsIi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCcuLi9lbmNvZGluZycpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VQb3N0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcG9zdCA9IHt9LFxuICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCksXG4gICAgICAgIGksIG5hbWVMZW5ndGg7XG4gICAgcG9zdC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBwb3N0Lml0YWxpY0FuZ2xlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QudW5kZXJsaW5lVGhpY2tuZXNzID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC5pc0ZpeGVkUGl0Y2ggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgICAgcG9zdC5uYW1lcyA9IGVuY29kaW5nLnN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPj0gZW5jb2Rpbmcuc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyLjU6XG4gICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldFtpXSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG5mdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDMwMDAwfSxcbiAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICBdKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlUG9zdFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZVBvc3RUYWJsZTtcbiIsIi8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG4vLyBJdCBpcyB0aGUgdG9wLWxldmVsIGRhdGEgc3RydWN0dXJlIGluIGEgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3RmZi5odG1cbi8vIFJlY29tbWVuZGF0aW9ucyBmb3IgY3JlYXRpbmcgT3BlblR5cGUgRm9udHM6XG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMxNDAvcmVjb20uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gcmVxdWlyZSgnLi4vY2hlY2snKTtcbnZhciB0YWJsZSA9IHJlcXVpcmUoJy4uL3RhYmxlJyk7XG5cbnZhciBjbWFwID0gcmVxdWlyZSgnLi9jbWFwJyk7XG52YXIgY2ZmID0gcmVxdWlyZSgnLi9jZmYnKTtcbnZhciBoZWFkID0gcmVxdWlyZSgnLi9oZWFkJyk7XG52YXIgaGhlYSA9IHJlcXVpcmUoJy4vaGhlYScpO1xudmFyIGhtdHggPSByZXF1aXJlKCcuL2htdHgnKTtcbnZhciBtYXhwID0gcmVxdWlyZSgnLi9tYXhwJyk7XG52YXIgX25hbWUgPSByZXF1aXJlKCcuL25hbWUnKTtcbnZhciBvczIgPSByZXF1aXJlKCcuL29zMicpO1xudmFyIHBvc3QgPSByZXF1aXJlKCcuL3Bvc3QnKTtcblxuZnVuY3Rpb24gbG9nMih2KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikgfCAwO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnVGFibGUgUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG9mZnNldCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0IDogMH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcbiAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG4gICAgc2ZudC5zZWFyY2hSYW5nZSA9IDE2ICogaGlnaGVzdFBvd2VyT2YyO1xuICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcbiAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuICAgIHZhciByZWNvcmRGaWVsZHMgPSBbXTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQodC50YWJsZU5hbWUubGVuZ3RoID09PSA0LCAnVGFibGUgbmFtZScgKyB0LnRhYmxlTmFtZSArICcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcbiAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogdC50YWJsZU5hbWUgKyAnIHRhYmxlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcbiAgICByZXR1cm4gc2ZudDtcbn1cblxuLy8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBtZXRyaWNzIGZvciB0aGUgZmlyc3QgYXZhaWxhYmxlIGNoYXJhY3Rlci5cbi8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBhbmQgbGFyZ2VzdCB1bmljb2RlIHZhbHVlcyBvZiB0aGUgY2hhcmFjdGVycyBpbiB0aGlzIGZvbnQuXG4vLyBGb3IgbW9zdCBmb250cyB0aGUgc21hbGxlc3QgdmFsdWUgd291bGQgYmUgMjAgKHNwYWNlKS5cbmZ1bmN0aW9uIGNoYXJDb2RlQm91bmRzKGdseXBocykge1xuICAgIHZhciBtaW5Db2RlLCBtYXhDb2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGdseXBoLnVuaWNvZGUgPj0gMjApIHtcbiAgICAgICAgICAgIGlmIChtaW5Db2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA8IG1pbkNvZGUpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA+IG1heENvZGUpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbkNvZGUsIG1heENvZGVdO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tpXTtcbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGdsb2JhbHMueU1heDtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGdsb2JhbHMueU1pbjtcblxuICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcbiAgICAgICAgeU1pbjogZ2xvYmFscy55TWluLFxuICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG4gICAgICAgIHlNYXg6IGdsb2JhbHMueU1heFxuICAgIH0pO1xuXG4gICAgdmFyIGhoZWFUYWJsZSA9IGhoZWEubWFrZSh7XG4gICAgICAgIC8vIEFkZGluZyBhIGxpdHRsZSBoZXJlIG1ha2VzIE9TIFggUXVpY2sgTG9vayBoYXBweVxuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBjb2RlQm91bmRzID0gY2hhckNvZGVCb3VuZHMoZm9udC5nbHlwaHMpO1xuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKHtcbiAgICAgICAgeEF2Z0NoYXJXaWR0aDogTWF0aC5yb3VuZChnbG9iYWxzLmFkdmFuY2VXaWR0aEF2ZyksXG4gICAgICAgIHVzV2VpZ2h0Q2xhc3M6IDUwMCwgLy8gTWVkaXVtIEZJWE1FIE1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAgICAgdXNXaWR0aENsYXNzOiA1LCAvLyBNZWRpdW0gKG5vcm1hbCkgRklYTUUgTWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBjb2RlQm91bmRzWzBdLFxuICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGNvZGVCb3VuZHNbMV0sXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMTogMHgwMDAwMDAwMSwgLy8gQmFzaWMgTGF0aW5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly90eXBvcGhpbGUuY29tL25vZGUvMTMwODEgZm9yIG1vcmUgaW5mbyBvbiB2ZXJ0aWNhbCBtZXRyaWNzLlxuICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cbiAgICAgICAgLy8gV2UgcHJvdmlkZSBzb21lIGZhbGxiYWNrIGNoYXJhY3RlcnMgaWYgY2hhcmFjdGVycyBhcmUgdW5hdmFpbGFibGU6IHRoZWlyXG4gICAgICAgIC8vIG9yZGVyaW5nIHdhcyBjaG9zZW4gZXhwZXJpbWVudGFsbHkuXG4gICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHNUeXBvRGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgc1R5cG9MaW5lR2FwOiAwLFxuICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgdXNXaW5EZXNjZW50OiAtZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHVsQ29kZVBhZ2VSYW5nZTE6IDB4MDAwMDAwMDEsIC8vIEJhc2ljIExhdGluXG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiAwfSkueU1heCxcbiAgICAgICAgc0NhcEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ0hJS0xFRkpNTlRaQkRQUkFHT1FTVVZXWFknLCBnbG9iYWxzKS55TWF4LFxuICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICB9KTtcblxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IGhtdHgubWFrZShmb250LmdseXBocyk7XG4gICAgdmFyIGNtYXBUYWJsZSA9IGNtYXAubWFrZShmb250LmdseXBocyk7XG5cbiAgICB2YXIgZnVsbE5hbWUgPSBmb250LmZhbWlseU5hbWUgKyAnICcgKyBmb250LnN0eWxlTmFtZTtcbiAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGZvbnQuc3R5bGVOYW1lO1xuICAgIHZhciBuYW1lVGFibGUgPSBfbmFtZS5tYWtlKHtcbiAgICAgICAgY29weXJpZ2h0OiBmb250LmNvcHlyaWdodCxcbiAgICAgICAgZm9udEZhbWlseTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICBmb250U3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgdW5pcXVlSUQ6IGZvbnQubWFudWZhY3R1cmVyICsgJzonICsgZnVsbE5hbWUsXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgdmVyc2lvbjogZm9udC52ZXJzaW9uLFxuICAgICAgICBwb3N0U2NyaXB0TmFtZTogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgIHRyYWRlbWFyazogZm9udC50cmFkZW1hcmssXG4gICAgICAgIG1hbnVmYWN0dXJlcjogZm9udC5tYW51ZmFjdHVyZXIsXG4gICAgICAgIGRlc2lnbmVyOiBmb250LmRlc2lnbmVyLFxuICAgICAgICBkZXNjcmlwdGlvbjogZm9udC5kZXNjcmlwdGlvbixcbiAgICAgICAgbWFudWZhY3R1cmVyVVJMOiBmb250Lm1hbnVmYWN0dXJlclVSTCxcbiAgICAgICAgZGVzaWduZXJVUkw6IGZvbnQuZGVzaWduZXJVUkwsXG4gICAgICAgIGxpY2Vuc2U6IGZvbnQubGljZW5zZSxcbiAgICAgICAgbGljZW5zZVVSTDogZm9udC5saWNlbnNlVVJMLFxuICAgICAgICBwcmVmZXJyZWRGYW1pbHk6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgcHJlZmVycmVkU3ViZmFtaWx5OiBmb250LnN0eWxlTmFtZVxuICAgIH0pO1xuICAgIHZhciBwb3N0VGFibGUgPSBwb3N0Lm1ha2UoKTtcbiAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuICAgICAgICB2ZXJzaW9uOiBmb250LnZlcnNpb24sXG4gICAgICAgIGZ1bGxOYW1lOiBmdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogZm9udC5mYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHROYW1lOiBmb250LnN0eWxlTmFtZSxcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lXG4gICAgfSk7XG4gICAgLy8gT3JkZXIgdGhlIHRhYmxlcyBhY2NvcmRpbmcgdG8gdGhlIHRoZSBPcGVuVHlwZSBzcGVjaWZpY2F0aW9uIDEuNC5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKTtcbiAgICBoZWFkVGFibGUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuXG4gICAgLy8gQnVpbGQgdGhlIGZvbnQgYWdhaW4sIG5vdyB3aXRoIHRoZSBwcm9wZXIgY2hlY2tTdW0uXG4gICAgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxuZXhwb3J0cy5jb21wdXRlQ2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW07XG5leHBvcnRzLm1ha2UgPSBtYWtlU2ZudFRhYmxlO1xuZXhwb3J0cy5mb250VG9UYWJsZSA9IGZvbnRUb1NmbnRUYWJsZTtcbiIsIi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwb2x5ZmlsbCA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9lczYtY29sbGVjdGlvbnMnKTtcbnZhciBjaGVjayA9IHJlcXVpcmUoJy4vY2hlY2snKTtcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbnZhciBkZWNvZGUgPSB7fTtcbnZhciBlbmNvZGUgPSB7fTtcbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24gKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcbiAgICByZXR1cm4gW3ZdO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYi5wdXNoKHYuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblxuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMTYpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLy8gQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5MT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMzIpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuXG4vLyBGSVhNRSBJbXBsZW1lbnQgTE9OR0RBVEVUSU1FXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59O1xuXG5zaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cbi8vIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlRBRyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbnNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuLy8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW5jb2RlLkNhcmQ4ID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuQ2FyZDE2ID0gc2l6ZU9mLlVTSE9SVDtcblxuZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5TSUQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEgKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbnNpemVPZi5OVU1CRVIgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuLy8gVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMik7XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZm91ci1ieXRlIHZhbHVlLlxuLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuLy8gYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8vIENvbnZlcnQgYSBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIFVURjE2IGJ5dGVzLlxuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiLnB1c2goMCk7XG4gICAgICAgIGIucHVzaCh2LmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn07XG5cbnNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIG9mZlNpemUsIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgICAgIGRhdGFTaXplLCBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZmV0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICBvZmZzZXRzID0gW29mZnNldF07XG4gICAgZGF0YSA9IFtdO1xuICAgIGRhdGFTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIGRhdGFTaXplICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhkYXRhU2l6ZSkvTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbi8vIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIGQgPSBbXSxcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG0pLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIHZhciB2ID0gbVtrXTtcbiAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQVRPUihrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIGVuY29kZS5ESUNUKG0pLmxlbmd0aDtcbn07XG5cbmVuY29kZS5PUEVSQVRPUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24gKHYsIHR5cGUpIHtcbiAgICB2YXIgZCwgaTtcbiAgICBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG4gICAgICAgICAgICAvLyA0IGJ5dGVzLiBUaGlzIG1ha2VzIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgdGhlIHRvcCBkaWN0IGVhc2llci5cbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG52YXIgY3dtID0gbmV3IFdlYWtNYXAoKTtcbi8vIENvbnZlcnQgYSBsaXN0IG9mIENoYXJTdHJpbmcgb3BlcmF0aW9ucyB0byBieXRlcy5cbmVuY29kZS5DSEFSU1RSSU5HID0gZnVuY3Rpb24gKG9wcykge1xuICAgIGlmICggY3dtLmhhcyggb3BzICkgKSB7XG4gICAgICAgIHJldHVybiBjd20uZ2V0KCBvcHMgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdLFxuICAgICAgICBsZW5ndGggPSBvcHMubGVuZ3RoLFxuICAgICAgICBvcCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvcCA9IG9wc1tpXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KCBlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpICk7XG4gICAgfVxuXG4gICAgY3dtLnNldCggb3BzLCBkICk7XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbnNpemVPZi5DSEFSU1RSSU5HID0gZnVuY3Rpb24gKG9wcykge1xuICAgIHJldHVybiBlbmNvZGUuQ0hBUlNUUklORyhvcHMpLmxlbmd0aDtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIENvbnZlcnQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZSB0byBieXRlcy5cbmVuY29kZS5PQkpFQ1QgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW3YudHlwZV07XG4gICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nRnVuY3Rpb24odi52YWx1ZSk7XG59O1xuXG4vLyBDb252ZXJ0IGEgdGFibGUgb2JqZWN0IHRvIGJ5dGVzLlxuLy8gQSB0YWJsZSBjb250YWlucyBhIGxpc3Qgb2YgZmllbGRzIGNvbnRhaW5pbmcgdGhlIG1ldGFkYXRhIChuYW1lLCB0eXBlIGFuZCBkZWZhdWx0IHZhbHVlKS5cbi8vIFRoZSB0YWJsZSBpdHNlbGYgaGFzIHRoZSBmaWVsZCB2YWx1ZXMgc2V0IGFzIGF0dHJpYnV0ZXMuXG5lbmNvZGUuVEFCTEUgPSBmdW5jdGlvbiAodGFibGUpIHtcbiAgICB2YXIgZCA9IFtdLFxuICAgICAgICBsZW5ndGggPSB0YWJsZS5maWVsZHMubGVuZ3RoLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRhYmxlLmZpZWxkc1tpXTtcbiAgICAgICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFibGVbZmllbGQubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlcyA9IGVuY29kaW5nRnVuY3Rpb24odmFsdWUpO1xuICAgICAgICBkID0gZC5jb25jYXQoYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbn07XG5cbi8vIE1lcmdlIGluIGEgbGlzdCBvZiBieXRlcy5cbmVuY29kZS5MSVRFUkFMID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdjtcbn07XG5cbnNpemVPZi5MSVRFUkFMID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGg7XG59O1xuXG5cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLnNpemVPZiA9IHNpemVPZjtcbiIsIi8qIVxuICogUGFwZXIuanMgdjAuOS4yMSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxNCwgSnVlcmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vICYgaHR0cDovL2pvbmF0aGFucHVja2V5LmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBTYXQgTm92IDIyIDE5OjIzOjM1IDIwMTQgLTA4MDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxMyBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBuZXcgZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cbnZhciBCYXNlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuXG5cdFx0Zm9yRWFjaCA9IFtdLmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRmb3JJbiA9IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcylcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRyZXR1cm4geyBfX3Byb3RvX186IHByb3RvIH07XG5cdFx0fSxcblxuXHRcdGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRcdHZhciBnZXQgPSBvYmouX19sb29rdXBHZXR0ZXJfXyAmJiBvYmouX19sb29rdXBHZXR0ZXJfXyhuYW1lKTtcblx0XHRcdHJldHVybiBnZXRcblx0XHRcdFx0XHQ/IHsgZ2V0OiBnZXQsIHNldDogb2JqLl9fbG9va3VwU2V0dGVyX18obmFtZSksXG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuXHRcdFx0XHRcdDogb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG5cdFx0XHRcdFx0XHQ/IHsgdmFsdWU6IG9ialtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdF9kZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRpZiAoKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSAmJiBvYmouX19kZWZpbmVHZXR0ZXJfXykge1xuXHRcdFx0XHRpZiAoZGVzYy5nZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lR2V0dGVyX18obmFtZSwgZGVzYy5nZXQpO1xuXHRcdFx0XHRpZiAoZGVzYy5zZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lU2V0dGVyX18obmFtZSwgZGVzYy5zZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqW25hbWVdID0gZGVzYy52YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0ZGVsZXRlIG9ialtuYW1lXTtcblx0XHRcdHJldHVybiBfZGVmaW5lKG9iaiwgbmFtZSwgZGVzYyk7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmNcblx0XHRcdFx0XHRcdD8gKHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSlcblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0YmVhbjtcblx0XHRcdGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBwcmV2KVxuXHRcdFx0XHRcdHZhbC5iYXNlID0gcHJldjtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpXG5cdFx0XHRcdFx0YmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cdFx0XHRcdGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0fHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKVxuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0aWYgKChkZXNjcmliZShkZXN0LCBuYW1lKVxuXHRcdFx0XHRcdFx0fHwgeyBjb25maWd1cmFibGU6IHRydWUgfSkuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0cmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3JjKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuXHRcdFx0XHR2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG5cdFx0XHRcdFx0c2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuXHRcdFx0XHRcdGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG5cdFx0XHRcdGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUsIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBiaW5kKSB7XG5cdFx0aWYgKG9iailcblx0XHRcdCgnbGVuZ3RoJyBpbiBvYmogJiYgIW9iai5nZXRMZW5ndGhcblx0XHRcdFx0XHQmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHRcdFx0PyBmb3JFYWNoXG5cdFx0XHRcdDogZm9ySW4pLmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdHJldHVybiBiaW5kO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG9iaiwgcHJvcHMsIGV4Y2x1ZGUpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG5cdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoIWV4Y2x1ZGUgfHwgIWV4Y2x1ZGVba2V5XSkpXG5cdFx0XHRcdG9ialtrZXldID0gcHJvcHNba2V5XTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0cmV0dXJuIGluamVjdChmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNldCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuXHR9LCB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbihzcmMpIHtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0dmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuXHRcdFx0XHRcdGJlYW5zID0gc3JjLmJlYW5zLFxuXHRcdFx0XHRcdHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuXHRcdFx0XHRpZiAoc3RhdGljcyAhPT0gc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdFx0aW5qZWN0KHRoaXMsIHN0YXRpY3MsIHRydWUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYXNlID0gdGhpcyxcblx0XHRcdFx0Y3Rvcjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKGN0b3IgPSBhcmd1bWVudHNbaV0uaW5pdGlhbGl6ZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdGRlZmluZShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpIDogY3Rvcjtcblx0XHR9XG5cdH0sIHRydWUpLmluamVjdCh7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0XHRyZXR1cm4gc2V0KHRoaXMsIHByb3BzKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRlYWNoOiBlYWNoLFxuXHRcdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0XHRkZWZpbmU6IGRlZmluZSxcblx0XHRcdGRlc2NyaWJlOiBkZXNjcmliZSxcblx0XHRcdHNldDogc2V0LFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2Vcblx0XHRcdFx0XHRcdHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUsIGRvbnRDaGVjaykge1xuXHRcdGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG5cdFx0XHR2YXIgb3JpZyA9IHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHM7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb3JpZykge1xuXHRcdFx0XHRpZiAob3JpZy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGZ1bmN0aW9uIGNoZWNrS2V5cyhvMSwgbzIpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvMSlcblx0XHRcdFx0XHRpZiAobzEuaGFzT3duUHJvcGVydHkoaSkgJiYgIW8yLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqMSAmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCdcblx0XHRcdFx0XHQmJiBvYmoyICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoIWNoZWNrS2V5cyhvYmoxLCBvYmoyKSB8fCAhY2hlY2tLZXlzKG9iajIsIG9iajEpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSlcblx0XHRcdFx0XHRcdFx0JiYgIUJhc2UuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRyZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcyA9PT0gQmFzZSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0XHRsaXN0Ll9faW5kZXgrKztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG5cdFx0XHRcdHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG5cdFx0XHRcdGluZGV4ID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwO1xuXHRcdFx0aWYgKCFsZW5ndGgpXG5cdFx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoIC0gaW5kZXg7XG5cdFx0XHR2YXIgb2JqID0gbGlzdFtpbmRleF07XG5cdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuXHRcdFx0XHR8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgbGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIDE7XG5cdFx0XHRcdHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSBCYXNlLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRcdG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgaW5kZXggPiAwIHx8IGxlbmd0aCA8IGxpc3QubGVuZ3RoXG5cdFx0XHRcdD8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaW5kZXgsIGluZGV4ICsgbGVuZ3RoKVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRcdGlmIChyZWFkSW5kZXgpIHtcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyBvYmouX19yZWFkO1xuXHRcdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0cGVlazogZnVuY3Rpb24obGlzdCwgc3RhcnQpIHtcblx0XHRcdHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcblx0XHR9LFxuXG5cdFx0cmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuXHRcdH0sXG5cblx0XHRyZWFkQWxsOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHJlcyA9IFtdLFxuXHRcdFx0XHRlbnRyeTtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG5cdFx0XHRcdFx0XHQ/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcblx0XHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdHJlYWROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcblx0XHRcdFx0aGFzT2JqZWN0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0XHRcdGlmIChoYXNPYmplY3QpIHtcblx0XHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQ7XG5cdFx0XHRcdGlmICghZmlsdGVyZWQpIHtcblx0XHRcdFx0XHRmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG5cdFx0XHRcdFx0ZmlsdGVyZWQuX2ZpbHRlcmluZyA9IGxpc3RbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGhhc09iamVjdCA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0Z2V0TmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHZhciBhcmcgPSBsaXN0WzBdO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRsaXN0Ll9oYXNPYmplY3QgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QpXG5cdFx0XHRcdHJldHVybiBuYW1lID8gYXJnW25hbWVdIDogbGlzdC5fZmlsdGVyZWQgfHwgYXJnO1xuXHRcdH0sXG5cblx0XHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0aXNQbGFpblZhbHVlOiBmdW5jdGlvbihvYmosIGFzU3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG5cdFx0XHRcdFx0fHwgYXNTdHJpbmcgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZyc7XG5cdFx0fSxcblxuXHRcdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0dmFyIHJvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKHJvb3QpIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0XHRsZW5ndGg6IDAsXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24oaXRlbSwgY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRcdGlmICghcmVmKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gaXRlbS5fY2xhc3M7XG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWZpbml0aW9uc1tpZF0gPSByZXM7XG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR2YXIgbmFtZSA9IG9iai5fY2xhc3M7XG5cdFx0XHRcdGlmIChuYW1lICYmICFjb21wYWN0ICYmICFyZXMuX2NvbXBhY3QgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHRpZiAoY29tcGFjdClcblx0XHRcdFx0XHRyZXMuX2NvbXBhY3QgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmopXG5cdFx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdFx0PyBbWydkaWN0aW9uYXJ5JywgZGljdGlvbmFyeS5kZWZpbml0aW9uc10sIHJlc11cblx0XHRcdFx0XHQ6IHJlcztcblx0XHR9LFxuXG5cdFx0ZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGpzb24sIGNyZWF0ZSwgX2RhdGEpIHtcblx0XHRcdHZhciByZXMgPSBqc29uO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmICghaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHRcdFx0aWYgKF9kYXRhLmRpY3Rpb25hcnkgJiYganNvbi5sZW5ndGggPT0gMSAmJiAvXiMvLnRlc3QodHlwZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0XHR0eXBlID0gQmFzZS5leHBvcnRzW3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdHlwZSA/IDEgOiAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhKSk7XG5cdFx0XHRcdGlmIChpc0RpY3Rpb25hcnkpIHtcblx0XHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzWzBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUpIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IHJlcztcblx0XHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlcyA9IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKTtcblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkocmVzLCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGpzb24pKSB7XG5cdFx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4ganNvbilcblx0XHRcdFx0XHRyZXNba2V5XSA9IEJhc2UuZGVzZXJpYWxpemUoanNvbltrZXldLCBjcmVhdGUsIF9kYXRhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2Vcblx0XHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHRcdH0sXG5cblx0XHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKGlzVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXTtcblx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdFx0aWYgKGhhbmRsZXJzLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0XHRpZiAoZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT0gMSlcblx0XHRcdFx0XHRcdGVudHJ5Lmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuXHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuXHRcdFx0aW5kZXg7XG5cdFx0aWYgKGVudHJ5ICYmIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT09IC0xXG5cdFx0XHRcdFx0JiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbnRyeS51bmluc3RhbGwpXG5cdFx0XHRcdFx0ZW50cnkudW5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0cmV0dXJuIHRoaXMub24odHlwZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZih0eXBlLCBmdW5jKTtcblx0XHR9KTtcblx0fSxcblxuXHRlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpID09PSBmYWxzZVxuXHRcdFx0XHRcdCYmIGV2ZW50ICYmIGV2ZW50LnN0b3ApIHtcblx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0cmVzcG9uZHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSk7XG5cdH0sXG5cblx0YXR0YWNoOiAnI29uJyxcblx0ZGV0YWNoOiAnI29mZicsXG5cdGZpcmU6ICcjZW1pdCcsXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uKGluc3RhbGwpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MsXG5cdFx0XHRrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZXZlbnRUeXBlc1t0eXBlXSxcblx0XHRcdFx0XHRmdW5jID0gZW50cnlba2V5XTtcblx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbiBpbmplY3Qoc3JjKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gc3JjLl9ldmVudHM7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlcyA9IHt9O1xuXHRcdFx0XHRCYXNlLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdG5hbWUgPSBpc1N0cmluZyA/IGVudHJ5IDoga2V5LFxuXHRcdFx0XHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHR5cGVzW3R5cGVdID0gaXNTdHJpbmcgPyB7fSA6IGVudHJ5O1xuXHRcdFx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0dmFyIHByZXYgPSB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYpXG5cdFx0XHRcdFx0XHRcdHRoaXMub2ZmKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmMpXG5cdFx0XHRcdFx0XHRcdHRoaXMub24odHlwZSwgZnVuYyk7XG5cdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gZnVuYztcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c3JjLl9ldmVudFR5cGVzID0gdHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaW5qZWN0LmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQYXBlclNjb3BlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXBlclNjb3BlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXBlclNjb3BlKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnNldHRpbmdzID0gbmV3IEJhc2Uoe1xuXHRcdFx0YXBwbHlNYXRyaXg6IHRydWUsXG5cdFx0XHRoYW5kbGVTaXplOiA0LFxuXHRcdFx0aGl0VG9sZXJhbmNlOiAwXG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLnByb2plY3RzID0gW107XG5cdFx0dGhpcy50b29scyA9IFtdO1xuXHRcdHRoaXMucGFsZXR0ZXMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cblx0fSxcblxuXHR2ZXJzaW9uOiAnMC45LjIxJyxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcblx0XHRWaWV3LnVwZGF0ZUZvY3VzKCk7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdGNvcyA9IE1hdGguY29zLFxuXHRcdFBJID0gTWF0aC5QSSxcblx0XHRUT0xFUkFOQ0UgPSAxMGUtNixcblx0XHRFUFNJTE9OID0gMTBlLTEyO1xuXG5cdGZ1bmN0aW9uIHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHVuYm91bmQgPSBtaW4gPT09IHVuZGVmaW5lZCxcblx0XHRcdG1pbkUgPSBtaW4gLSBFUFNJTE9OLFxuXHRcdFx0bWF4RSA9IG1heCArIEVQU0lMT04sXG5cdFx0XHRjb3VudCA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QpIHtcblx0XHRcdGlmICh1bmJvdW5kIHx8IHJvb3QgPiBtaW5FICYmIHJvb3QgPCBtYXhFKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IHJvb3QgPCBtaW4gPyBtaW4gOiByb290ID4gbWF4ID8gbWF4IDogcm9vdDtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRUT0xFUkFOQ0U6IFRPTEVSQU5DRSxcblx0XHRFUFNJTE9OOiBFUFNJTE9OLFxuXHRcdEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cblx0XHRpc1plcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIGFicyh2YWwpIDw9IEVQU0lMT047XG5cdFx0fSxcblxuXHRcdGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xuXHRcdFx0dmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuXHRcdFx0XHR3ID0gd2VpZ2h0c1tuIC0gMl0sXG5cdFx0XHRcdEEgPSAoYiAtIGEpICogMC41LFxuXHRcdFx0XHRCID0gQSArIGEsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRtID0gKG4gKyAxKSA+PiAxLFxuXHRcdFx0XHRzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwO1xuXHRcdFx0d2hpbGUgKGkgPCBtKSB7XG5cdFx0XHRcdHZhciBBeCA9IEEgKiB4W2ldO1xuXHRcdFx0XHRzdW0gKz0gd1tpKytdICogKGYoQiArIEF4KSArIGYoQiAtIEF4KSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQSAqIHN1bTtcblx0XHR9LFxuXG5cdFx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGYsIGRmLCB4LCBhLCBiLCBuLCB0b2xlcmFuY2UpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBmeCA9IGYoeCksXG5cdFx0XHRcdFx0ZHggPSBmeCAvIGRmKHgpLFxuXHRcdFx0XHRcdG54ID0geCAtIGR4O1xuXHRcdFx0XHRpZiAoYWJzKGR4KSA8IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRyZXR1cm4gbng7XG5cdFx0XHRcdGlmIChmeCA+IDApIHtcblx0XHRcdFx0XHRiID0geDtcblx0XHRcdFx0XHR4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0geDtcblx0XHRcdFx0XHR4ID0gbnggPj0gYiA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fSxcblxuXHRcdHNvbHZlUXVhZHJhdGljOiBmdW5jdGlvbihhLCBiLCBjLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBhZGQgPSBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCk7XG5cblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGlmIChhYnMoYikgPj0gRVBTSUxPTilcblx0XHRcdFx0XHRyZXR1cm4gYWRkKC1jIC8gYik7XG5cdFx0XHRcdHJldHVybiBhYnMoYykgPCBFUFNJTE9OID8gLTEgOiAwO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHAgPSBiIC8gKDIgKiBhKTtcblx0XHRcdHZhciBxID0gYyAvIGE7XG5cdFx0XHR2YXIgcDIgPSBwICogcDtcblx0XHRcdGlmIChwMiA8IHEgLSBFUFNJTE9OKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdHZhciBzID0gcDIgPiBxID8gc3FydChwMiAtIHEpIDogMCxcblx0XHRcdFx0Y291bnQgPSBhZGQocyAtIHApO1xuXHRcdFx0aWYgKHMgPiAwKVxuXHRcdFx0XHRjb3VudCA9IGFkZCgtcyAtIHApO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKVxuXHRcdFx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCk7XG5cblx0XHRcdGIgLz0gYTtcblx0XHRcdGMgLz0gYTtcblx0XHRcdGQgLz0gYTtcblx0XHRcdHZhciBhZGQgPSBzZXR1cFJvb3RzKHJvb3RzLCBtaW4sIG1heCksXG5cdFx0XHRcdGJiID0gYiAqIGIsXG5cdFx0XHRcdHAgPSAoYmIgLSAzICogYykgLyA5LFxuXHRcdFx0XHRxID0gKDIgKiBiYiAqIGIgLSA5ICogYiAqIGMgKyAyNyAqIGQpIC8gNTQsXG5cdFx0XHRcdHBwcCA9IHAgKiBwICogcCxcblx0XHRcdFx0RCA9IHEgKiBxIC0gcHBwO1xuXHRcdFx0YiAvPSAzO1xuXHRcdFx0aWYgKGFicyhEKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhxKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFkZCgtYik7XG5cdFx0XHRcdHZhciBzcXAgPSBzcXJ0KHApLFxuXHRcdFx0XHRcdHNucSA9IHEgPiAwID8gMSA6IC0xO1xuXHRcdFx0XHRhZGQoLXNucSAqIDIgKiBzcXAgLSBiKTtcblx0XHRcdFx0cmV0dXJuIGFkZChzbnEgKiBzcXAgLSBiKTtcblx0XHRcdH1cblx0XHRcdGlmIChEIDwgMCkge1xuXHRcdFx0XHR2YXIgc3FwID0gc3FydChwKSxcblx0XHRcdFx0XHRwaGkgPSBNYXRoLmFjb3MocSAvIChzcXAgKiBzcXAgKiBzcXApKSAvIDMsXG5cdFx0XHRcdFx0dCA9IC0yICogc3FwLFxuXHRcdFx0XHRcdG8gPSAyICogUEkgLyAzO1xuXHRcdFx0XHRhZGQodCAqIGNvcyhwaGkpIC0gYik7XG5cdFx0XHRcdGFkZCh0ICogY29zKHBoaSArIG8pIC0gYik7XG5cdFx0XHRcdHJldHVybiBhZGQodCAqIGNvcyhwaGkgLSBvKSAtIGIpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIEEgPSAocSA+IDAgPyAtMSA6IDEpICogcG93KGFicyhxKSArIHNxcnQoRCksIDEgLyAzKTtcblx0XHRcdHJldHVybiBhZGQoQSArIHAgLyBBIC0gYik7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBoYXNZID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzWSA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmFuZ2xlICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC5sZW5ndGg7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMuc2V0QW5nbGUoYXJnMC5hbmdsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50XG5cdFx0XHRcdCYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG5cdFx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShwb2ludClcblx0XHRcdFx0XHRcdCYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0dGhpcy54ICogc2NhbGUsXG5cdFx0XHRcdHRoaXMueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblx0Z2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXHR9LFxuXG5cdGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcblx0c2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuXG5cdGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9hbmdsZSB8fCAwXG5cdFx0XHRcdFx0OiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCAtIHRoaXMueCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy55LFxuXHRcdFx0ZCA9IHggKiB4ICsgeSAqIHksXG5cdFx0XHRzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0cyA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGMgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogYyAtIHBvaW50LnkgKiBzLFxuXHRcdFx0cG9pbnQueCAqIHMgKyBwb2ludC55ICogY1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2U6IGZ1bmN0aW9uKHBvaW50LCB0b2xlcmFuY2UpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPCB0b2xlcmFuY2U7XG5cdH0sXG5cblx0aXNDb2xpbmVhcjogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5jcm9zcyhwb2ludCkpIDwgMC4wMDAwMTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuZG90KHBvaW50KSkgPCAwLjAwMDAxO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocG9pbnQuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMud2lkdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gYXJnMTtcblx0XHRcdHRoaXMud2lkdGggPSBhcmcyO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBhcmczO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzBbMV07XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzJdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzBbM107XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54IHx8IDA7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueSB8fCAwO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aCB8fCAwO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0IHx8IDA7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFyZWFkKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRvLnggLSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHRvLnkgLSBwb2ludC55O1xuXHRcdFx0XHRpZiAodGhpcy53aWR0aCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnggPSB0by54O1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSAtdGhpcy53aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdG8ueTtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IC10aGlzLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2ZpeFgpXG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSBzaXplLndpZHRoKSAqIHRoaXMuX2ZpeFg7XG5cdFx0aWYgKHRoaXMuX2ZpeFkpXG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcblx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdHRoaXMuX2ZpeFcgPSAxO1xuXHRcdHRoaXMuX2ZpeEggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZml4Vylcblx0XHRcdHRoaXMud2lkdGggLT0gbGVmdCAtIHRoaXMueDtcblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX2ZpeFggPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZml4SClcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRvcCAtIHRoaXMueTtcblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fZml4WSA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICh0aGlzLl9maXhYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WCAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeFcgPSAwO1xuXHRcdGlmICh0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMueDtcblx0XHR0aGlzLl9maXhYID0gMTtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeEggPSAwO1xuXHRcdGlmICh0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0dGhpcy5fZml4WSA9IDE7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuXHRcdHRoaXMuX2ZpeFggPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0dGhpcy5fZml4WSA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0dG91Y2hlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID49IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHRoaXMuX3R4ICs9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fdHkgKz0geCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHRoaXMuX2EgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9jICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS55O1xuXHRcdHRoaXMuX2QgKj0gc2NhbGUueTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSksXG5cdFx0XHR4ID0gY2VudGVyLngsXG5cdFx0XHR5ID0gY2VudGVyLnksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR0eCA9IHggLSB4ICogY29zICsgeSAqIHNpbixcblx0XHRcdHR5ID0geSAtIHggKiBzaW4gLSB5ICogY29zLFxuXHRcdFx0YSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2Q7XG5cdFx0dGhpcy5fYSA9IGNvcyAqIGEgKyBzaW4gKiBiO1xuXHRcdHRoaXMuX2IgPSAtc2luICogYSArIGNvcyAqIGI7XG5cdFx0dGhpcy5fYyA9IGNvcyAqIGMgKyBzaW4gKiBkO1xuXHRcdHRoaXMuX2QgPSAtc2luICogYyArIGNvcyAqIGQ7XG5cdFx0dGhpcy5fdHggKz0gdHggKiBhICsgdHkgKiBiO1xuXHRcdHRoaXMuX3R5ICs9IHR4ICogYyArIHR5ICogZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2hlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaGVhciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGMgPSB0aGlzLl9jO1xuXHRcdHRoaXMuX2EgKz0gc2hlYXIueSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fYyArPSBzaGVhci55ICogdGhpcy5fZDtcblx0XHR0aGlzLl9iICs9IHNoZWFyLnggKiBhO1xuXHRcdHRoaXMuX2QgKz0gc2hlYXIueCAqIGM7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNrZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBza2V3ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHR0b1JhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0c2hlYXIgPSBuZXcgUG9pbnQoTWF0aC50YW4oc2tldy54ICogdG9SYWRpYW5zKSxcblx0XHRcdFx0TWF0aC50YW4oc2tldy55ICogdG9SYWRpYW5zKSk7XG5cdFx0cmV0dXJuIHRoaXMuc2hlYXIoc2hlYXIsIGNlbnRlcik7XG5cdH0sXG5cblx0Y29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBjMiAqIGIxO1xuXHRcdHRoaXMuX2IgPSBiMiAqIGExICsgZDIgKiBiMTtcblx0XHR0aGlzLl9jID0gYTIgKiBjMSArIGMyICogZDE7XG5cdFx0dGhpcy5fZCA9IGIyICogYzEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYjE7XG5cdFx0dGhpcy5fdHkgKz0gdHgyICogYzEgKyB0eTIgKiBkMTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cHJlQ29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0dHkxID0gdGhpcy5fdHksXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYjIgKiBjMTtcblx0XHR0aGlzLl9iID0gYTIgKiBiMSArIGIyICogZDE7XG5cdFx0dGhpcy5fYyA9IGMyICogYTEgKyBkMiAqIGMxO1xuXHRcdHRoaXMuX2QgPSBjMiAqIGIxICsgZDIgKiBkMTtcblx0XHR0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG5cdFx0dGhpcy5fdHkgPSBjMiAqIHR4MSArIGQyICogdHkxICsgdHkyO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjaGFpbjogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgoXG5cdFx0XHRcdGEyICogYTEgKyBjMiAqIGIxLFxuXHRcdFx0XHRhMiAqIGMxICsgYzIgKiBkMSxcblx0XHRcdFx0YjIgKiBhMSArIGQyICogYjEsXG5cdFx0XHRcdGIyICogYzEgKyBkMiAqIGQxLFxuXHRcdFx0XHR0eDEgKyB0eDIgKiBhMSArIHR5MiAqIGIxLFxuXHRcdFx0XHR0eTEgKyB0eDIgKiBjMSArIHR5MiAqIGQxKTtcblx0fSxcblxuXHRpc0lkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9jID09PSAwICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fZCA9PT0gMVxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gMCAmJiB0aGlzLl90eSA9PT0gMDtcblx0fSxcblxuXHRvck51bGxJZklkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCkgPyBudWxsIDogdGhpcztcblx0fSxcblxuXHRpc0ludmVydGlibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0aXNTaW5ndWxhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24oIHNyYywgZHN0LCBjb3VudCkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgM1xuXHRcdFx0PyB0aGlzLl90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHNyYywgZHN0LCBjb3VudCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0eCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4LFxuXHRcdFx0eCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24oc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRtYXggPSAyICogY291bnQ7XG5cdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdHZhciB4ID0gc3JjW2krK10sXG5cdFx0XHRcdHkgPSBzcmNbaSsrXTtcblx0XHRcdGRzdFtqKytdID0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4O1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gY29vcmRzLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pXG5cdFx0XHRcdG1pbltqXSA9IHZhbDtcblx0XHRcdGVsc2UgaWYgKHZhbCA+IG1heFtqXSlcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0LnNldChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0sXG5cdFx0XHRcdF9kb250Tm90aWZ5KTtcblx0fSxcblxuXHRpbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9nZXREZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYiAqIHRoaXMuX2M7XG5cdFx0cmV0dXJuIGlzRmluaXRlKGRldCkgJiYgIU51bWVyaWNhbC5pc1plcm8oZGV0KVxuXHRcdFx0XHQmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpXG5cdFx0XHRcdD8gZGV0IDogbnVsbDtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG5cdFx0aWYgKCFkZXQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLl90eCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy5fdHk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0LnNldChcblx0XHRcdCh4ICogdGhpcy5fZCAtIHkgKiB0aGlzLl9iKSAvIGRldCxcblx0XHRcdCh5ICogdGhpcy5fYSAtIHggKiB0aGlzLl9jKSAvIGRldCxcblx0XHRcdF9kb250Tm90aWZ5XG5cdFx0KTtcblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSwgYiA9IHRoaXMuX2IsIGMgPSB0aGlzLl9jLCBkID0gdGhpcy5fZDtcblx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhhICogZCAtIGIgKiBjKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRhIC89IHNjYWxlWDtcblx0XHRiIC89IHNjYWxlWDtcblxuXHRcdHZhciBzaGVhciA9IGEgKiBjICsgYiAqIGQ7XG5cdFx0YyAtPSBhICogc2hlYXI7XG5cdFx0ZCAtPSBiICogc2hlYXI7XG5cblx0XHR2YXIgc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuXHRcdGMgLz0gc2NhbGVZO1xuXHRcdGQgLz0gc2NhbGVZO1xuXHRcdHNoZWFyIC89IHNjYWxlWTtcblxuXHRcdGlmIChhICogZCA8IGIgKiBjKSB7XG5cdFx0XHRhID0gLWE7XG5cdFx0XHRiID0gLWI7XG5cdFx0XHRzaGVhciA9IC1zaGVhcjtcblx0XHRcdHNjYWxlWCA9IC1zY2FsZVg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNjYWxpbmc6IG5ldyBQb2ludChzY2FsZVgsIHNjYWxlWSksXG5cdFx0XHRyb3RhdGlvbjogLU1hdGguYXRhbjIoYiwgYSkgKiAxODAgLyBNYXRoLlBJLFxuXHRcdFx0c2hlYXJpbmc6IHNoZWFyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5zY2FsaW5nO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnJvdGF0aW9uO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRyZXR1cm4gZGV0ICYmIG5ldyBNYXRyaXgoXG5cdFx0XHRcdHRoaXMuX2QgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9jIC8gZGV0LFxuXHRcdFx0XHQtdGhpcy5fYiAvIGRldCxcblx0XHRcdFx0dGhpcy5fYSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2IgKiB0aGlzLl90eSAtIHRoaXMuX2QgKiB0aGlzLl90eCkgLyBkZXQsXG5cdFx0XHRcdCh0aGlzLl9jICogdGhpcy5fdHggLSB0aGlzLl9hICogdGhpcy5fdHkpIC8gZGV0KTtcblx0fSxcblxuXHRzaGlmdGxlc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIDAsIDApO1xuXHR9LFxuXG5cdGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2EnLCAnYycsICdiJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRwcm9wID0gJ18nICsgbmFtZTtcblx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF07XG5cdH07XG5cdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdMaW5lJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcblx0XHR2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzE7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzI7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzM7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMC54O1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcwLnk7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzEueDtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMS55O1xuXHRcdFx0YXNWZWN0b3IgPSBhcmcyO1xuXHRcdH1cblx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHR0aGlzLl92eCAtPSB0aGlzLl9weDtcblx0XHRcdHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuXHR9LFxuXG5cdGdldFZlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0bGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksXG5cdFx0XHRcdHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldFNpZGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lkZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyhMaW5lLmdldFNpZ25lZERpc3RhbmNlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSkpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGFweCwgYXB5LCBhdngsIGF2eSwgYnB4LCBicHksIGJ2eCwgYnZ5LCBhc1ZlY3Rvcixcblx0XHRcdFx0aXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHRhdnggLT0gYXB4O1xuXHRcdFx0XHRhdnkgLT0gYXB5O1xuXHRcdFx0XHRidnggLT0gYnB4O1xuXHRcdFx0XHRidnkgLT0gYnB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNyb3NzID0gYXZ4ICogYnZ5IC0gYXZ5ICogYnZ4O1xuXHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKGNyb3NzKSkge1xuXHRcdFx0XHR2YXIgZHggPSBhcHggLSBicHgsXG5cdFx0XHRcdFx0ZHkgPSBhcHkgLSBicHksXG5cdFx0XHRcdFx0dGEgPSAoYnZ4ICogZHkgLSBidnkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHR0YiA9IChhdnggKiBkeSAtIGF2eSAqIGR4KSAvIGNyb3NzO1xuXHRcdFx0XHRpZiAoaXNJbmZpbml0ZSB8fCAwIDw9IHRhICYmIHRhIDw9IDEgJiYgMCA8PSB0YiAmJiB0YiA8PSAxKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0YXB4ICsgdGEgKiBhdngsXG5cdFx0XHRcdFx0XHRcdFx0YXB5ICsgdGEgKiBhdnkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTaWRlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHYyeCA9IHggLSBweCxcblx0XHRcdFx0djJ5ID0geSAtIHB5LFxuXHRcdFx0XHRjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4O1xuXHRcdFx0aWYgKGNjdyA9PT0gMCkge1xuXHRcdFx0XHRjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5O1xuXHRcdFx0XHRpZiAoY2N3ID4gMCkge1xuXHRcdFx0XHRcdHYyeCAtPSB2eDtcblx0XHRcdFx0XHR2MnkgLT0gdnk7XG5cdFx0XHRcdFx0Y2N3ID0gdjJ4ICogdnggKyB2MnkgKiB2eTtcblx0XHRcdFx0XHRpZiAoY2N3IDwgMClcblx0XHRcdFx0XHRcdGNjdyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG5cdFx0fSxcblxuXHRcdGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8odngpKVxuXHRcdFx0XHRyZXR1cm4geCAtIHB4O1xuXHRcdFx0dmFyIG0gPSB2eSAvIHZ4LFxuXHRcdFx0XHRiID0gcHkgLSBtICogcHg7XG5cdFx0XHRyZXR1cm4gKHkgLSAobSAqIHgpIC0gYikgLyBNYXRoLnNxcnQobSAqIG0gKyAxKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgUHJvamVjdCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Byb2plY3QnLFxuXHRfbGlzdDogJ3Byb2plY3RzJyxcblx0X3JlZmVyZW5jZTogJ3Byb2plY3QnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFByb2plY3QoZWxlbWVudCkge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5sYXllcnMgPSBbXTtcblx0XHR0aGlzLl9hY3RpdmVMYXllciA9IG51bGw7XG5cdFx0dGhpcy5zeW1ib2xzID0gW107XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlID0gbmV3IFN0eWxlKG51bGwsIG51bGwsIHRoaXMpO1xuXHRcdHRoaXMuX3ZpZXcgPSBWaWV3LmNyZWF0ZSh0aGlzLFxuXHRcdFx0XHRlbGVtZW50IHx8IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcygxLCAxKSk7XG5cdFx0dGhpcy5fc2VsZWN0ZWRJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gMDtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMubGF5ZXJzLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5sYXllcnNbaV0ucmVtb3ZlKCk7XG5cdFx0dGhpcy5zeW1ib2xzID0gW107XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRpZiAoIXJlbW92ZS5iYXNlLmNhbGwodGhpcykpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3ZpZXcpXG5cdFx0XHR0aGlzLl92aWV3LnJlbW92ZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9LFxuXG5cdGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTdHlsZTtcblx0fSxcblxuXHRzZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlLmluaXRpYWxpemUoc3R5bGUpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0Z2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLnNldHRpbmdzO1xuXHR9LFxuXG5cdGdldEFjdGl2ZUxheWVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKHsgcHJvamVjdDogdGhpcyB9KTtcblx0fSxcblxuXHRnZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9zZWxlY3RlZEl0ZW1zKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX3NlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdFx0aWYgKGl0ZW0uaXNJbnNlcnRlZCgpKVxuXHRcdFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgTGF5ZXIpIHtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbY2hpbGRdKTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gY2hpbGQ7XG5cdFx0fSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIEl0ZW0pIHtcblx0XHRcdCh0aGlzLl9hY3RpdmVMYXllclxuXHRcdFx0XHR8fCB0aGlzLmFkZENoaWxkKG5ldyBMYXllcihJdGVtLk5PX0lOU0VSVCkpKS5hZGRDaGlsZChjaGlsZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGlmIChpdGVtLl9zZWxlY3RlZCkge1xuXHRcdFx0aWYgKHNlbGVjdGVkSXRlbXNbaWRdICE9PSBpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50Kys7XG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNbaWRdID0gaXRlbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGVkSXRlbXNbaWRdID09PSBpdGVtKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudC0tO1xuXHRcdFx0ZGVsZXRlIHNlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsYXllcnNbaV0uc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRkZXNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGZvciAodmFyIGkgaW4gc2VsZWN0ZWRJdGVtcylcblx0XHRcdHNlbGVjdGVkSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciByZXMgPSB0aGlzLmxheWVyc1tpXS5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAocmVzKSByZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLmxheWVycywgbWF0Y2gsIG51bGwsIG51bGwsIHRydWUpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9hY3RpdmVMYXllcjtcblx0XHRyZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uKys7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgcGFyYW0gPSBuZXcgQmFzZSh7XG5cdFx0XHRvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcblx0XHRcdHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG5cdFx0XHR2aWV3TWF0cml4OiBtYXRyaXguaXNJZGVudGl0eSgpID8gbnVsbCA6IG1hdHJpeCxcblx0XHRcdG1hdHJpY2VzOiBbbmV3IE1hdHJpeCgpXSxcblx0XHRcdHVwZGF0ZU1hdHJpeDogdHJ1ZVxuXHRcdH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsYXllcnMgPSB0aGlzLmxheWVycywgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsYXllcnNbaV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID4gMCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zdHJva2VXaWR0aCA9IDE7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zLFxuXHRcdFx0XHRzaXplID0gdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGFuZGxlU2l6ZSxcblx0XHRcdFx0dmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb247XG5cdFx0XHRmb3IgKHZhciBpZCBpbiBpdGVtcylcblx0XHRcdFx0aXRlbXNbaWRdLl9kcmF3U2VsZWN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBpdGVtcywgdmVyc2lvbik7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTeW1ib2wgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sKGl0ZW0sIGRvbnRDZW50ZXIpIHtcblx0XHR0aGlzLl9pZCA9IFN5bWJvbC5faWQgPSAoU3ltYm9sLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHR0aGlzLnByb2plY3Quc3ltYm9scy5wdXNoKHRoaXMpO1xuXHRcdGlmIChpdGVtKVxuXHRcdFx0dGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9kZWZpbml0aW9uXSxcblx0XHRcdFx0XHRvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudFN5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2RlZmluaXRpb24pXG5cdFx0XHR0aGlzLl9kZWZpbml0aW9uLl9wYXJlbnRTeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3BhcmVudFN5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFBsYWNlZFN5bWJvbCh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcblx0fVxufSk7XG5cbnZhciBJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRzdGF0aWNzOiB7XG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc3JjKSB7XG5cdFx0XHRpZiAoc3JjLl9zZXJpYWxpemVGaWVsZHMpXG5cdFx0XHRcdHNyYy5fc2VyaWFsaXplRmllbGRzID0gbmV3IEJhc2UoXG5cdFx0XHRcdFx0XHR0aGlzLnByb3RvdHlwZS5fc2VyaWFsaXplRmllbGRzLCBzcmMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Tk9fSU5TRVJUOiB7IGluc2VydDogZmFsc2UgfVxuXHR9LFxuXG5cdF9jbGFzczogJ0l0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcblx0X2JvdW5kc1NlbGVjdGVkOiBmYWxzZSxcblx0X3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdG5hbWU6IG51bGwsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0bWF0cml4OiBuZXcgTWF0cml4KCksXG5cdFx0cGl2b3Q6IG51bGwsXG5cdFx0bG9ja2VkOiBmYWxzZSxcblx0XHR2aXNpYmxlOiB0cnVlLFxuXHRcdGJsZW5kTW9kZTogJ25vcm1hbCcsXG5cdFx0b3BhY2l0eTogMSxcblx0XHRndWlkZTogZmFsc2UsXG5cdFx0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdGNsaXBNYXNrOiBmYWxzZSxcblx0XHRkYXRhOiB7fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7XG5cdH0sXG5cblx0X2luaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzLCBwb2ludCkge1xuXHRcdHZhciBoYXNQcm9wcyA9IHByb3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcyksXG5cdFx0XHRpbnRlcm5hbCA9IGhhc1Byb3BzICYmIHByb3BzLmludGVybmFsID09PSB0cnVlLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0cHJvamVjdCA9IGhhc1Byb3BzICYmIHByb3BzLnByb2plY3QgfHwgcGFwZXIucHJvamVjdDtcblx0XHRpZiAoIWludGVybmFsKVxuXHRcdFx0dGhpcy5faWQgPSBJdGVtLl9pZCA9IChJdGVtLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmICghdGhpcy5fcHJvamVjdCkge1xuXHRcdFx0aWYgKGludGVybmFsIHx8IGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoaGFzUHJvcHMgJiYgcHJvcHMucGFyZW50KSB7XG5cdFx0XHRcdHRoaXMuc2V0UGFyZW50KHByb3BzLnBhcmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQocHJvamVjdC5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKCkpLmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaGFzUHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSwgcGFyZW50OiB0cnVlIH0sIHRydWUpO1xuXHRcdHJldHVybiBoYXNQcm9wcztcblx0fSxcblxuXHRfZXZlbnRzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbW91c2VGbGFncyA9IHtcblx0XHRcdG1vdXNlZG93bjoge1xuXHRcdFx0XHRtb3VzZWRvd246IDEsXG5cdFx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0XHR9LFxuXHRcdFx0bW91c2V1cDoge1xuXHRcdFx0XHRtb3VzZXVwOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNlbW92ZToge1xuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdFx0bW91c2VlbnRlcjogMSxcblx0XHRcdFx0bW91c2VsZWF2ZTogMVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgbW91c2VFdmVudCA9IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5nZXRWaWV3KCkuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKSB7XG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldID0gKGNvdW50ZXJzW2tleV0gfHwgMClcblx0XHRcdFx0XHRcdFx0XHQrIChtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncylcblx0XHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gLT0gbW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIEJhc2UuZWFjaChbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXSxcblx0XHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IG1vdXNlRXZlbnQ7XG5cdFx0XHR9LCB7XG5cdFx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25Mb2FkOiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihhbmltYXRlKSB7XG5cdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGFuaW1hdGUpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9wYXJlbnRTeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPVxuXHRcdFx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY2FjaGVQYXJlbnRcblx0XHRcdFx0JiYgKGZsYWdzICYgNDApKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMikge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb2plY3QuX2NoYW5nZXMpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gcHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdO1xuXHRcdFx0XHRpZiAoZW50cnkpIHtcblx0XHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbnRyeSA9IHsgaXRlbTogdGhpcywgZmxhZ3M6IGZsYWdzIH07XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdID0gZW50cnk7XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlcy5wdXNoKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3ltYm9sKVxuXHRcdFx0c3ltYm9sLl9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKHByb3BzKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9LFxuXG5cdGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsYXNzO1xuXHR9LFxuXG5cdGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9LFxuXG5cdHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUsIHVuaXF1ZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKG5hbWUgJiYgcGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRvcmlnID0gbmFtZSxcblx0XHRcdFx0aSA9IDE7XG5cdFx0XHR3aGlsZSAodW5pcXVlICYmIGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgxMjgpO1xuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3R5bGU7XG5cdH0sXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0fTtcblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXNbbmFtZV0pIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKG5hbWUgPT09ICdfbG9ja2VkJ1xuXHRcdFx0XHRcdFx0PyAxMjggOiAxMjkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG57fSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2xvY2tlZDogZmFsc2UsXG5cblx0X3Zpc2libGU6IHRydWUsXG5cblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cblx0X29wYWNpdHk6IDEsXG5cblx0X2d1aWRlOiBmYWxzZSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG5vQ2hpbGRyZW4pIHtcblx0XHRpZiAoIW5vQ2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0aWYgKChzZWxlY3RlZCA9ICEhc2VsZWN0ZWQpIF4gdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll91cGRhdGVTZWxlY3Rpb24odGhpcyk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWxlY3RlZDogZmFsc2UsXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoIWNoaWxkcmVuW2ldLmlzRnVsbHlTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdHJ1ZSk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgxMDI0KTtcblx0XHR9XG5cdH0sXG5cblx0X2NsaXBNYXNrOiBmYWxzZSxcblxuXHRnZXREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2RhdGEpXG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH0sXG5cblx0c2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHR9LFxuXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbixcblx0XHRcdGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdGlmICghcG9zaXRpb24pIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiA9IHBpdm90XG5cdFx0XHRcdFx0PyB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgY3Rvcihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB0aGlzLCAnc2V0UG9zaXRpb24nKTtcblx0fSxcblxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLnN1YnRyYWN0KHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fSxcblxuXHRnZXRQaXZvdDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0aWYgKHBpdm90KSB7XG5cdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRwaXZvdCA9IG5ldyBjdG9yKHBpdm90LngsIHBpdm90LnksIHRoaXMsICdzZXRQaXZvdCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl2b3Q7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9waXZvdDogbnVsbCxcblxuXHRnZXRSZWdpc3RyYXRpb246ICcjZ2V0UGl2b3QnLFxuXHRzZXRSZWdpc3RyYXRpb246ICcjc2V0UGl2b3QnXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgeDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkLl92aXNpYmxlICYmICFjaGlsZC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBjaGlsZC5fZ2V0Q2FjaGVkQm91bmRzKGdldHRlcixcblx0XHRcdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdHgyID0gTWF0aC5tYXgocmVjdC54ICsgcmVjdC53aWR0aCwgeDIpO1xuXHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0PyBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSlcblx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCk7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0aWYgKHJlY3Qud2lkdGggIT0gYm91bmRzLndpZHRoIHx8IHJlY3QuaGVpZ2h0ICE9IGJvdW5kcy5oZWlnaHQpIHtcblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAxLFxuXHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQgIT0gMCA/IHJlY3QuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCA6IDEpO1xuXHRcdH1cblx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZSgtY2VudGVyLngsIC1jZW50ZXIueSk7XG5cdFx0dGhpcy50cmFuc2Zvcm0obWF0cml4KTtcblx0fSxcblxuXHRfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtLCBpbnRlcm5hbEdldHRlcikge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHZhciBfbWF0cml4ID0gaW50ZXJuYWxHZXR0ZXIgPyBudWxsIDogdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdGNhY2hlID0gKCFtYXRyaXggfHwgbWF0cml4LmVxdWFscyhfbWF0cml4KSkgJiYgZ2V0dGVyO1xuXHRcdHZhciBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnRTeW1ib2w7XG5cdFx0aWYgKGNhY2hlUGFyZW50KSB7XG5cdFx0XHR2YXIgaWQgPSBjYWNoZUl0ZW0uX2lkLFxuXHRcdFx0XHRyZWYgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdGlkczoge30sXG5cdFx0XHRcdFx0bGlzdDogW11cblx0XHRcdFx0fTtcblx0XHRcdGlmICghcmVmLmlkc1tpZF0pIHtcblx0XHRcdFx0cmVmLmxpc3QucHVzaChjYWNoZUl0ZW0pO1xuXHRcdFx0XHRyZWYuaWRzW2lkXSA9IGNhY2hlSXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhY2hlICYmIHRoaXMuX2JvdW5kcyAmJiB0aGlzLl9ib3VuZHNbY2FjaGVdKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2JvdW5kc1tjYWNoZV0uY2xvbmUoKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzKGludGVybmFsR2V0dGVyIHx8IGdldHRlcixcblx0XHRcdFx0bWF0cml4IHx8IF9tYXRyaXgsIGNhY2hlSXRlbSk7XG5cdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgY2FjaGVkID0gdGhpcy5fYm91bmRzW2NhY2hlXSA9IGJvdW5kcy5jbG9uZSgpO1xuXHRcdFx0Y2FjaGVkLl9pbnRlcm5hbCA9ICEhaW50ZXJuYWxHZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBvdGhlciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKG90aGVyICE9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHRvdGhlci5fYm91bmRzID0gb3RoZXIuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyLl9ib3VuZHNDYWNoZSlcblx0XHRcdFx0XHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShvdGhlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCk7XG5cdFx0cmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5yb3RhdGlvbjtcblx0fSxcblxuXHRzZXRSb3RhdGlvbjogZnVuY3Rpb24ocm90YXRpb24pIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblx0XHRpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cdFx0XHRkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpLFxuXHRcdFx0c2NhbGluZyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nLFxuXHRcdFx0Y3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIHNjYWxpbmcgJiYgbmV3IGN0b3Ioc2NhbGluZy54LCBzY2FsaW5nLnksIHRoaXMsICdzZXRTY2FsaW5nJyk7XG5cdH0sXG5cblx0c2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKTtcblx0XHRpZiAoY3VycmVudCkge1xuXHRcdFx0dmFyIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSB9KSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHRcdGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmluaXRpYWxpemUobWF0cml4KTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguX3VwZGF0ZVZlcnNpb24gIT09IHVwZGF0ZVZlcnNpb24pXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdGlmICghbWF0cml4KSB7XG5cdFx0XHRtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG5cdH0sXG5cblx0c2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuXHRcdGlmICh0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmICEhdHJhbnNmb3JtKVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uIF9pbnN0YWxsRXZlbnRzKGluc3RhbGwpIHtcblx0XHRfaW5zdGFsbEV2ZW50cy5iYXNlLmNhbGwodGhpcywgaW5zdGFsbCk7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5faW5zdGFsbEV2ZW50cyhpbnN0YWxsKTtcblx0fSxcblxuXHRnZXRMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgTGF5ZXIpXG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudDtcblx0fSxcblxuXHRzZXRQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRnZXRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuXHR9LFxuXG5cdHNldENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcykge1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHR0aGlzLmFkZENoaWxkcmVuKGl0ZW1zKTtcblx0fSxcblxuXHRnZXRGaXJzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bMF0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRMYXN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblt0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxXVxuXHRcdFx0XHR8fCBudWxsO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fY2hpbGRyZW5bdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID09PSB0aGlzIHx8IGl0ZW0gJiYgdGhpcy5fY2xhc3MgPT09IGl0ZW0uX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSlcblx0XHRcdFx0JiYgdGhpcy5fbWF0cml4LmVxdWFscyhpdGVtLl9tYXRyaXgpXG5cdFx0XHRcdCYmIHRoaXMuX2xvY2tlZCA9PT0gaXRlbS5fbG9ja2VkXG5cdFx0XHRcdCYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGVcblx0XHRcdFx0JiYgdGhpcy5fYmxlbmRNb2RlID09PSBpdGVtLl9ibGVuZE1vZGVcblx0XHRcdFx0JiYgdGhpcy5fb3BhY2l0eSA9PT0gaXRlbS5fb3BhY2l0eVxuXHRcdFx0XHQmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2tcblx0XHRcdFx0JiYgdGhpcy5fZ3VpZGUgPT09IGl0ZW0uX2d1aWRlXG5cdFx0XHRcdCYmIHRoaXMuX2VxdWFscyhpdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX2NoaWxkcmVuLCBpdGVtLl9jaGlsZHJlbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbihjb3B5LCBpbnNlcnQpIHtcblx0XHRjb3B5LnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb3B5LmFkZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Lmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLFxuXHRcdFx0XHQnX2NsaXBNYXNrJywgJ19ndWlkZScsICdfYXBwbHlNYXRyaXgnXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdGNvcHlba2V5XSA9IHRoaXNba2V5XTtcblx0XHR9XG5cdFx0Y29weS5fbWF0cml4LmluaXRpYWxpemUodGhpcy5fbWF0cml4KTtcblx0XHRjb3B5Ll9kYXRhID0gdGhpcy5fZGF0YSA/IEJhc2UuY2xvbmUodGhpcy5fZGF0YSkgOiBudWxsO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0Y29weS5zZXROYW1lKHRoaXMuX25hbWUsIHRydWUpO1xuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24oaXRlbU9yUHJvamVjdCkge1xuXHRcdHJldHVybiBpdGVtT3JQcm9qZWN0LmFkZENoaWxkKHRoaXMuY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRyYXN0ZXJpemU6IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcblx0XHRcdHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuXHRcdFx0dG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcblx0XHRcdGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2NvbnRhaW5zKFxuXHRcdFx0XHR0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRyZWN0YW5nbGU6IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSxcblx0XHRcdG1hdHJpeDogdGhpcy5fbWF0cml4LFxuXHRcdFx0aW5zZXJ0OiBmYWxzZSxcblx0XHR9KTtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbihpdGVtLCBfbWF0cml4KSB7XG5cdFx0aWYgKCEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksXG5cdFx0XHRcdF9tYXRyaXggfHwgaXRlbS5fbWF0cml4KS5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oaXRUZXN0KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKHRoaXMuX2xvY2tlZCB8fCAhdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9ndWlkZSAmJiAhb3B0aW9ucy5ndWlkZXNcblx0XHRcdFx0fHwgdGhpcy5pc0VtcHR5KCkpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRwYXJlbnRUb3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4LFxuXHRcdFx0dmlldyA9IHRoaXMuZ2V0VmlldygpLFxuXHRcdFx0dG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4XG5cdFx0XHRcdFx0PyBwYXJlbnRUb3RhbE1hdHJpeC5jaGFpbihtYXRyaXgpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZUNvbmNhdGVuYXRlKHZpZXcuX21hdHJpeCksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZygxLCB0b3RhbE1hdHJpeC5pbnZlcnRlZCgpKVxuXHRcdFx0XHRcdCkubXVsdGlwbHkoXG5cdFx0XHRcdFx0XHRNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMC4wMDAwMSlcblx0XHRcdFx0XHQpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0SW50ZXJuYWxSb3VnaEJvdW5kcygpXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNoZWNrU2VsZiA9ICEob3B0aW9ucy5ndWlkZXMgJiYgIXRoaXMuX2d1aWRlXG5cdFx0XHRcdHx8IG9wdGlvbnMuc2VsZWN0ZWQgJiYgIXRoaXMuX3NlbGVjdGVkXG5cdFx0XHRcdHx8IG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgIT09IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHR8fCBvcHRpb25zLmNsYXNzICYmICEodGhpcyBpbnN0YW5jZW9mIG9wdGlvbnMuY2xhc3MpKSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gY2hlY2tCb3VuZHModHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gYm91bmRzWydnZXQnICsgcGFydF0oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LFxuXHRcdFx0XHRcdFx0eyBuYW1lOiBCYXNlLmh5cGhlbmF0ZShwYXJ0KSwgcG9pbnQ6IHB0IH0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHRpZiAob3B0aW9ucy5jZW50ZXIpXG5cdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBvcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspXG5cdFx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkcmVuID0gIXJlcyAmJiB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5fZ2V0Q2hpbGRIaXRUZXN0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDAgJiYgIXJlczsgaS0tKVxuXHRcdFx0XHRyZXMgPSBjaGlsZHJlbltpXS5faGl0VGVzdChwb2ludCwgb3B0cyk7XG5cdFx0fVxuXHRcdGlmICghcmVzICYmIGNoZWNrU2VsZilcblx0XHRcdHJlcyA9IHRoaXMuX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzICYmIHJlcy5wb2ludClcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHRvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4O1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpIHtcblx0XHRcdFx0aWYgKG5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGhpcy5tYXRjaGVzKGtleSwgbmFtZVtrZXldKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB2YWx1ZSA9IC9eKGVtcHR5fGVkaXRhYmxlKSQvLnRlc3QobmFtZSlcblx0XHRcdFx0XHQ/IHRoaXNbJ2lzJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0oKVxuXHRcdFx0XHRcdDogbmFtZSA9PT0gJ3R5cGUnXG5cdFx0XHRcdFx0XHQ/IEJhc2UuaHlwaGVuYXRlKHRoaXMuX2NsYXNzKVxuXHRcdFx0XHRcdFx0OiB0aGlzW25hbWVdO1xuXHRcdFx0aWYgKC9eKGNvbnN0cnVjdG9yfGNsYXNzKSQvLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIGNvbXBhcmUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUudGVzdCh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRpZiAoIWNvbXBhcmUodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdGlmICghbWF0Y2hPYmplY3QoY29tcGFyZSwgdmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpXG5cdFx0XHRcdFswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfZ2V0SXRlbXM6IGZ1bmN0aW9uIF9nZXRJdGVtcyhjaGlsZHJlbiwgbWF0Y2gsIG1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSkge1xuXHRcdFx0XHR2YXIgb3ZlcmxhcHBpbmcgPSBtYXRjaC5vdmVybGFwcGluZyxcblx0XHRcdFx0XHRpbnNpZGUgPSBtYXRjaC5pbnNpZGUsXG5cdFx0XHRcdFx0Ym91bmRzID0gb3ZlcmxhcHBpbmcgfHwgaW5zaWRlLFxuXHRcdFx0XHRcdHJlY3QgPVx0Ym91bmRzICYmIFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdKTtcblx0XHRcdFx0cGFyYW0gPSB7XG5cdFx0XHRcdFx0aXRlbXM6IFtdLFxuXHRcdFx0XHRcdGluc2lkZTogcmVjdCxcblx0XHRcdFx0XHRvdmVybGFwcGluZzogb3ZlcmxhcHBpbmcgJiYgbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdFx0XHRcdHJlY3RhbmdsZTogcmVjdCxcblx0XHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoYm91bmRzKVxuXHRcdFx0XHRcdG1hdGNoID0gQmFzZS5zZXQoe30sIG1hdGNoLFxuXHRcdFx0XHRcdFx0XHR7IGluc2lkZTogdHJ1ZSwgb3ZlcmxhcHBpbmc6IHRydWUgfSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaXRlbXMgPSBwYXJhbS5pdGVtcyxcblx0XHRcdFx0aW5zaWRlID0gcGFyYW0uaW5zaWRlLFxuXHRcdFx0XHRvdmVybGFwcGluZyA9IHBhcmFtLm92ZXJsYXBwaW5nO1xuXHRcdFx0bWF0cml4ID0gaW5zaWRlICYmIChtYXRyaXggfHwgbmV3IE1hdHJpeCgpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRcdGNoaWxkTWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSxcblx0XHRcdFx0XHRhZGQgPSB0cnVlO1xuXHRcdFx0XHRpZiAoaW5zaWRlKSB7XG5cdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGNoaWxkLmdldEJvdW5kcyhjaGlsZE1hdHJpeCk7XG5cdFx0XHRcdFx0aWYgKCFpbnNpZGUuaW50ZXJzZWN0cyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKCEoaW5zaWRlICYmIGluc2lkZS5jb250YWlucyhib3VuZHMpKSAmJiAhKG92ZXJsYXBwaW5nXG5cdFx0XHRcdFx0XHRcdCYmIG92ZXJsYXBwaW5nLmludGVyc2VjdHMoY2hpbGQsIGNoaWxkTWF0cml4KSkpXG5cdFx0XHRcdFx0XHRhZGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWRkICYmIGNoaWxkLm1hdGNoZXMobWF0Y2gpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0aWYgKGZpcnN0T25seSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9nZXRJdGVtcyhjaGlsZC5fY2hpbGRyZW4sIG1hdGNoLFxuXHRcdFx0XHRcdFx0Y2hpbGRNYXRyaXgsIHBhcmFtLFxuXHRcdFx0XHRcdFx0Zmlyc3RPbmx5KTtcblx0XHRcdFx0aWYgKGZpcnN0T25seSAmJiBpdGVtcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufSwge1xuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR2YXIgcmVzID0gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuXHRcdHJldHVybiByZXMgIT09IHRoaXNcblx0XHRcdFx0PyB0aGlzLmFkZENoaWxkKHJlcylcblx0XHRcdFx0OiByZXM7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHZhciByZXMgPSB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0sIF9wcmVzZXJ2ZSk7XG5cdFx0cmV0dXJuIHJlcyAmJiByZXNbMF07XG5cdH0sXG5cblx0YWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgX3Byb3RvKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGl0ZW1zKTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpZiAoX3Byb3RvICYmICEoaXRlbSBpbnN0YW5jZW9mIF9wcm90bykpIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMuX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbS5fbmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUoaXRlbS5fbmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydDogZnVuY3Rpb24oYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdGlmICghaXRlbS5fcGFyZW50KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5faW5kZXggKyAoYWJvdmUgPyAxIDogMCk7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudCA9PT0gdGhpcy5fcGFyZW50ICYmIGluZGV4ID4gdGhpcy5faW5kZXgpXG5cdFx0XHRpbmRleC0tO1xuXHRcdHJldHVybiBpdGVtLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoaW5kZXgsIHRoaXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QWJvdmU6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnQodHJ1ZSwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRCZWxvdzogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luc2VydChmYWxzZSwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudC5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuXHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0XHRpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG5cdFx0XHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbClcblx0XHRcdFx0QmFzZS5zcGxpY2UocGFyZW50Ll9jaGlsZHJlbiwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZikge1xuXHRcdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRcdGlmIChwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdGlmIChub3RpZnlQYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY2hhbmdlZCgxMSk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09IGl0ZW0pXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnJvdGF0ZShhbmdsZSxcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtuYW1lXShwb2ludCxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fTtcbn0sIHtcblxufSksIHtcblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgsIF9hcHBseU1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG5cdFx0XHRcdCYmICghX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgbWF0cml4KTtcblx0XHRpZiAoIW1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0X21hdHJpeC5wcmVDb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdGlmIChhcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4ICYmIHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCkpIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90LFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG5cdFx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdF9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90LCBwaXZvdCwgdHJ1ZSk7XG5cdFx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0XHRmaWxsQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRfbWF0cml4LnJlc2V0KHRydWUpO1xuXHRcdH1cblx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzLFxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdHZhciBkZWNvbXAgPSBib3VuZHMgJiYgbWF0cml4ICYmIG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRpZiAoZGVjb21wICYmICFkZWNvbXAuc2hlYXJpbmcgJiYgZGVjb21wLnJvdGF0aW9uICUgOTAgPT09IDApIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBib3VuZHMpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGFwcGx5TWF0cml4IHx8ICFyZWN0Ll9pbnRlcm5hbClcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0LCByZWN0KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdHJlY3QgPSBib3VuZHNbZ2V0dGVyICYmIGdldHRlci5nZXRCb3VuZHMgfHwgZ2V0dGVyIHx8ICdnZXRCb3VuZHMnXTtcblx0XHRcdGlmIChyZWN0KVxuXHRcdFx0XHR0aGlzLl9wb3NpdGlvbiA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzO1xuXHRcdH0gZWxzZSBpZiAobWF0cml4ICYmIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9wb3NpdGlvbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9zaXRpb24sIHBvc2l0aW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5faW52ZXJzZVRyYW5zZm9ybShcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX3RyYW5zZm9ybVBvaW50KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHBhcmVudFRvTG9jYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvUGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGZpdEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlLCBmaWxsKSB7XG5cdFx0cmVjdGFuZ2xlID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdGl0ZW1SYXRpbyA9IGJvdW5kcy5oZWlnaHQgLyBib3VuZHMud2lkdGgsXG5cdFx0XHRyZWN0UmF0aW8gPSByZWN0YW5nbGUuaGVpZ2h0IC8gcmVjdGFuZ2xlLndpZHRoLFxuXHRcdFx0c2NhbGUgPSAoZmlsbCA/IGl0ZW1SYXRpbyA+IHJlY3RSYXRpbyA6IGl0ZW1SYXRpbyA8IHJlY3RSYXRpbylcblx0XHRcdFx0XHQ/IHJlY3RhbmdsZS53aWR0aCAvIGJvdW5kcy53aWR0aFxuXHRcdFx0XHRcdDogcmVjdGFuZ2xlLmhlaWdodCAvIGJvdW5kcy5oZWlnaHQsXG5cdFx0XHRuZXdCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLFxuXHRcdFx0XHRcdG5ldyBTaXplKGJvdW5kcy53aWR0aCAqIHNjYWxlLCBib3VuZHMuaGVpZ2h0ICogc2NhbGUpKTtcblx0XHRuZXdCb3VuZHMuc2V0Q2VudGVyKHJlY3RhbmdsZS5nZXRDZW50ZXIoKSk7XG5cdFx0dGhpcy5zZXRCb3VuZHMobmV3Qm91bmRzKTtcblx0fSxcblxuXHRfc2V0U3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcigpLFxuXHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbENvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRpZiAoc3Ryb2tlQ29sb3IpIHtcblx0XHRcdHZhciBzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKSB7XG5cdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdFx0XHRzdHJva2VDYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdFx0XHRtaXRlckxpbWl0ID0gc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRpZiAoc3Ryb2tlSm9pbilcblx0XHRcdFx0XHRjdHgubGluZUpvaW4gPSBzdHJva2VKb2luO1xuXHRcdFx0XHRpZiAoc3Ryb2tlQ2FwKVxuXHRcdFx0XHRcdGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuXHRcdFx0XHRpZiAobWl0ZXJMaW1pdClcblx0XHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdFx0XHRcdGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcblx0XHRcdFx0XHR2YXIgZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdFx0XHRkYXNoT2Zmc2V0ID0gc3R5bGUuZ2V0RGFzaE9mZnNldCgpO1xuXHRcdFx0XHRcdGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCdzZXRMaW5lRGFzaCcgaW4gY3R4KSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2ggPSBkYXNoQXJyYXk7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHNoYWRvd0NvbG9yKSB7XG5cdFx0XHR2YXIgc2hhZG93Qmx1ciA9IHN0eWxlLmdldFNoYWRvd0JsdXIoKTtcblx0XHRcdGlmIChzaGFkb3dCbHVyID4gMCkge1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcblx0XHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuZ2V0U2hhZG93T2Zmc2V0KCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG5cdFx0XHRcdGN0eC5zaGFkb3dPZmZzZXRZID0gb2Zmc2V0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHBhcmVudFN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciB1cGRhdGVWZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIG1hdHJpY2VzID0gcGFyYW0ubWF0cmljZXMsXG5cdFx0XHR2aWV3TWF0cml4ID0gcGFyYW0udmlld01hdHJpeCxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGdsb2JhbE1hdHJpeCA9IG1hdHJpY2VzW21hdHJpY2VzLmxlbmd0aCAtIDFdLmNoYWluKG1hdHJpeCk7XG5cdFx0aWYgKCFnbG9iYWxNYXRyaXguaXNJbnZlcnRpYmxlKCkpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRmdW5jdGlvbiBnZXRWaWV3TWF0cml4KG1hdHJpeCkge1xuXHRcdFx0cmV0dXJuIHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmNoYWluKG1hdHJpeCkgOiBtYXRyaXg7XG5cdFx0fVxuXG5cdFx0bWF0cmljZXMucHVzaChnbG9iYWxNYXRyaXgpO1xuXHRcdGlmIChwYXJhbS51cGRhdGVNYXRyaXgpIHtcblx0XHRcdGdsb2JhbE1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXg7XG5cdFx0fVxuXG5cdFx0dmFyIGJsZW5kTW9kZSA9IHRoaXMuX2JsZW5kTW9kZSxcblx0XHRcdG9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5LFxuXHRcdFx0bm9ybWFsQmxlbmQgPSBibGVuZE1vZGUgPT09ICdub3JtYWwnLFxuXHRcdFx0bmF0aXZlQmxlbmQgPSBCbGVuZE1vZGUubmF0aXZlTW9kZXNbYmxlbmRNb2RlXSxcblx0XHRcdGRpcmVjdCA9IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPT09IDFcblx0XHRcdFx0XHR8fCBwYXJhbS5kb250U3RhcnRcblx0XHRcdFx0XHR8fCBwYXJhbS5jbGlwXG5cdFx0XHRcdFx0fHwgKG5hdGl2ZUJsZW5kIHx8IG5vcm1hbEJsZW5kICYmIG9wYWNpdHkgPCAxKVxuXHRcdFx0XHRcdFx0JiYgdGhpcy5fY2FuQ29tcG9zaXRlKCksXG5cdFx0XHRwaXhlbFJhdGlvID0gcGFyYW0ucGl4ZWxSYXRpbyxcblx0XHRcdG1haW5DdHgsIGl0ZW1PZmZzZXQsIHByZXZPZmZzZXQ7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyhnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCkpO1xuXHRcdFx0aWYgKCFib3VuZHMud2lkdGggfHwgIWJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXZPZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpdGVtT2Zmc2V0ID0gcGFyYW0ub2Zmc2V0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpO1xuXHRcdFx0bWFpbkN0eCA9IGN0eDtcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoYm91bmRzLmdldFNpemUoKS5jZWlsKCkuYWRkKDEpXG5cdFx0XHRcdFx0Lm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKVxuXHRcdFx0XHRjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIHN0cm9rZU1hdHJpeCA9IHBhcmVudFN0cm9rZU1hdHJpeFxuXHRcdFx0XHQ/IHBhcmVudFN0cm9rZU1hdHJpeC5jaGFpbihtYXRyaXgpXG5cdFx0XHRcdDogIXRoaXMuZ2V0U3Ryb2tlU2NhbGluZyh0cnVlKSAmJiBnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCksXG5cdFx0XHRjbGlwID0gIWRpcmVjdCAmJiBwYXJhbS5jbGlwSXRlbSxcblx0XHRcdHRyYW5zZm9ybSA9ICFzdHJva2VNYXRyaXggfHwgY2xpcDtcblx0XHRpZiAoZGlyZWN0KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXHRcdFx0aWYgKG5hdGl2ZUJsZW5kKVxuXHRcdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuXHRcdH0gZWxzZSBpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuXHRcdH1cblx0XHRpZiAodHJhbnNmb3JtKVxuXHRcdFx0KGRpcmVjdCA/IG1hdHJpeCA6IGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSkuYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAoY2xpcClcblx0XHRcdHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHRpZiAoc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGlmIChvZmZzZXQpXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuXHRcdH1cblx0XHR0aGlzLl9kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRtYXRyaWNlcy5wb3AoKTtcblx0XHRpZiAocGFyYW0uY2xpcCAmJiAhcGFyYW0uZG9udEZpbmlzaClcblx0XHRcdGN0eC5jbGlwKCk7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LFxuXHRcdFx0XHRcdGl0ZW1PZmZzZXQuc3VidHJhY3QocHJldk9mZnNldCkubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0cGFyYW0ub2Zmc2V0ID0gcHJldk9mZnNldDtcblx0XHR9XG5cdH0sXG5cblx0X2lzVXBkYXRlZDogZnVuY3Rpb24odXBkYXRlVmVyc2lvbikge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdHJldHVybiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKTtcblx0XHR2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPT09IHVwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF1cGRhdGVkICYmIHBhcmVudCAmJiBwYXJlbnQuX3Zpc2libGVcblx0XHRcdFx0JiYgcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB1cGRhdGVkO1xuXHR9LFxuXG5cdF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgc2VsZWN0ZWRJdGVtcywgdXBkYXRlVmVyc2lvbikge1xuXHRcdGlmICgodGhpcy5fZHJhd1NlbGVjdGVkIHx8IHRoaXMuX2JvdW5kc1NlbGVjdGVkKVxuXHRcdFx0XHQmJiB0aGlzLl9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKVxuXHRcdFx0XHRcdHx8IHRoaXMuZ2V0TGF5ZXIoKS5nZXRTZWxlY3RlZENvbG9yKHRydWUpLFxuXHRcdFx0XHRteCA9IG1hdHJpeC5jaGFpbih0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3Jcblx0XHRcdFx0XHQ/IGNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KSA6ICcjMDA5ZGVjJztcblx0XHRcdGlmICh0aGlzLl9kcmF3U2VsZWN0ZWQpXG5cdFx0XHRcdHRoaXMuX2RyYXdTZWxlY3RlZChjdHgsIG14LCBzZWxlY3RlZEl0ZW1zKTtcblx0XHRcdGlmICh0aGlzLl9ib3VuZHNTZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgaGFsZiA9IHNpemUgLyAyO1xuXHRcdFx0XHRcdGNvb3JkcyA9IG14Ll90cmFuc2Zvcm1Db3JuZXJzKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4W2kgPT09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjb29yZHNbaV0sIGNvb3Jkc1srK2ldKTtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsXG5cdFx0XHRcdFx0XHRcdHNpemUsIHNpemUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2Rvd24nLCAnZHJhZycsICd1cCcsICdtb3ZlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dGhpc1sncmVtb3ZlT24nICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNoID0ge307XG5cdFx0aGFzaFtuYW1lXSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlT24oaGFzaCk7XG5cdH07XG59LCB7XG5cblx0cmVtb3ZlT246IGZ1bmN0aW9uKG9iaikge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqW25hbWVdKSB7XG5cdFx0XHRcdHZhciBrZXkgPSAnbW91c2UnICsgbmFtZSxcblx0XHRcdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0XHRzZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgfHwge307XG5cdFx0XHRcdHNldHNba2V5XSA9IHNldHNba2V5XSB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KSk7XG5cbnZhciBHcm91cCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JvdXAnLFxuXHRfc2VsZWN0Q2hpbGRyZW46IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcm91cChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSlcblx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcblx0XHRfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXHRcdGlmIChmbGFncyAmIDEwMjYpIHtcblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Q2xpcEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjbGlwSXRlbSA9IHRoaXMuX2NsaXBJdGVtO1xuXHRcdGlmIChjbGlwSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjbGlwSXRlbSA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGNoaWxkLl9jbGlwTWFzaykge1xuXHRcdFx0XHRcdGNsaXBJdGVtID0gY2hpbGQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gY2xpcEl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBjbGlwSXRlbTtcblx0fSxcblxuXHRpc0NsaXBwZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldENsaXBJdGVtKCk7XG5cdH0sXG5cblx0c2V0Q2xpcHBlZDogZnVuY3Rpb24oY2xpcHBlZCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdGlmIChjaGlsZClcblx0XHRcdGNoaWxkLnNldENsaXBNYXNrKGNsaXBwZWQpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dmFyIGNsaXAgPSBwYXJhbS5jbGlwLFxuXHRcdFx0Y2xpcEl0ZW0gPSAhY2xpcCAmJiB0aGlzLl9nZXRDbGlwSXRlbSgpLFxuXHRcdFx0ZHJhdyA9IHRydWU7XG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBjbGlwSXRlbTogY2xpcEl0ZW0sIGNsaXA6IGZhbHNlIH0pO1xuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudFBhdGgpIHtcblx0XHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0XHRcdGRyYXcgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0cGFyYW0uZG9udFN0YXJ0ID0gcGFyYW0uZG9udEZpbmlzaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjbGlwSXRlbSkge1xuXHRcdFx0Y2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdH1cblx0XHRpZiAoZHJhdykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IGNsaXBJdGVtKVxuXHRcdFx0XHRcdGl0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBMYXllciA9IEdyb3VwLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xheWVyJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMYXllcihhcmcpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQ/IG5ldyBCYXNlKGFyZylcblx0XHRcdFx0OiB7IGNoaWxkcmVuOiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMgfSxcblx0XHRcdGluc2VydCA9IHByb3BzLmluc2VydDtcblx0XHRwcm9wcy5pbnNlcnQgPSBmYWxzZTtcblx0XHRHcm91cC5jYWxsKHRoaXMsIHByb3BzKTtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9wcm9qZWN0LmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbiBfcmVtb3ZlKG5vdGlmeSkge1xuXHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRyZXR1cm4gX3JlbW92ZS5iYXNlLmNhbGwodGhpcywgbm90aWZ5KTtcblx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0aWYgKHByb2plY3QuX2FjdGl2ZUxheWVyID09PSB0aGlzKVxuXHRcdFx0XHRwcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKVxuXHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHByb2plY3QubGF5ZXJzLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXROZXh0U2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldFByZXZpb3VzU2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gaXNJbnNlcnRlZC5iYXNlLmNhbGwodGhpcykgOiB0aGlzLl9pbmRleCAhPSBudWxsO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXM7XG5cdH0sXG5cblx0X2luc2VydDogZnVuY3Rpb24gX2luc2VydChhYm92ZSwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllciAmJiAhaXRlbS5fcGFyZW50KSB7XG5cdFx0XHR0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRCYXNlLnNwbGljZShpdGVtLl9wcm9qZWN0LmxheWVycywgW3RoaXNdLFxuXHRcdFx0XHRcdGl0ZW0uX2luZGV4ICsgKGFib3ZlID8gMSA6IDApLCAwKTtcblx0XHRcdHRoaXMuX3NldFByb2plY3QoaXRlbS5fcHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIF9pbnNlcnQuYmFzZS5jYWxsKHRoaXMsIGFib3ZlLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9XG59KTtcblxudmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaGFwZScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHR5cGU6IG51bGwsXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRyYWRpdXM6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcykge1xuXHRcdHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZVxuXHRcdFx0JiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSlcblx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgU2hhcGUoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0VHlwZSh0aGlzLl90eXBlKTtcblx0XHRjb3B5LnNldFNpemUodGhpcy5fc2l6ZSk7XG5cdFx0Y29weS5zZXRSYWRpdXModGhpcy5fcmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fSxcblxuXHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdH0sXG5cblx0Z2V0U2hhcGU6ICcjZ2V0VHlwZScsXG5cdHNldFNoYXBlOiAnI3NldFR5cGUnLFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0fSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0d2lkdGggPSBoZWlnaHQgPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldCh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG5cdFx0XHRcdD8gcmFkXG5cdFx0XHRcdDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbihyYWRpdXMpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBzaXplID0gcmFkaXVzICogMjtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdGlmICghdGhpcy5fcmFkaXVzKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JhZGl1cy5lcXVhbHMocmFkaXVzKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLm1heCh0aGlzLl9zaXplLCByYWRpdXMubXVsdGlwbHkoMikpO1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dG9QYXRoOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoW0Jhc2UuY2FwaXRhbGl6ZSh0aGlzLl90eXBlKV0oe1xuXHRcdFx0Y2VudGVyOiBuZXcgUG9pbnQoKSxcblx0XHRcdHNpemU6IHRoaXMuX3NpemUsXG5cdFx0XHRyYWRpdXM6IHRoaXMuX3JhZGl1cyxcblx0XHRcdGluc2VydDogZmFsc2Vcblx0XHR9KTtcblx0XHRwYXRoLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRwYXRoLnRyYW5zZm9ybSh0aGlzLl9tYXRyaXgpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuXHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSB8fCBkb250UGFpbnQpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRpc0NpcmNsZSA9IHR5cGUgPT09ICdjaXJjbGUnO1xuXHRcdFx0aWYgKCFwYXJhbS5kb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIGlzQ2lyY2xlKSB7XG5cdFx0XHRcdGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcnggPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRzaXplID0gdGhpcy5fc2l6ZSxcblx0XHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIHR5cGUgPT09ICdyZWN0JyAmJiByeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdGN0eC5yZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgeCA9IHdpZHRoIC8gMixcblx0XHRcdFx0XHRcdHkgPSBoZWlnaHQgLyAyLFxuXHRcdFx0XHRcdFx0a2FwcGEgPSAxIC0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0Y3kgPSByeSAqIGthcHBhLFxuXHRcdFx0XHRcdFx0YyA9IFtcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgLXksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdHgsIC15ICsgcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIHksXG5cdFx0XHRcdFx0XHRcdHggLSByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyByeCwgeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0LXgsIHkgLSByeVxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRpZiAoc3Ryb2tlTWF0cml4KVxuXHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4LnRyYW5zZm9ybShjLCBjLCAzMik7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjWzBdLCBjWzFdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzJdLCBjWzNdLCBjWzRdLCBjWzVdLCBjWzZdLCBjWzddKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbOF0sIGNbOV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMTBdLCBjWzExXSwgY1sxMl0sIGNbMTNdLCBjWzE0XSwgY1sxNV0pO1xuXHRcdFx0XHRcdGlmICh5ICE9PSByeSlcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1sxNl0sIGNbMTddKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzE4XSwgY1sxOV0sIGNbMjBdLCBjWzIxXSwgY1syMl0sIGNbMjNdKTtcblx0XHRcdFx0XHRpZiAoeCAhPT0gcngpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMjRdLCBjWzI1XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syNl0sIGNbMjddLCBjWzI4XSwgY1syOV0sIGNbMzBdLCBjWzMxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHR9XG5cdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0aWYgKGdldHRlciAhPT0gJ2dldEJvdW5kcycgJiYgdGhpcy5oYXNTdHJva2UoKSlcblx0XHRcdHJlY3QgPSByZWN0LmV4cGFuZCh0aGlzLmdldFN0cm9rZVdpZHRoKCkpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQoaSAmIDEgPyAxIDogLTEsIGkgPiAxID8gMSA6IC0xKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoY29ybmVyLCBjZW50ZXIpO1xuXHRcdFx0XHRpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcblx0XHR2YXIgYW5nbGUgPSBwb2ludC5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0d2lkdGggPSByYWRpdXMud2lkdGggKiAyLFxuXHRcdFx0aGVpZ2h0ID0gcmFkaXVzLmhlaWdodCAqIDIsXG5cdFx0XHR4ID0gd2lkdGggKiBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR5ID0gaGVpZ2h0ICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHJldHVybiB3aWR0aCAqIGhlaWdodCAvICgyICogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHQgPSBwb2ludC5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHB0LmdldExlbmd0aCgpXG5cdFx0XHRcdFx0XHRcdFx0LSBnZXRFbGxpcHNlUmFkaXVzKHB0LCByYWRpdXMpKSA8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChzdHJva2VXaWR0aCksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQoLXN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpXG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuXHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwb2ludC5nZXRMZW5ndGgoKSAtIHJhZGl1cylcblx0XHRcdFx0XHRcdFx0PD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXRcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBuZXcgU2hhcGUoQmFzZS5nZXROYW1lZChhcmdzKSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtLnRyYW5zbGF0ZShwb2ludCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUob2JqZWN0LFxuXHRcdFx0XHRwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpXG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRpbWFnZSA9IHRoaXMuX2ltYWdlLFxuXHRcdFx0Y2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdGlmIChpbWFnZSkge1xuXHRcdFx0Y29weS5zZXRJbWFnZShpbWFnZSk7XG5cdFx0fSBlbHNlIGlmIChjYW52YXMpIHtcblx0XHRcdHZhciBjb3B5Q2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHRoaXMuX3NpemUpO1xuXHRcdFx0Y29weUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuXHRcdFx0Y29weS5zZXRDYW52YXMoY29weUNhbnZhcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0dGhpcy5zZXRDYW52YXMoQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpKTtcblx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkuZHJhd0ltYWdlKGVsZW1lbnQsIDAsIDAsXG5cdFx0XHRcdFx0XHRzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS53aWR0aDtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS53aWR0aCA9PT0gMCAmJiB0aGlzLl9zaXplLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0b3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG5cdFx0XHR2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuXHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdDcyIC8gdS5nZXRMZW5ndGgoKSxcblx0XHRcdDcyIC8gdi5nZXRMZW5ndGgoKVxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0UHBpOiAnI2dldFJlc29sdXRpb24nLFxuXG5cdGdldEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH0sXG5cblx0c2V0SW1hZ2U6IGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRpZiAoaW1hZ2UgJiYgaW1hZ2UuZ2V0Q29udGV4dCkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gaW1hZ2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLndpZHRoIDogMCxcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IGltYWdlLmhlaWdodCA6IDApO1xuXHRcdHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHRcdHRoaXMuX2NoYW5nZWQoNTIxKTtcblx0fSxcblxuXHRnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCh0aGlzLl9zaXplKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwKTtcblx0XHRcdFx0dGhpcy5fY2FudmFzID0gY3R4LmNhbnZhcztcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzO1xuXHR9LFxuXG5cdHNldENhbnZhczogJyNzZXRJbWFnZScsXG5cblx0Z2V0Q29udGV4dDogZnVuY3Rpb24obW9kaWZ5KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAobW9kaWZ5KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDUxMyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblx0fSxcblxuXHRnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmMgfHwgdGhpcy50b0RhdGFVUkwoKTtcblx0fSxcblxuXHRzZXRTb3VyY2U6IGZ1bmN0aW9uKHNyYykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZGVkKCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKTtcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHR0aGF0LmVtaXQoJ2xvYWQnKTtcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzIHx8IHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0Q2FudmFzKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblx0XHRyYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cdFx0cmFzdGVyLl9tYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fbWF0cml4KTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHR0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzcmMgPSB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmM7XG5cdFx0aWYgKC9eZGF0YTovLnRlc3Qoc3JjKSlcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwoKSA6IG51bGw7XG5cdH0sXG5cblx0ZHJhd0ltYWdlOiBmdW5jdGlvbihpbWFnZSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbihvYmplY3QpIHtcblx0XHR2YXIgYm91bmRzLCBwYXRoO1xuXHRcdGlmICghb2JqZWN0KSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcblx0XHRcdHBhdGggPSBvYmplY3Q7XG5cdFx0XHRib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3Qud2lkdGgpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC54KSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG5cdFx0fVxuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuXHRcdFx0XHRvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcblx0XHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcGFjaXR5O1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFBsYWNlZFN5bWJvbCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGxhY2VkU3ltYm9sJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogeyBnZXRCb3VuZHM6ICdnZXRTdHJva2VCb3VuZHMnIH0sXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBsYWNlZFN5bWJvbChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZzAsXG5cdFx0XHRcdGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKVxuXHRcdFx0dGhpcy5zZXRTeW1ib2woYXJnMCBpbnN0YW5jZW9mIFN5bWJvbCA/IGFyZzAgOiBuZXcgU3ltYm9sKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbCA9PT0gaXRlbS5fc3ltYm9sO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbDtcblx0fSxcblxuXHRzZXRTeW1ib2w6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHRoaXMuX3N5bWJvbCA9IHN5bWJvbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQbGFjZWRTeW1ib2woSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U3ltYm9sKHRoaXMuX3N5bWJvbCk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBkZWZpbml0aW9uID0gdGhpcy5zeW1ib2wuX2RlZmluaXRpb247XG5cdFx0cmV0dXJuIGRlZmluaXRpb24uX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oZGVmaW5pdGlvbi5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5zeW1ib2wuX2RlZmluaXRpb24uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHZhbHVlcy5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5qZWN0KHZhbHVlcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJhc2Uoe1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHR0b2xlcmFuY2U6IHBhcGVyLnNldHRpbmdzLmhpdFRvbGVyYW5jZSxcblx0XHRcdFx0ZmlsbDogIW9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZTogIW9wdGlvbnMsXG5cdFx0XHRcdHNlZ21lbnRzOiAhb3B0aW9ucyxcblx0XHRcdFx0aGFuZGxlczogZmFsc2UsXG5cdFx0XHRcdGVuZHM6IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0O1xuXHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcwLnBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcwLmhhbmRsZUluO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyICYmIHR5cGVvZiBhcmcwID09PSAnbnVtYmVyJykge1xuXHRcdFx0cG9pbnQgPSBhcmd1bWVudHM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG5cdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzE7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb2ludCA9IGFyZzAgIT09IHVuZGVmaW5lZCA/IFsgYXJnMCwgYXJnMSBdIDogbnVsbDtcblx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gWyBhcmc0LCBhcmc1IF0gOiBudWxsO1xuXHRcdH1cblx0XHRuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5pc0xpbmVhcigpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgJiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdHNldExpbmVhcjogZnVuY3Rpb24obGluZWFyKSB7XG5cdFx0aWYgKGxpbmVhcikge1xuXHRcdFx0dGhpcy5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHRcdFx0dGhpcy5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdH1cblx0fSxcblxuXHRpc0NvbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0dmFyIG5leHQxID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRuZXh0MiA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dDEuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBuZXh0Mi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0JiYgbmV4dDEuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KS5pc0NvbGluZWFyKFxuXHRcdFx0XHRcdG5leHQyLl9wb2ludC5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLmdldFByZXZpb3VzKCksXG5cdFx0XHRuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0cmV0dXJuIHByZXYuX2hhbmRsZU91dC5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHQmJiB0aGlzLl9wb2ludC5zdWJ0cmFjdChwcmV2Ll9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdG5leHQuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSk7XG5cdH0sXG5cblx0aXNBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRoYW5kbGUxID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlMiA9IG5leHQuX2hhbmRsZUluLFxuXHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHR0byA9IG5leHQuX3BvaW50LFxuXHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShmcm9tLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRuZXcgTGluZSh0bywgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChmcm9tKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdCh0bykuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlSW4gOiBudWxsLFxuXHRcdFx0aGFuZGxlT3V0ID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVPdXQgOiBudWxsLFxuXHRcdFx0eCA9IHBvaW50Ll94LFxuXHRcdFx0eSA9IHBvaW50Ll95LFxuXHRcdFx0aSA9IDI7XG5cdFx0Y29vcmRzWzBdID0geDtcblx0XHRjb29yZHNbMV0gPSB5O1xuXHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl95ICsgeTtcblx0XHR9XG5cdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVPdXQuX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCBpIC8gMik7XG5cdFx0XHR4ID0gY29vcmRzWzBdO1xuXHRcdFx0eSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChjaGFuZ2UpIHtcblx0XHRcdFx0cG9pbnQuX3ggPSB4O1xuXHRcdFx0XHRwb2ludC5feSA9IHk7XG5cdFx0XHRcdGkgID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LCBzZWxlY3RlZDtcblx0XHRpZiAoIXBvaW50KSB7XG5cdFx0XHR4ID0geSA9IDA7XG5cdFx0fSBlbHNlIGlmICgoeCA9IHBvaW50WzBdKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR5ID0gcG9pbnRbMV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwdCA9IHBvaW50O1xuXHRcdFx0aWYgKCh4ID0gcHQueCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0eCA9IHB0Lng7XG5cdFx0XHR9XG5cdFx0XHR5ID0gcHQueTtcblx0XHRcdHNlbGVjdGVkID0gcHQuc2VsZWN0ZWQ7XG5cdFx0fVxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0b3duZXJba2V5XSA9IHRoaXM7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcixcblx0XHRcdHggPSBmLm51bWJlcih0aGlzLl94KSxcblx0XHRcdHkgPSBmLm51bWJlcih0aGlzLl95KTtcblx0XHRyZXR1cm4gdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0PyB7IHg6IHgsIHk6IHksIHNlbGVjdGVkOiB0cnVlIH1cblx0XHRcdFx0OiBbeCwgeV07XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3gpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5feSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5fb3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vd25lci5pc1NlbGVjdGVkKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmIChjb3VudCA9PT0gMykge1xuXHRcdFx0dGhpcy5fcGF0aCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IGFyZzE7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IGFyZzI7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudCgpO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudCgpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50MSk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoYXJnMCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQxLCBoYW5kbGUxLCBoYW5kbGUyLCBwb2ludDI7XG5cdFx0XHRpZiAoY291bnQgPT09IDQpIHtcblx0XHRcdFx0cG9pbnQxID0gYXJnMDtcblx0XHRcdFx0aGFuZGxlMSA9IGFyZzE7XG5cdFx0XHRcdGhhbmRsZTIgPSBhcmcyO1xuXHRcdFx0XHRwb2ludDIgPSBhcmczO1xuXHRcdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gOCkge1xuXHRcdFx0XHRwb2ludDEgPSBbYXJnMCwgYXJnMV07XG5cdFx0XHRcdHBvaW50MiA9IFthcmc2LCBhcmc3XTtcblx0XHRcdFx0aGFuZGxlMSA9IFthcmcyIC0gYXJnMCwgYXJnMyAtIGFyZzFdO1xuXHRcdFx0XHRoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KHBvaW50MSwgbnVsbCwgaGFuZGxlMSk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KHBvaW50MiwgaGFuZGxlMiwgbnVsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Z2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MTtcblx0fSxcblxuXHRnZXRTZWdtZW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4ICsgMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggLSAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuaXNMaW5lYXIoKVxuXHRcdFx0XHQ/IHRoaXMuX3NlZ21lbnQyLl9wb2ludC5nZXREaXN0YW5jZSh0aGlzLl9zZWdtZW50MS5fcG9pbnQpXG5cdFx0XHRcdDogQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRBcmVhKHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG5cdH0sXG5cblx0Z2V0UGFydExlbmd0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0JiYgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuXHR9LFxuXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lYXIoKSAmJiBOdW1lcmljYWwuaXNaZXJvKFxuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5fcG9pbnQuX3kgLSB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuX3kpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEludGVyc2VjdGlvbnModGhpcy5nZXRWYWx1ZXMoKSwgY3VydmUuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdHRoaXMsIGN1cnZlLCBbXSk7XG5cdH0sXG5cblx0X2dldFBhcmFtZXRlcjogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiBpc1BhcmFtZXRlclxuXHRcdFx0XHQ/IG9mZnNldFxuXHRcdFx0XHQ6IG9mZnNldCAmJiBvZmZzZXQuY3VydmUgPT09IHRoaXNcblx0XHRcdFx0XHQ/IG9mZnNldC5wYXJhbWV0ZXJcblx0XHRcdFx0XHQ6IG9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGlzUGFyYW1ldGVyID09PSB1bmRlZmluZWRcblx0XHRcdFx0XHRcdD8gMC41XG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0LCAwKTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIsIGlnbm9yZUxpbmVhcikge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlciksXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAxLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAocGFyYW1ldGVyID4gdG9sZXJhbmNlICYmIHBhcmFtZXRlciA8IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIpLFxuXHRcdFx0XHRpc0xpbmVhciA9IGlnbm9yZUxpbmVhciA/IGZhbHNlIDogdGhpcy5pc0xpbmVhcigpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV07XG5cblx0XHRcdGlmICghaXNMaW5lYXIpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQobGVmdFsyXSAtIGxlZnRbMF0sXG5cdFx0XHRcdFx0XHRsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocmlnaHRbNF0gLSByaWdodFs2XSxcblx0XHRcdFx0XHRcdHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgeCA9IGxlZnRbNl0sIHkgPSBsZWZ0WzddLFxuXHRcdFx0XHRzZWdtZW50ID0gbmV3IFNlZ21lbnQobmV3IFBvaW50KHgsIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXG5cdFx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc2VnbWVudDEuX2luZGV4ID4gMCAmJiB0aGlzLl9zZWdtZW50Mi5faW5kZXggPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmFkZChzZWdtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmluc2VydCh0aGlzLl9zZWdtZW50Mi5faW5kZXgsIHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZW5kID0gdGhpcy5fc2VnbWVudDI7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnbWVudDtcblx0XHRcdFx0cmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIGVuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aFxuXHRcdFx0PyB0aGlzLl9wYXRoLnNwbGl0KHRoaXMuX3NlZ21lbnQxLl9pbmRleCxcblx0XHRcdFx0XHR0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlcikpXG5cdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2UoKSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudDIgPSB0aGlzLl9zZWdtZW50Mixcblx0XHRcdFx0aGFuZGxlT3V0ID0gc2VnbWVudDIuX2hhbmRsZU91dDtcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50Mi5yZW1vdmUoKTtcblx0XHRcdGlmIChyZW1vdmVkKVxuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChoYW5kbGVPdXQueCwgaGFuZGxlT3V0LnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcblx0XHRwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCkge1xuXHRcdHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcblx0XHRcdGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuXHRcdFx0cDIgPSBzZWdtZW50Mi5fcG9pbnQsXG5cdFx0XHR2YWx1ZXMgPSBbXG5cdFx0XHRcdHAxLl94LCBwMS5feSxcblx0XHRcdFx0cDEuX3ggKyBoMS5feCwgcDEuX3kgKyBoMS5feSxcblx0XHRcdFx0cDIuX3ggKyBoMi5feCwgcDIuX3kgKyBoMi5feSxcblx0XHRcdFx0cDIuX3gsIHAyLl95XG5cdFx0XHRdO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHZhbHVlcywgdmFsdWVzLCA0KTtcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbih2LCB0LCB0eXBlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAxLFxuXHRcdFx0eCwgeTtcblxuXHRcdGlmICh0eXBlID09PSAwICYmICh0IDwgdG9sZXJhbmNlIHx8IHQgPiAxIC0gdG9sZXJhbmNlKSkge1xuXHRcdFx0dmFyIGlzWmVybyA9IHQgPCB0b2xlcmFuY2U7XG5cdFx0XHR4ID0gaXNaZXJvID8gcDF4IDogcDJ4O1xuXHRcdFx0eSA9IGlzWmVybyA/IHAxeSA6IHAyeTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXHRcdFx0XHRieCA9IDMgKiAoYzJ4IC0gYzF4KSAtIGN4LFxuXHRcdFx0XHRheCA9IHAyeCAtIHAxeCAtIGN4IC0gYngsXG5cblx0XHRcdFx0Y3kgPSAzICogKGMxeSAtIHAxeSksXG5cdFx0XHRcdGJ5ID0gMyAqIChjMnkgLSBjMXkpIC0gY3ksXG5cdFx0XHRcdGF5ID0gcDJ5IC0gcDF5IC0gY3kgLSBieTtcblx0XHRcdGlmICh0eXBlID09PSAwKSB7XG5cdFx0XHRcdHggPSAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgcDF4O1xuXHRcdFx0XHR5ID0gKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdCArIHAxeTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0IDwgdG9sZXJhbmNlICYmIGMxeCA9PT0gcDF4ICYmIGMxeSA9PT0gcDF5XG5cdFx0XHRcdFx0XHR8fCB0ID4gMSAtIHRvbGVyYW5jZSAmJiBjMnggPT09IHAyeCAmJiBjMnkgPT09IHAyeSkge1xuXHRcdFx0XHRcdHggPSBjMnggLSBjMXg7XG5cdFx0XHRcdFx0eSA9IGMyeSAtIGMxeTtcblx0XHRcdFx0fSBlbHNlIGlmICh0IDwgdG9sZXJhbmNlKSB7XG5cdFx0XHRcdFx0eCA9IGN4O1xuXHRcdFx0XHRcdHkgPSBjeTtcblx0XHRcdFx0fSBlbHNlIGlmICh0ID4gMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSAzICogKHAyeCAtIGMyeCk7XG5cdFx0XHRcdFx0eSA9IDMgKiAocDJ5IC0gYzJ5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuXHRcdFx0XHRcdHkgPSAoMyAqIGF5ICogdCArIDIgKiBieSkgKiB0ICsgY3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHR2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuXHRcdFx0XHRcdFx0eTIgPSA2ICogYXkgKiB0ICsgMiAqIGJ5O1xuXHRcdFx0XHRcdHJldHVybiAoeCAqIHkyIC0geSAqIHgyKSAvIE1hdGgucG93KHggKiB4ICsgeSAqIHksIDMgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHAzeCA9IHUgKiBwMXggKyB0ICogYzF4LCBwM3kgPSB1ICogcDF5ICsgdCAqIGMxeSxcblx0XHRcdHA0eCA9IHUgKiBjMXggKyB0ICogYzJ4LCBwNHkgPSB1ICogYzF5ICsgdCAqIGMyeSxcblx0XHRcdHA1eCA9IHUgKiBjMnggKyB0ICogcDJ4LCBwNXkgPSB1ICogYzJ5ICsgdCAqIHAyeSxcblx0XHRcdHA2eCA9IHUgKiBwM3ggKyB0ICogcDR4LCBwNnkgPSB1ICogcDN5ICsgdCAqIHA0eSxcblx0XHRcdHA3eCA9IHUgKiBwNHggKyB0ICogcDV4LCBwN3kgPSB1ICogcDR5ICsgdCAqIHA1eSxcblx0XHRcdHA4eCA9IHUgKiBwNnggKyB0ICogcDd4LCBwOHkgPSB1ICogcDZ5ICsgdCAqIHA3eTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3AxeCwgcDF5LCBwM3gsIHAzeSwgcDZ4LCBwNnksIHA4eCwgcDh5XSxcblx0XHRcdFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV1cblx0XHRdO1xuXHR9LFxuXG5cdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcblx0XHR2YXIgcDEgPSB2W2Nvb3JkXSxcblx0XHRcdGMxID0gdltjb29yZCArIDJdLFxuXHRcdFx0YzIgPSB2W2Nvb3JkICsgNF0sXG5cdFx0XHRwMiA9IHZbY29vcmQgKyA2XSxcblx0XHRcdGMgPSAzICogKGMxIC0gcDEpLFxuXHRcdFx0YiA9IDMgKiAoYzIgLSBjMSkgLSBjLFxuXHRcdFx0YSA9IHAyIC0gcDEgLSBjIC0gYjtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgcDEgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHgsIHkpIHtcblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMTtcblx0XHRpZiAoTWF0aC5hYnModlswXSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbMV0gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAwO1xuXHRcdGlmIChNYXRoLmFicyh2WzZdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModls3XSAtIHkpIDwgdG9sZXJhbmNlKVxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0dmFyIHR4cyA9IFtdLFxuXHRcdFx0dHlzID0gW10sXG5cdFx0XHRzeCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMCwgeCwgdHhzLCAwLCAxKSxcblx0XHRcdHN5ID0gQ3VydmUuc29sdmVDdWJpYyh2LCAxLCB5LCB0eXMsIDAsIDEpLFxuXHRcdFx0dHgsIHR5O1xuXHRcdGZvciAodmFyIGN4ID0gMDsgIHN4ID09IC0xIHx8IGN4IDwgc3g7KSB7XG5cdFx0XHRpZiAoc3ggPT0gLTEgfHwgKHR4ID0gdHhzW2N4KytdKSA+PSAwICYmIHR4IDw9IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBzeSA9PSAtMSB8fCBjeSA8IHN5Oykge1xuXHRcdFx0XHRcdGlmIChzeSA9PSAtMSB8fCAodHkgPSB0eXNbY3krK10pID49IDAgJiYgdHkgPD0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKHN4ID09IC0xKSB0eCA9IHR5O1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc3kgPT0gLTEpIHR5ID0gdHg7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModHggLSB0eSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0XHRcdHJldHVybiAodHggKyB0eSkgKiAwLjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCA9PSAtMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHRpZiAoZnJvbSA+IDApXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsIGZyb20pWzFdO1xuXHRcdGlmICh0byA8IDEpXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsICh0byAtIGZyb20pIC8gKDEgLSBmcm9tKSlbMF07XG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG5cdFx0XHRcdCYmIGlzWmVybyh2WzRdIC0gdls2XSkgJiYgaXNaZXJvKHZbNV0gLSB2WzddKTtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIHRvbGVyYW5jZSkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dXggPSAzICogYzF4IC0gMiAqIHAxeCAtIHAyeCxcblx0XHRcdHV5ID0gMyAqIGMxeSAtIDIgKiBwMXkgLSBwMnksXG5cdFx0XHR2eCA9IDMgKiBjMnggLSAyICogcDJ4IC0gcDF4LFxuXHRcdFx0dnkgPSAzICogYzJ5IC0gMiAqIHAyeSAtIHAxeTtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8IDEwICogdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRyZXR1cm4gKCAgMy4wICogYzF5ICogcDF4IC0gMS41ICogYzF5ICogYzJ4XG5cdFx0XHRcdC0gMS41ICogYzF5ICogcDJ4IC0gMy4wICogcDF5ICogYzF4XG5cdFx0XHRcdC0gMS41ICogcDF5ICogYzJ4IC0gMC41ICogcDF5ICogcDJ4XG5cdFx0XHRcdCsgMS41ICogYzJ5ICogcDF4ICsgMS41ICogYzJ5ICogYzF4XG5cdFx0XHRcdC0gMy4wICogYzJ5ICogcDJ4ICsgMC41ICogcDJ5ICogcDF4XG5cdFx0XHRcdCsgMS41ICogcDJ5ICogYzF4ICsgMy4wICogcDJ5ICogYzJ4KSAvIDEwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IFswLCAwXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKylcblx0XHRcdEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSxcblx0XHRcdFx0XHRpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0X2FkZEJvdW5kczogZnVuY3Rpb24odjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcblx0XHRmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcblx0XHRcdHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuXHRcdFx0XHRyaWdodCA9IHZhbHVlICsgcGFkZGluZztcblx0XHRcdGlmIChsZWZ0IDwgbWluW2Nvb3JkXSlcblx0XHRcdFx0bWluW2Nvb3JkXSA9IGxlZnQ7XG5cdFx0XHRpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuXHRcdFx0XHRtYXhbY29vcmRdID0gcmlnaHQ7XG5cdFx0fVxuXHRcdHZhciBhID0gMyAqICh2MSAtIHYyKSAtIHYwICsgdjMsXG5cdFx0XHRiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcblx0XHRcdGMgPSB2MSAtIHYwLFxuXHRcdFx0Y291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMpLFxuXHRcdFx0dE1pbiA9IDAuMDAwMDEsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0YWRkKHYzLCAwKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdHUgPSAxIC0gdDtcblx0XHRcdGlmICh0TWluIDwgdCAmJiB0IDwgdE1heClcblx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHQrIDMgKiB1ICogdCAqIHQgKiB2MlxuXHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFsnZ2V0Qm91bmRzJywgJ2dldFN0cm9rZUJvdW5kcycsICdnZXRIYW5kbGVCb3VuZHMnLCAnZ2V0Um91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV07XG5cdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFt0aGlzLl9zZWdtZW50MSxcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnQyXSwgZmFsc2UsIHRoaXMuX3BhdGguZ2V0U3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm91bmRzLmNsb25lKCk7XG5cdFx0fTtcblx0fSxcbntcblxufSksIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuXHRmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cdFx0XHRyZXR1cm4gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBpc1BhcmFtZXRlclxuXHRcdFx0XHRcdD8gb2Zmc2V0IDogQ3VydmUuZ2V0UGFyYW1ldGVyQXQodmFsdWVzLCBvZmZzZXQsIDApLCBpbmRleCk7XG5cdFx0fTtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG5cdFx0XHRyZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5nZXRWYWx1ZXMoKSwgcGFyYW1ldGVyLCBpbmRleCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFBhcmFtZXRlckF0KHRoaXMuZ2V0VmFsdWVzKCksIG9mZnNldCwgc3RhcnQpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlck9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuZ2V0VmFsdWVzKCksIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRpZiAoIWlzUGFyYW1ldGVyKVxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdHJldHVybiBvZmZzZXQgPj0gMCAmJiBvZmZzZXQgPD0gMSAmJiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCBvZmZzZXQpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXQodGhpcy5nZXRQYXJhbWV0ZXJPZihQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHR0cnVlKTtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdGNvdW50ID0gMTAwLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluVCA9IDA7XG5cblx0XHRmdW5jdGlvbiByZWZpbmUodCkge1xuXHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcblx0XHRcdFx0dmFyIGRpc3QgPSBwb2ludC5nZXREaXN0YW5jZShcblx0XHRcdFx0XHRcdEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gMC4wMDAwMSkge1xuXHRcdFx0aWYgKCFyZWZpbmUobWluVCAtIHN0ZXApICYmICFyZWZpbmUobWluVCArIHN0ZXApKVxuXHRcdFx0XHRzdGVwIC89IDI7XG5cdFx0fVxuXHRcdHZhciBwdCA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgbWluVCwgMCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIG1pblQsIHB0LCBudWxsLCBudWxsLCBudWxsLFxuXHRcdFx0XHRwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZ2V0UG9pbnQoKTtcblx0fVxuXG59KSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRMZW5ndGhJbnRlZ3JhbmQodikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXG5cdFx0XHRheCA9IDkgKiAoYzF4IC0gYzJ4KSArIDMgKiAocDJ4IC0gcDF4KSxcblx0XHRcdGJ4ID0gNiAqIChwMXggKyBjMngpIC0gMTIgKiBjMXgsXG5cdFx0XHRjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblxuXHRcdFx0YXkgPSA5ICogKGMxeSAtIGMyeSkgKyAzICogKHAyeSAtIHAxeSksXG5cdFx0XHRieSA9IDYgKiAocDF5ICsgYzJ5KSAtIDEyICogYzF5LFxuXHRcdFx0Y3kgPSAzICogKGMxeSAtIHAxeSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcblx0XHRcdFx0ZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEl0ZXJhdGlvbnMoYSwgYikge1xuXHRcdHJldHVybiBNYXRoLm1heCgyLCBNYXRoLm1pbigxNiwgTWF0aC5jZWlsKE1hdGguYWJzKGIgLSBhKSAqIDMyKSkpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdGF0aWNzOiB0cnVlLFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbih2LCBhLCBiKSB7XG5cdFx0XHRpZiAoYSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRhID0gMDtcblx0XHRcdGlmIChiID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGIgPSAxO1xuXHRcdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0XHRpZiAoYSA9PT0gMCAmJiBiID09PSAxXG5cdFx0XHRcdFx0JiYgaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG5cdFx0XHRcdFx0JiYgaXNaZXJvKHZbNl0gLSB2WzRdKSAmJiBpc1plcm8odls3XSAtIHZbNV0pKSB7XG5cdFx0XHRcdHZhciBkeCA9IHZbNl0gLSB2WzBdLFxuXHRcdFx0XHRcdGR5ID0gdls3XSAtIHZbMV07XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpO1xuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsIGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdH0sXG5cblx0XHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24odiwgb2Zmc2V0LCBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHN0YXJ0ID0gb2Zmc2V0IDwgMCA/IDEgOiAwXG5cdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gc3RhcnQ7XG5cdFx0XHR2YXIgZm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYixcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdFx0aWYgKE1hdGguYWJzKG9mZnNldCkgPj0gcmFuZ2VMZW5ndGgpXG5cdFx0XHRcdHJldHVybiBmb3J3YXJkID8gYiA6IGE7XG5cdFx0XHR2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZ1bmN0aW9uIGYodCkge1xuXHRcdFx0XHRsZW5ndGggKz0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgc3RhcnQsIHQsXG5cdFx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKHN0YXJ0LCB0KSk7XG5cdFx0XHRcdHN0YXJ0ID0gdDtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aCAtIG9mZnNldDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuZmluZFJvb3QoZiwgZHMsIHN0YXJ0ICsgZ3Vlc3MsIGEsIGIsIDE2LFxuXHRcdFx0XHRcdDAuMDAwMDEpO1xuXHRcdH1cblx0fTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG5cdFx0XHRwb2ludDIpIHtcblx0XHR2YXIgbG9jID0gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUxLCB0MSwgcG9pbnQxLCBjdXJ2ZTIsIHQyLCBwb2ludDIpO1xuXHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpXG5cdFx0XHRsb2NhdGlvbnMucHVzaChsb2MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAocmVjdXJzaW9uID4gMjApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMSxcblx0XHRcdGh1bGxFcHNpbG9uID0gMWUtOSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pIHx8IDAsXG5cdFx0XHRkMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbNF0sIHYyWzVdKSB8fCAwLFxuXHRcdFx0ZmFjdG9yID0gZDEgKiBkMiA+IDAgPyAzIC8gNCA6IDQgLyA5LFxuXHRcdFx0ZE1pbiA9IGZhY3RvciAqIE1hdGgubWluKDAsIGQxLCBkMiksXG5cdFx0XHRkTWF4ID0gZmFjdG9yICogTWF0aC5tYXgoMCwgZDEsIGQyKSxcblx0XHRcdGRwMCA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMF0sIHYxWzFdKSxcblx0XHRcdGRwMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMl0sIHYxWzNdKSxcblx0XHRcdGRwMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNF0sIHYxWzVdKSxcblx0XHRcdGRwMyA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNl0sIHYxWzddKSxcblx0XHRcdHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmO1xuXHRcdGlmIChxMHggPT09IHEzeCAmJiB1TWF4IC0gdU1pbiA8PSBodWxsRXBzaWxvbiAmJiByZWN1cnNpb24gPiAzKSB7XG5cdFx0XHR0TWluTmV3ID0gKHRNYXggKyB0TWluKSAvIDI7XG5cdFx0XHR0TWF4TmV3ID0gdE1pbk5ldztcblx0XHRcdHREaWZmID0gMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRcdGJvdHRvbSA9IGh1bGxbMV0sXG5cdFx0XHRcdHRNaW5DbGlwLCB0TWF4Q2xpcDtcblx0XHRcdHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0dG9wLnJldmVyc2UoKTtcblx0XHRcdGJvdHRvbS5yZXZlcnNlKCk7XG5cdFx0XHR0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcblx0XHRcdGlmICh0TWluQ2xpcCA9PSBudWxsIHx8IHRNYXhDbGlwID09IG51bGwpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHYxID0gQ3VydmUuZ2V0UGFydCh2MSwgdE1pbkNsaXAsIHRNYXhDbGlwKTtcblx0XHRcdHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcDtcblx0XHRcdHRNaW5OZXcgPSB0TWF4ICogdE1pbkNsaXAgKyB0TWluICogKDEgLSB0TWluQ2xpcCk7XG5cdFx0XHR0TWF4TmV3ID0gdE1heCAqIHRNYXhDbGlwICsgdE1pbiAqICgxIC0gdE1heENsaXApO1xuXHRcdH1cblx0XHRpZiAob2xkVERpZmYgPiAwLjggJiYgdERpZmYgPiAwLjgpIHtcblx0XHRcdGlmICh0TWF4TmV3IC0gdE1pbk5ldyA+IHVNYXggLSB1TWluKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHR0ID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0djIsIHBhcnRzWzFdLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcblx0XHRcdFx0XHR0ID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMF0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHQsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldykgPCB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciB0MSA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMixcblx0XHRcdFx0dDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZXZhbHVhdGUodjIsIHQyLCAwKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkaXN0MSA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAxIC8gMywgZHExKSxcblx0XHRcdGRpc3QyID0gZ2V0U2lnbmVkRGlzdGFuY2UoMCwgZHEwLCAxLCBkcTMsIDIgLyAzLCBkcTIpLFxuXHRcdFx0ZmxpcCA9IGZhbHNlLFxuXHRcdFx0aHVsbDtcblx0XHRpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcblx0XHRcdGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxIDwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBtYXgsIGNyb3NzID0gMCxcblx0XHRcdFx0ZGlzdFplcm8gPSBkaXN0MSA9PT0gMCB8fCBkaXN0MiA9PT0gMDtcblx0XHRcdGlmIChNYXRoLmFicyhkaXN0MSkgPiBNYXRoLmFicyhkaXN0MikpIHtcblx0XHRcdFx0cG1heCA9IHAxO1xuXHRcdFx0XHRjcm9zcyA9IChkcTMgLSBkcTIgLSAoZHEzIC0gZHEwKSAvIDMpXG5cdFx0XHRcdFx0XHQqICgyICogKGRxMyAtIGRxMikgLSBkcTMgKyBkcTEpIC8gMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBtYXggPSBwMjtcblx0XHRcdFx0Y3Jvc3MgPSAoZHExIC0gZHEwICsgKGRxMCAtIGRxMykgLyAzKVxuXHRcdFx0XHRcdFx0KiAoLTIgKiAoZHEwIC0gZHExKSArIGRxMCAtIGRxMikgLyAzO1xuXHRcdFx0fVxuXHRcdFx0aHVsbCA9IGNyb3NzIDwgMCB8fCBkaXN0WmVyb1xuXHRcdFx0XHRcdD8gW1twMCwgcG1heCwgcDNdLCBbcDAsIHAzXV1cblx0XHRcdFx0XHQ6IFtbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG5cdFx0XHRmbGlwID0gZGlzdDEgPyBkaXN0MSA8IDAgOiBkaXN0MiA8IDA7XG5cdFx0fVxuXHRcdHJldHVybiBmbGlwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdHZhciB0UHJveHksXG5cdFx0XHR0VmFsID0gbnVsbCxcblx0XHRcdHB4LCBweSxcblx0XHRcdHF4LCBxeTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGh1bGxCb3R0b20ubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0cHkgPSBodWxsQm90dG9tW2ldWzFdO1xuXHRcdFx0cXkgPSBodWxsQm90dG9tW2kgKyAxXVsxXTtcblx0XHRcdGlmIChweSA8IHF5KSB7XG5cdFx0XHRcdHRQcm94eSA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHF5IDw9IGRNYXgpIHtcblx0XHRcdFx0cHggPSBodWxsQm90dG9tW2ldWzBdO1xuXHRcdFx0XHRxeCA9IGh1bGxCb3R0b21baSArIDFdWzBdO1xuXHRcdFx0XHR0UHJveHkgPSBweCArIChkTWF4IC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKGh1bGxUb3BbMF1bMV0gPD0gZE1heClcblx0XHRcdHRQcm94eSA9IGh1bGxUb3BbMF1bMF07XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBodWxsVG9wLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHB5ID0gaHVsbFRvcFtpXVsxXTtcblx0XHRcdHF5ID0gaHVsbFRvcFtpICsgMV1bMV07XG5cdFx0XHRpZiAocHkgPj0gZE1pbikge1xuXHRcdFx0XHR0VmFsID0gdFByb3h5O1xuXHRcdFx0fSBlbHNlIGlmIChweSA+IHF5KSB7XG5cdFx0XHRcdHRWYWwgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmIChxeSA+PSBkTWluKSB7XG5cdFx0XHRcdHB4ID0gaHVsbFRvcFtpXVswXTtcblx0XHRcdFx0cXggPSBodWxsVG9wW2kgKyAxXVswXTtcblx0XHRcdFx0dFZhbCA9IHB4ICsgKGRNaW4gIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0cmV0dXJuIHRWYWw7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucyxcblx0XHRcdGluY2x1ZGUpIHtcblx0XHR2YXIgZmxpcCA9IEN1cnZlLmlzTGluZWFyKHYxKSxcblx0XHRcdHZjID0gZmxpcCA/IHYyIDogdjEsXG5cdFx0XHR2bCA9IGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0bHgxID0gdmxbMF0sIGx5MSA9IHZsWzFdLFxuXHRcdFx0bHgyID0gdmxbNl0sIGx5MiA9IHZsWzddLFxuXHRcdFx0bGR4ID0gbHgyIC0gbHgxLFxuXHRcdFx0bGR5ID0gbHkyIC0gbHkxLFxuXHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKC1sZHksIGxkeCksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRybHgyID0gbGR4ICogY29zIC0gbGR5ICogc2luLFxuXHRcdFx0cnZsID0gWzAsIDAsIDAsIDAsIHJseDIsIDAsIHJseDIsIDBdLFxuXHRcdFx0cnZjID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuXHRcdFx0dmFyIHggPSB2Y1tpXSAtIGx4MSxcblx0XHRcdFx0eSA9IHZjW2kgKyAxXSAtIGx5MTtcblx0XHRcdHJ2Yy5wdXNoKFxuXHRcdFx0XHR4ICogY29zIC0geSAqIHNpbixcblx0XHRcdFx0eSAqIGNvcyArIHggKiBzaW4pO1xuXHRcdH1cblx0XHR2YXIgcm9vdHMgPSBbXSxcblx0XHRcdGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyhydmMsIDEsIDAsIHJvb3RzLCAwLCAxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0YyA9IHJvb3RzW2ldLFxuXHRcdFx0XHR4ID0gQ3VydmUuZXZhbHVhdGUocnZjLCB0YywgMCkueDtcblx0XHRcdGlmICh4ID49IDAgJiYgeCA8PSBybHgyKSB7XG5cdFx0XHRcdHZhciB0bCA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHJ2bCwgeCwgMCksXG5cdFx0XHRcdFx0dDEgPSBmbGlwID8gdGwgOiB0Yyxcblx0XHRcdFx0XHR0MiA9IGZsaXAgPyB0YyA6IHRsO1xuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZXZhbHVhdGUodjIsIHQyLCAwKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHR2YXIgcG9pbnQgPSBMaW5lLmludGVyc2VjdChcblx0XHRcdFx0djFbMF0sIHYxWzFdLCB2MVs2XSwgdjFbN10sXG5cdFx0XHRcdHYyWzBdLCB2MlsxXSwgdjJbNl0sIHYyWzddKTtcblx0XHRpZiAocG9pbnQpIHtcblx0XHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0Y3VydmUxLCBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MSwgeCwgeSksIHBvaW50LFxuXHRcdFx0XHRcdGN1cnZlMiwgQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjIsIHgsIHkpLCBwb2ludCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXHRcdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdFx0dmFyIGxpbmVhcjEgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG5cdFx0XHRcdGxpbmVhcjIgPSBDdXJ2ZS5pc0xpbmVhcih2Mik7XG5cdFx0XHQobGluZWFyMSAmJiBsaW5lYXIyXG5cdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHQ6IGxpbmVhcjEgfHwgbGluZWFyMlxuXHRcdFx0XHRcdD8gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdDogYWRkQ3VydmVJbnRlcnNlY3Rpb25zKShcblx0XHRcdFx0XHRcdHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdDAsIDEsIDAsIDEsIDAsIGZhbHNlLCAwKTtcblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHBhcmFtZXRlciwgcG9pbnQsIF9jdXJ2ZTIsXG5cdFx0XHRfcGFyYW1ldGVyMiwgX3BvaW50MiwgX2Rpc3RhbmNlKSB7XG5cdFx0dGhpcy5faWQgPSBDdXJ2ZUxvY2F0aW9uLl9pZCA9IChDdXJ2ZUxvY2F0aW9uLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fY3VydmUgPSBjdXJ2ZTtcblx0XHR0aGlzLl9zZWdtZW50MSA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLl9jdXJ2ZTIgPSBfY3VydmUyO1xuXHRcdHRoaXMuX3BhcmFtZXRlcjIgPSBfcGFyYW1ldGVyMjtcblx0XHR0aGlzLl9wb2ludDIgPSBfcG9pbnQyO1xuXHRcdHRoaXMuX2Rpc3RhbmNlID0gX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQ6IGZ1bmN0aW9uKF9wcmVmZXJGaXJzdCkge1xuXHRcdGlmICghdGhpcy5fc2VnbWVudCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgX3ByZWZlckZpcnN0KSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKVxuXHRcdFx0XHRcdDwgY3VydmUuZ2V0UGFydExlbmd0aChwYXJhbWV0ZXIsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50O1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbihfdW5jYWNoZWQpIHtcblx0XHRpZiAoIXRoaXMuX2N1cnZlIHx8IF91bmNhY2hlZCkge1xuXHRcdFx0dGhpcy5fY3VydmUgPSB0aGlzLl9zZWdtZW50MS5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KSA9PSBudWxsKVxuXHRcdFx0XHR0aGlzLl9jdXJ2ZSA9IHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkuZ2V0Q3VydmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnZlO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGludGVyc2VjdGlvbiA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblx0XHRpZiAoIWludGVyc2VjdGlvbiAmJiB0aGlzLl9jdXJ2ZTIpIHtcblx0XHRcdHZhciBwYXJhbSA9IHRoaXMuX3BhcmFtZXRlcjI7XG5cdFx0XHR0aGlzLl9pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24gPSBuZXcgQ3VydmVMb2NhdGlvbihcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZTIsIHBhcmFtLCB0aGlzLl9wb2ludDIgfHwgdGhpcy5fcG9pbnQsIHRoaXMpO1xuXHRcdFx0aW50ZXJzZWN0aW9uLl9pbnRlcnNlY3Rpb24gPSB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGggPyBwYXRoLl9nZXRPZmZzZXQodGhpcykgOiB0aGlzLmdldEN1cnZlT2Zmc2V0KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICgodGhpcy5fcGFyYW1ldGVyID09IG51bGwgfHwgX3VuY2FjaGVkKSAmJiB0aGlzLl9wb2ludCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZShfdW5jYWNoZWQpO1xuXHRcdFx0dGhpcy5fcGFyYW1ldGVyID0gY3VydmUgJiYgY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcGFyYW1ldGVyO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfdW5jYWNoZWQpIHtcblx0XHRpZiAoKCF0aGlzLl9wb2ludCB8fCBfdW5jYWNoZWQpICYmIHRoaXMuX3BhcmFtZXRlciAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKF91bmNhY2hlZCk7XG5cdFx0XHR0aGlzLl9wb2ludCA9IGN1cnZlICYmIGN1cnZlLmdldFBvaW50QXQodGhpcy5fcGFyYW1ldGVyLCB0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzdGFuY2U7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKHRydWUpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5kaXZpZGUodGhpcy5nZXRQYXJhbWV0ZXIodHJ1ZSksIHRydWUpO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKHRydWUpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5zcGxpdCh0aGlzLmdldFBhcmFtZXRlcih0cnVlKSwgdHJ1ZSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gdGhpcyA9PT0gbG9jXG5cdFx0XHRcdHx8IGxvY1xuXHRcdFx0XHRcdCYmIHRoaXMuX2N1cnZlID09PSBsb2MuX2N1cnZlXG5cdFx0XHRcdFx0JiYgdGhpcy5fY3VydmUyID09PSBsb2MuX2N1cnZlMlxuXHRcdFx0XHRcdCYmIGlzWmVybyh0aGlzLl9wYXJhbWV0ZXIgLSBsb2MuX3BhcmFtZXRlcilcblx0XHRcdFx0XHQmJiBpc1plcm8odGhpcy5fcGFyYW1ldGVyMiAtIGxvYy5fcGFyYW1ldGVyMilcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdGlmIChwYXJhbWV0ZXIgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3BhcmFtZXRlcjogJyArIGYubnVtYmVyKHBhcmFtZXRlcikpO1xuXHRcdGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0ocGFyYW1ldGVyLCB0cnVlKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIF9tYXRyaXgsIF9leHBhbmQpIHtcblx0XHRpZiAodGhpcyA9PT0gcGF0aClcblx0XHRcdHBhdGggPSBudWxsO1xuXHRcdHZhciBsb2NhdGlvbnMgPSBbXSxcblx0XHRcdGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHBhdGggPyAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKVxuXHRcdFx0XHQ6IG1hdHJpeDEsXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gcGF0aCA/IGN1cnZlczIubGVuZ3RoIDogbGVuZ3RoMSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdE1JTiA9IDFlLTExLFxuXHRcdFx0TUFYID0gMSAtIDFlLTExO1xuXHRcdGlmIChwYXRoICYmICF0aGlzLmdldEJvdW5kcyhtYXRyaXgxKS50b3VjaGVzKHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpKSlcblx0XHRcdHJldHVybiBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKylcblx0XHRcdHZhbHVlczJbaV0gPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcyhtYXRyaXgyKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlMSA9IGN1cnZlczFbaV0sXG5cdFx0XHRcdHZhbHVlczEgPSBwYXRoID8gY3VydmUxLmdldFZhbHVlcyhtYXRyaXgxKSA6IHZhbHVlczJbaV07XG5cdFx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdFx0dmFyIHNlZzEgPSBjdXJ2ZTEuZ2V0U2VnbWVudDEoKSxcblx0XHRcdFx0XHRzZWcyID0gY3VydmUxLmdldFNlZ21lbnQyKCksXG5cdFx0XHRcdFx0aDEgPSBzZWcxLl9oYW5kbGVPdXQsXG5cdFx0XHRcdFx0aDIgPSBzZWcyLl9oYW5kbGVJbjtcblx0XHRcdFx0aWYgKG5ldyBMaW5lKHNlZzEuX3BvaW50LnN1YnRyYWN0KGgxKSwgaDEubXVsdGlwbHkoMiksIHRydWUpXG5cdFx0XHRcdFx0XHQuaW50ZXJzZWN0KG5ldyBMaW5lKHNlZzIuX3BvaW50LnN1YnRyYWN0KGgyKSxcblx0XHRcdFx0XHRcdGgyLm11bHRpcGx5KDIpLCB0cnVlKSwgZmFsc2UpKSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHZhbHVlczEpO1xuXHRcdFx0XHRcdEN1cnZlLmdldEludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRwYXJ0c1swXSwgcGFydHNbMV0sIGN1cnZlMSwgY3VydmUxLCBsb2NhdGlvbnMsXG5cdFx0XHRcdFx0XHRmdW5jdGlvbihsb2MpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxvYy5fcGFyYW1ldGVyIDw9IE1BWCkge1xuXHRcdFx0XHRcdFx0XHRcdGxvYy5fcGFyYW1ldGVyIC89IDI7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIyID0gMC41ICsgbG9jLl9wYXJhbWV0ZXIyIC8gMjtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGogPSBwYXRoID8gMCA6IGkgKyAxOyBqIDwgbGVuZ3RoMjsgaisrKSB7XG5cdFx0XHRcdEN1cnZlLmdldEludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0dmFsdWVzMSwgdmFsdWVzMltqXSwgY3VydmUxLCBjdXJ2ZXMyW2pdLCBsb2NhdGlvbnMsXG5cdFx0XHRcdFx0IXBhdGggJiYgKGogPT09IGkgKyAxIHx8IGogPT09IGxlbmd0aDIgLSAxICYmIGkgPT09IDApXG5cdFx0XHRcdFx0XHQmJiBmdW5jdGlvbihsb2MpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHQgPSBsb2MuX3BhcmFtZXRlcjtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHQgPj0gTUlOICYmIHQgPD0gTUFYO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgbGFzdCA9IGxvY2F0aW9ucy5sZW5ndGggLSAxO1xuXHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcblx0XHRcdFx0bmV4dCA9IGxvYy5fY3VydmUuZ2V0TmV4dCgpLFxuXHRcdFx0XHRuZXh0MiA9IGxvYy5fY3VydmUyLmdldE5leHQoKTtcblx0XHRcdGlmIChuZXh0ICYmIGxvYy5fcGFyYW1ldGVyID49IE1BWCkge1xuXHRcdFx0XHRsb2MuX3BhcmFtZXRlciA9IDA7XG5cdFx0XHRcdGxvYy5fY3VydmUgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5leHQyICYmIGxvYy5fcGFyYW1ldGVyMiA+PSBNQVgpIHtcblx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIyID0gMDtcblx0XHRcdFx0bG9jLl9jdXJ2ZTIgPSBuZXh0Mjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wYXJlKGxvYzEsIGxvYzIpIHtcblx0XHRcdHZhciBwYXRoMSA9IGxvYzEuZ2V0UGF0aCgpLFxuXHRcdFx0XHRwYXRoMiA9IGxvYzIuZ2V0UGF0aCgpO1xuXHRcdFx0cmV0dXJuIHBhdGgxID09PSBwYXRoMlxuXHRcdFx0XHRcdD8gKGxvYzEuZ2V0SW5kZXgoKSArIGxvYzEuZ2V0UGFyYW1ldGVyKCkpXG5cdFx0XHRcdFx0XHRcdC0gKGxvYzIuZ2V0SW5kZXgoKSArIGxvYzIuZ2V0UGFyYW1ldGVyKCkpXG5cdFx0XHRcdFx0OiBwYXRoMS5faWQgLSBwYXRoMi5faWQ7XG5cdFx0fVxuXG5cdFx0aWYgKGxhc3QgPiAwKSB7XG5cdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDE7IGktLSkge1xuXHRcdFx0XHRpZiAobG9jYXRpb25zW2ldLmVxdWFscyhsb2NhdGlvbnNbaSA9PT0gMCA/IGxhc3QgOiBpIC0gMV0pKSB7XG5cdFx0XHRcdFx0bG9jYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRsYXN0LS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKF9leHBhbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSlcblx0XHRcdFx0bG9jYXRpb25zLnB1c2gobG9jYXRpb25zW2ldLmdldEludGVyc2VjdGlvbigpKTtcblx0XHRcdGxvY2F0aW9ucy5zb3J0KGNvbXBhcmUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRQYXRoRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXG5cdFx0dmFyIHBhcnRzID0gZGF0YS5tYXRjaCgvW21saHZjc3F0YXpdW15tbGh2Y3NxdGF6XSovaWcpLFxuXHRcdFx0Y29vcmRzLFxuXHRcdFx0cmVsYXRpdmUgPSBmYWxzZSxcblx0XHRcdHByZXZpb3VzLFxuXHRcdFx0Y29udHJvbCxcblx0XHRcdGN1cnJlbnQgPSBuZXcgUG9pbnQoKSxcblx0XHRcdHN0YXJ0ID0gbmV3IFBvaW50KCk7XG5cblx0XHRmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcblx0XHRcdHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcblx0XHRcdGlmIChyZWxhdGl2ZSlcblx0XHRcdFx0dmFsICs9IGN1cnJlbnRbY29vcmRdO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQb2ludChpbmRleCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXgsICd4JyksXG5cdFx0XHRcdGdldENvb3JkKGluZGV4ICsgMSwgJ3knKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRbMF0sXG5cdFx0XHRcdGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG5cdFx0XHRyZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuXHRcdFx0aWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSlcblx0XHRcdFx0dGhpcy5tb3ZlVG8oY3VycmVudCA9IHN0YXJ0KTtcblx0XHRcdHN3aXRjaCAobG93ZXIpIHtcblx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHZhciBtb3ZlID0gbG93ZXIgPT09ICdtJztcblx0XHRcdFx0aWYgKG1vdmUgJiYgcHJldmlvdXMgJiYgcHJldmlvdXMgIT09ICd6Jylcblx0XHRcdFx0XHR0aGlzLmNsb3NlUGF0aCh0cnVlKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMilcblx0XHRcdFx0XHR0aGlzW2ogPT09IDAgJiYgbW92ZSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0aWYgKG1vdmUpXG5cdFx0XHRcdFx0c3RhcnQgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcblx0XHRcdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGogKyAyKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyA0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHQvW2NzXS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gKC9bcXRdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNykge1xuXHRcdFx0XHRcdHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSxcblx0XHRcdFx0XHRcdFx0bmV3IFNpemUoK2Nvb3Jkc1swXSwgK2Nvb3Jkc1sxXSksXG5cdFx0XHRcdFx0XHRcdCtjb29yZHNbMl0sICtjb29yZHNbNF0sICtjb29yZHNbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdHRoaXMuY2xvc2VQYXRoKHRydWUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgd2luZGluZyA9IHRoaXMuX2dldFdpbmRpbmcocG9pbnQsIGZhbHNlLCB0cnVlKTtcblx0XHRyZXR1cm4gISEodGhpcy5nZXRXaW5kaW5nUnVsZSgpID09PSAnZXZlbm9kZCcgPyB3aW5kaW5nICYgMSA6IHdpbmRpbmcpO1xuXHR9XG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJndW1lbnRzXG5cdFx0XHQ6IGFyZyAmJiAoYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0PyBhcmd1bWVudHNcblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSAwO1xuXHRcdFx0aWYgKCFzZWdtZW50cyAmJiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHRcdGFyZyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2luaXRpYWxpemUoIXNlZ21lbnRzICYmIGFyZyk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9zZWdtZW50cywgaXRlbS5fc2VnbWVudHMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFNlZ21lbnRzKHRoaXMuX3NlZ21lbnRzKTtcblx0XHRjb3B5Ll9jbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29weS5fY2xvY2t3aXNlID0gdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdGlmIChwYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY3VycmVudFBhdGggPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9jbG9ja3dpc2UgPSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAodGhpcy5fY3VydmVzICYmICEoZmxhZ3MgJiAxNikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tpXS5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbW9ub0N1cnZlcyA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKGZsYWdzICYgMzIpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0cmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cztcblx0fSxcblxuXHRzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCk7XG5cdFx0dGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKVxuXHRcdFx0dGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cykpO1xuXHRcdGlmIChmdWxseVNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRpZiAoIWN1cnZlcykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcblx0XHRcdFx0XHRzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0cmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHRpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdH1cblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0ZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Y3VyWCA9IGNvb3Jkc1swXTtcblx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0cGFydHMucHVzaCgnTScgKyBmLnBhaXIoY3VyWCwgY3VyWSkpO1xuXHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRpblkgPSBjb29yZHNbM107XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGlmICghc2tpcExpbmUpXG5cdFx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdsJyArIGYucGFpcihjdXJYIC0gcHJldlgsIGN1clkgLSBwcmV2WSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ2MnICsgZi5wYWlyKG91dFggLSBwcmV2WCwgb3V0WSAtIHByZXZZKVxuXHRcdFx0XHRcdFx0XHQrICcgJyArIGYucGFpcihpblggLSBwcmV2WCwgaW5ZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdH1cblxuXHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwKSB7XG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzWzBdLCB0cnVlKTtcblx0XHRcdHBhcnRzLnB1c2goJ3onKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuXHR9XG59LCB7XG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRpc1BvbHlnb246IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3NlZ21lbnRzW2ldLmlzTGluZWFyKCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCAwLCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHNlZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWdtZW50cy5zcGxpY2UuYXBwbHkoc2VnbWVudHMsIFtpbmRleCwgMF0uY29uY2F0KHNlZ3MpKTtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlcyB8fCBzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdGlmICghY3VydmVzKVxuXHRcdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBbXTtcblx0XHRcdHZhciBmcm9tID0gaW5kZXggPiAwID8gaW5kZXggLSAxIDogaW5kZXgsXG5cdFx0XHRcdHN0YXJ0ID0gZnJvbSxcblx0XHRcdFx0dG8gPSBNYXRoLm1pbihmcm9tICsgYW1vdW50LCB0aGlzLl9jb3VudEN1cnZlcygpKTtcblx0XHRcdGlmIChzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0Y3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtmcm9tLCAwXS5jb25jYXQoc2Vncy5fY3VydmVzKSk7XG5cdFx0XHRcdHN0YXJ0ICs9IHNlZ3MuX2N1cnZlcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCB0bzsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoZnJvbSwgdG8pO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y3VydmU7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG5cdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGN1cnZlLl9wYXRoID0gdGhpcztcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RoaXMuX2Nsb3NlZCAmJiBmcm9tID09PSAwID8gc2VnbWVudHMubGVuZ3RoIC0gMVxuXHRcdFx0XHQ6IGZyb20gLSAxXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbZnJvbV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdG9dKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1t0b107XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfY291bnRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuICF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbihzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydDogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzLCAxKSwgaW5kZXgpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cykpO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbihpbmRleCwgc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cyksIGluZGV4KTtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudHM6IGZ1bmN0aW9uKGZyb20sIHRvLCBfaW5jbHVkZUN1cnZlcykge1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50cy5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tKSxcblx0XHRcdGFtb3VudCA9IHJlbW92ZWQubGVuZ3RoO1xuXHRcdGlmICghYW1vdW50KVxuXHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSByZW1vdmVkW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUsIDApO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBzZWdtZW50Ll9wYXRoID0gbnVsbDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20sIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciBpbmRleCA9IGZyb20gPiAwICYmIHRvID09PSBjb3VudCArICh0aGlzLl9jbG9zZWQgPyAxIDogMClcblx0XHRcdFx0XHQ/IGZyb20gLSAxXG5cdFx0XHRcdFx0OiBmcm9tLFxuXHRcdFx0XHRjdXJ2ZXMgPSBjdXJ2ZXMuc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXHRcdFx0aWYgKF9pbmNsdWRlQ3VydmVzKVxuXHRcdFx0XHRyZW1vdmVkLl9jdXJ2ZXMgPSBjdXJ2ZXMuc2xpY2UoMSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoaW5kZXgsIGluZGV4KTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlU2VnbWVudHMnLFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2xlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0dmFyIGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGFyZWEgKz0gY3VydmVzW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fSxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkICYmIGxlbmd0aCA+IDAgJiYgdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGVcblx0XHRcdFx0PT09IGxlbmd0aCAqIDc7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24gc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcblx0XHRpZiAoIXNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHMoZmFsc2UpO1xuXHRcdHNldFNlbGVjdGVkLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHQ/IGxlbmd0aCAqIDcgOiAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fc2VsZWN0aW9uU3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHRcdD8gNyA6IDA7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oc2VnbWVudCwgb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG5cdFx0c2VnbWVudC5fc2VsZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcblx0XHR2YXIgdG90YWwgPSB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSArPSBuZXdTdGF0ZSAtIG9sZFN0YXRlO1xuXHRcdGlmICh0b3RhbCA+IDApXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGZsYXR0ZW46IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dmFyIGl0ZXJhdG9yID0gbmV3IFBhdGhJdGVyYXRvcih0aGlzLCA2NCwgMC4xKSxcblx0XHRcdHBvcyA9IDAsXG5cdFx0XHRzdGVwID0gaXRlcmF0b3IubGVuZ3RoIC8gTWF0aC5jZWlsKGl0ZXJhdG9yLmxlbmd0aCAvIG1heERpc3RhbmNlKSxcblx0XHRcdGVuZCA9IGl0ZXJhdG9yLmxlbmd0aCArICh0aGlzLl9jbG9zZWQgPyAtc3RlcCA6IHN0ZXApIC8gMjtcblx0XHR2YXIgc2VnbWVudHMgPSBbXTtcblx0XHR3aGlsZSAocG9zIDw9IGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChpdGVyYXRvci5ldmFsdWF0ZShwb3MsIDApKSk7XG5cdFx0XHRwb3MgKz0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoY3VydmUuaXNMaW5lYXIoKSAmJiBjdXJ2ZS5nZXRMZW5ndGgoKSA9PT0gMClcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRpZiAodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIGZpdHRlciA9IG5ldyBQYXRoRml0dGVyKHRoaXMsIHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhmaXR0ZXIuZml0KCkpO1xuXHRcdH1cblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHBhcmFtZXRlcikge1xuXHRcdGlmIChwYXJhbWV0ZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBhcmcgPSBpbmRleDtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJylcblx0XHRcdFx0YXJnID0gdGhpcy5nZXRMb2NhdGlvbkF0KGFyZyk7XG5cdFx0XHRpbmRleCA9IGFyZy5pbmRleDtcblx0XHRcdHBhcmFtZXRlciA9IGFyZy5wYXJhbWV0ZXI7XG5cdFx0fVxuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAxO1xuXHRcdGlmIChwYXJhbWV0ZXIgPj0gMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0aW5kZXgrKztcblx0XHRcdHBhcmFtZXRlci0tO1xuXHRcdH1cblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGN1cnZlcy5sZW5ndGgpIHtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UpIHtcblx0XHRcdFx0Y3VydmVzW2luZGV4KytdLmRpdmlkZShwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuXHRcdFx0XHRwYXRoO1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb3NlZChmYWxzZSk7XG5cdFx0XHRcdHBhdGggPSB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0cGF0aCA9IHRoaXMuX2Nsb25lKG5ldyBQYXRoKCkuaW5zZXJ0QWJvdmUodGhpcywgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdFx0cGF0aC5fYWRkKHNlZ3MsIDApO1xuXHRcdFx0dGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHJldHVybiBQYXRoLmlzQ2xvY2t3aXNlKHRoaXMuX3NlZ21lbnRzKTtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHRcdHRoaXMuX2Nsb2Nrd2lzZSA9IGNsb2Nrd2lzZTtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50cy5yZXZlcnNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZUluID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0c2VnbWVudC5faGFuZGxlT3V0ID0gaGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnZlcyA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5fY2xvY2t3aXNlID0gIXRoaXMuX2Nsb2Nrd2lzZTtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGpvaW46IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRcdGxhc3QxID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpLFxuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdGlmIChsYXN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpXG5cdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0dmFyIGZpcnN0MSxcblx0XHRcdFx0Zmlyc3QyID0gcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdGlmIChsYXN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG5cdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpXG5cdFx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxLl9wb2ludC5lcXVhbHMobGFzdDIuX3BvaW50KSkge1xuXHRcdFx0XHRcdGZpcnN0MS5zZXRIYW5kbGVJbihsYXN0Mi5faGFuZGxlSW4pO1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKSwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aC5jbG9zZWQpXG5cdFx0XHRcdHRoaXMuX2FkZChbc2VnbWVudHNbMF1dKTtcblx0XHRcdHBhdGgucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRsYXN0ID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdGlmIChmaXJzdCAhPT0gbGFzdCAmJiBmaXJzdC5fcG9pbnQuZXF1YWxzKGxhc3QuX3BvaW50KSkge1xuXHRcdFx0Zmlyc3Quc2V0SGFuZGxlSW4obGFzdC5faGFuZGxlSW4pO1xuXHRcdFx0bGFzdC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdH1cblx0fSxcblxuXHR0b1NoYXBlOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRpZiAoIXRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHJhZGl1cyxcblx0XHRcdHRvcENlbnRlcjtcblxuXHRcdGZ1bmN0aW9uIGlzQ29saW5lYXIoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQ29saW5lYXIoc2VnbWVudHNbal0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNPcnRob2dvbmFsKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNBcmMoaSkge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQXJjKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUG9seWdvbigpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0NvbGluZWFyKDAsIDIpICYmIGlzQ29saW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29saW5lYXIoMSwgNSkgJiYgaXNDb2xpbmVhcigzLCA3KSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuXHRcdFx0cmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSxcblx0XHRcdFx0XHRnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5DaXJjbGU7XG5cdFx0XHRcdHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuXHRcdFx0XHRyYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRzaGFwZSA9IG5ldyB0eXBlKHtcblx0XHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdHNoYXBlLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHNoYXBlLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0am9pbiwgY2FwLCBtaXRlckxpbWl0LFxuXHRcdFx0YXJlYSwgbG9jLCByZXMsXG5cdFx0XHRoaXRTdHJva2UgPSBvcHRpb25zLnN0cm9rZSAmJiBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGhpdEZpbGwgPSBvcHRpb25zLmZpbGwgJiYgc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGl0Q3VydmVzID0gb3B0aW9ucy5jdXJ2ZXMsXG5cdFx0XHRyYWRpdXMgPSBoaXRTdHJva2Vcblx0XHRcdFx0XHQ/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyXG5cdFx0XHRcdFx0OiBoaXRGaWxsICYmIG9wdGlvbnMudG9sZXJhbmNlID4gMCB8fCBoaXRDdXJ2ZXNcblx0XHRcdFx0XHRcdD8gMCA6IG51bGw7XG5cdFx0aWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKHJhZGl1cyA+IDApIHtcblx0XHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKTtcblx0XHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCk7XG5cdFx0XHRcdG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLmFkZChuZXcgUG9pbnQocmFkaXVzLCByYWRpdXMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpvaW4gPSBjYXAgPSAncm91bmQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcblx0XHRcdHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcblx0XHRcdGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG5cdFx0XHRcdGlmIChwdCAhPT0gYW5jaG9yKVxuXHRcdFx0XHRcdHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cdFx0XHRcdGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQ6IHNlZyxcblx0XHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuXHRcdFx0cmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG5cdFx0XHRcdCYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKVxuXHRcdFx0XHR8fCAoIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzKSAmJiAoXG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHxcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcblx0XHRcdGFyZWEuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuXHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgfHwgY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdGFyZWEgPSBuZXcgUGF0aCh7IGludGVybmFsOiB0cnVlLCBjbG9zZWQ6IHRydWUgfSk7XG5cdFx0XHRcdGlmIChjbG9zZWQgfHwgc2VnbWVudC5faW5kZXggPiAwXG5cdFx0XHRcdFx0XHQmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdGlmIChqb2luICE9PSAncm91bmQnICYmIChzZWdtZW50Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdFx0XHR8fCBzZWdtZW50Ll9oYW5kbGVPdXQuaXNaZXJvKCkpKVxuXHRcdFx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCxcblx0XHRcdFx0XHRcdFx0XHRhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0dmFyIGxvYztcblx0XHRcdFx0XHRyZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcblx0XHRcdFx0XHRcdHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXNDbG9zZUVub3VnaChzZWdtZW50Ll9wb2ludCwgc3Ryb2tlUGFkZGluZyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG5cdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuXHRcdFx0XHRcdHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspXG5cdFx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IGxvYy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMCB8fCBwYXJhbWV0ZXIgPT09IDEgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGVja1NlZ21lbnRTdHJva2UobG9jLmdldFNlZ21lbnQoKSkpXG5cdFx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbG9jICYmIGpvaW4gPT09ICdtaXRlcicgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmdldERpc3RhbmNlKHNlZ21lbnQuX3BvaW50KSA8PSBtaXRlckxpbWl0XG5cdFx0XHRcdFx0XHRcdCYmIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSkge1xuXHRcdFx0XHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhbG9jICYmIGhpdEZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdHx8IGxvYyAmJiAhaGl0U3Ryb2tlICYmICFoaXRDdXJ2ZXNcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKVxuXHRcdFx0XHRcdDogbG9jXG5cdFx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoaGl0U3Ryb2tlID8gJ3N0cm9rZScgOiAnY3VydmUnLCB0aGlzLCB7XG5cdFx0XHRcdFx0XHRcdGxvY2F0aW9uOiBsb2MsXG5cdFx0XHRcdFx0XHRcdHBvaW50OiBsb2MuZ2V0UG9pbnQoKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdDogbnVsbDtcblx0fVxuXG59LCBCYXNlLmVhY2goWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQsIGlzUGFyYW1ldGVyKTtcblx0XHRcdHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdF9nZXRPZmZzZXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGluZGV4ID0gbG9jYXRpb24gJiYgbG9jYXRpb24uZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaW5kZXhdLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBsb2NhdGlvbi5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiAwKVxuXHRcdFx0XHRvZmZzZXQgKz0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0aWYgKGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgaW5kZXggPSB+fm9mZnNldDtcblx0XHRcdHJldHVybiBjdXJ2ZXNbaW5kZXhdLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gaW5kZXgsIHRydWUpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdGFydCA9IGxlbmd0aCxcblx0XHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAobGVuZ3RoID4gb2Zmc2V0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIHN0YXJ0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG9mZnNldCA8PSB0aGlzLmdldExlbmd0aCgpKVxuXHRcdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0sIDEpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pbkxvYyA9IG51bGw7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jLl9kaXN0YW5jZSA8IG1pbkRpc3QpIHtcblx0XHRcdFx0bWluRGlzdCA9IGxvYy5fZGlzdGFuY2U7XG5cdFx0XHRcdG1pbkxvYyA9IGxvYztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1pbkxvYztcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cbn0pLCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdFx0cFggPSBjb29yZHNbMF0sXG5cdFx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHN0YXRlICYgMSlcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzdGF0ZSAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKCEoc3RhdGUgJiA0KSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG5cdFx0XHRcdGN1clggPSBwb2ludC5feDtcblx0XHRcdFx0Y3VyWSA9IHBvaW50Ll95O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRcdFx0aW5YID0gY3VyWCArIGhhbmRsZS5feDtcblx0XHRcdFx0XHRpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ob3V0WCwgb3V0WSwgaW5YLCBpblksIGN1clgsIGN1clkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2WCA9IGN1clg7XG5cdFx0XHRwcmV2WSA9IGN1clk7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0XHRvdXRYID0gcHJldlggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdG91dFkgPSBwcmV2WSArIGhhbmRsZS5feTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMClcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzWzBdKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0dmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcblx0XHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2Vcblx0XHRcdFx0XHRcdCYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydCAmJiB0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG5cdFx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcblx0XHRcdFx0cmV0dXJuIGRhc2hBcnJheVsoKGkgJSBkYXNoTGVuZ3RoKSArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNTdHJva2UpIHtcblx0XHRcdFx0XHRpZiAoZGFzaExlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgMzIsIDAuMjUsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gaXRlcmF0b3IubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IuZHJhd1BhcnQoY3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblx0XHR2YXIgbiA9IHJocy5sZW5ndGgsXG5cdFx0XHR4ID0gW10sXG5cdFx0XHR0bXAgPSBbXSxcblx0XHRcdGIgPSAyO1xuXHRcdHhbMF0gPSByaHNbMF0gLyBiO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR0bXBbaV0gPSAxIC8gYjtcblx0XHRcdGIgPSAoaSA8IG4gLSAxID8gNCA6IDIpIC0gdG1wW2ldO1xuXHRcdFx0eFtpXSA9IChyaHNbaV0gLSB4W2kgLSAxXSkgLyBiO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0eFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHg7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0c2l6ZSA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0XHRuID0gc2l6ZSxcblx0XHRcdFx0b3ZlcmxhcCA9IDA7XG5cdFx0XHRpZiAoc2l6ZSA8PSAyKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdG92ZXJsYXAgPSBNYXRoLm1pbihzaXplLCA0KTtcblx0XHRcdFx0biArPSBNYXRoLm1pbihzaXplLCBvdmVybGFwKSAqIDI7XG5cdFx0XHR9XG5cdFx0XHR2YXIga25vdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKVxuXHRcdFx0XHRrbm90c1tpICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdFx0a25vdHNbaV0gPSBzZWdtZW50c1tpICsgc2l6ZSAtIG92ZXJsYXBdLl9wb2ludDtcblx0XHRcdFx0XHRrbm90c1tpICsgc2l6ZSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmhzID0gW107XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl94ICsgMiAqIGtub3RzW2kgKyAxXS5feDtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3g7XG5cdFx0XHR2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feSArIDIgKiBrbm90c1tpICsgMV0uX3k7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feSArIDIgKiBrbm90c1sxXS5feTtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl95O1xuXHRcdFx0dmFyIHkgPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IHNpemU7IGkgPCBvdmVybGFwOyBpKyssIGorKykge1xuXHRcdFx0XHRcdHZhciBmMSA9IGkgLyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0ZjIgPSAxIC0gZjEsXG5cdFx0XHRcdFx0XHRpZSA9IGkgKyBvdmVybGFwLFxuXHRcdFx0XHRcdFx0amUgPSBqICsgb3ZlcmxhcDtcblx0XHRcdFx0XHR4W2pdID0geFtpXSAqIGYxICsgeFtqXSAqIGYyO1xuXHRcdFx0XHRcdHlbal0gPSB5W2ldICogZjEgKyB5W2pdICogZjI7XG5cdFx0XHRcdFx0eFtqZV0gPSB4W2llXSAqIGYyICsgeFtqZV0gKiBmMTtcblx0XHRcdFx0XHR5W2plXSA9IHlbaWVdICogZjIgKyB5W2plXSAqIGYxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVJbiA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcDsgaSA8PSBuIC0gb3ZlcmxhcDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaSAtIG92ZXJsYXBdO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pXG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRpZiAoaSA8IG4pIHtcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZU91dChcblx0XHRcdFx0XHRcdFx0bmV3IFBvaW50KHhbaV0sIHlbaV0pLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBpIDwgbiAtIDFcblx0XHRcdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feCAtIHhbaSArIDFdLFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3kgLSB5W2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0OiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl94ICsgeFtuIC0gMV0pIC8gMixcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3kgKyB5W24gLSAxXSkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNsb3NlZCAmJiBoYW5kbGVJbikge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0aHJvdWdoLFxuXHRcdFx0XHRwZWVrID0gQmFzZS5wZWVrKGFyZ3VtZW50cyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3VtZW50cykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0RVBTSUxPTiA9IDFlLTExLFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0gIHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9ICB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IE1hdGguc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgRVBTSUxPTilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG5cdFx0XHRcdFx0XHRcdCogTWF0aC5zcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWF0aC5hYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbChleHQgLyA5MCksXG5cdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzKTtcblx0XHR9LFxuXG5cdFx0bGluZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGN1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLFxuXHRcdFx0XHRcdGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0YXJjQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmd1bWVudHMpLCB0cnVlKTtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY2xvY2t3aXNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0aWYgKGpvaW4pXG5cdFx0XHRcdHRoaXMuam9pbigpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRtYXRyaXgpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBzdW0gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdiA9IEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRzZWdtZW50c1tpXSwgc2VnbWVudHNbaSArIDEgPCBsID8gaSArIDEgOiAwXSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMjsgaiA8IDg7IGogKz0gMilcblx0XHRcdFx0c3VtICs9ICh2W2ogLSAyXSAtIHZbal0pICogKHZbaiArIDFdICsgdltqIC0gMV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3VtID4gMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgZmFsc2UpLFxuXHRcdFx0bWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0Q3VydmUuX2FkZEJvdW5kcyhcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2ldLFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaSArIDRdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpICsgMl0sXG5cdFx0XHRcdFx0Y29vcmRzW2ldLFxuXHRcdFx0XHRcdGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRcdH1cblx0XHRcdHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuXHRcdFx0cHJldkNvb3JkcyA9IGNvb3Jkcztcblx0XHRcdGNvb3JkcyA9IHRtcDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0Z2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0aWYgKCFzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdHJldHVybiBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KTtcblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKSxcblx0XHRcdHJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuXHRcdFx0cGFkZGluZyA9IFBhdGguX2dldFBlblBhZGRpbmcocmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0Ym91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgcGFkZGluZyksXG5cdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdHZhciBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShwYWRkaW5nKS5tdWx0aXBseSgyKSk7XG5cblx0XHRmdW5jdGlvbiBhZGQocG9pbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50KSA6IHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMudW5pdGUoam9pbkJvdW5kcy5zZXRDZW50ZXIobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChzZWdtZW50Ll9wb2ludCkgOiBzZWdtZW50Ll9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW4sXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdGlmIChqb2luID09PSAncm91bmQnIHx8ICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xpbmVhcihoYW5kbGVPdXQpKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcblx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0UGVuUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBteCA9IG1hdHJpeC5zaGlmdGxlc3MoKSxcblx0XHRcdGhvciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQocmFkaXVzLCAwKSksXG5cdFx0XHR2ZXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KDAsIHJhZGl1cykpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSAtTWF0aC5hdGFuKGIgKiB0YW4gLyBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuKGIgLyAodGFuICogYSkpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyAtIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgY3VydmUyID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuXHRcdFx0Y3VydmUxID0gY3VydmUyLmdldFByZXZpb3VzKCksXG5cdFx0XHRwb2ludCA9IGN1cnZlMi5nZXRQb2ludEF0KDAsIHRydWUpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdCgxLCB0cnVlKSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXQoMCwgdHJ1ZSksXG5cdFx0XHRzdGVwID0gbm9ybWFsMS5nZXREaXJlY3RlZEFuZ2xlKG5vcm1hbDIpIDwgMCA/IC1yYWRpdXMgOiByYWRpdXM7XG5cdFx0bm9ybWFsMS5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0bm9ybWFsMi5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50KTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0fVxuXHRcdGlmIChqb2luID09PSAnbWl0ZXInKSB7XG5cdFx0XHR2YXIgY29ybmVyID0gbmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDEpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlXG5cdFx0XHRcdCkuaW50ZXJzZWN0KG5ldyBMaW5lKFxuXHRcdFx0XHRcdHBvaW50LmFkZChub3JtYWwyKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuXHRcdFx0XHQpLCB0cnVlKTtcblx0XHRcdGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0KSB7XG5cdFx0XHRcdGFkZFBvaW50KGNvcm5lcik7XG5cdFx0XHRcdGlmICghYXJlYSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghYXJlYSlcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcblx0fSxcblxuXHRfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbihzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5ub3JtYWxpemUocmFkaXVzKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0fVxuXHRcdGlmIChjYXAgPT09ICdzcXVhcmUnKVxuXHRcdFx0cG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZShsb2MuZ2V0UGFyYW1ldGVyKCkgPT09IDAgPyAtOTAgOiA5MCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRqb2luUGFkZGluZykge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHR4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuXHRcdFx0XHR2YXIgcGFkZGluZyA9IGogPT09IDAgPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0Z2V0Um91Z2hCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG5cdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXHRcdGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguc3FydCgyKSk7XG5cdFx0fVxuXHRcdHJldHVybiBQYXRoLmdldEhhbmRsZUJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKHN0cm9rZVJhZGl1cywgbWF0cml4KSxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhqb2luUmFkaXVzLCBtYXRyaXgpKTtcblx0fVxufX0pO1xuXG5QYXRoLmluamVjdCh7IHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0ZWxsaXBzZVNlZ21lbnRzID0gW1xuXHRcdFx0bmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhIF0sIFswLCAta2FwcGFdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDAgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGEgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMCBdLCBbLWthcHBhLCAwXSlcblx0XHRdO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChbXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSAhKHNpZGVzICUgMyksXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0U3RhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMxJyksXG5cdFx0XHRcdHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0aXRlbXMgPSBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIFBhdGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gIV9wcmVzZXJ2ZSAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoaXRlbS5fY2xvY2t3aXNlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0uc2V0Q2xvY2t3aXNlKGl0ZW0uX2luZGV4ID09PSAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0ucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5zbW9vdGgoKTtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGNoaWxkICYmIGNoaWxkLmlzQ2xvY2t3aXNlKCk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuXHRcdFx0XHRcdD8gX21hdHJpeC5jaGFpbihteCkgOiBteCwgX3ByZWNpc2lvbikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHMuam9pbignICcpO1xuXHR9XG59LCB7XG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCdcblx0XHRcdFx0PyBvcHRpb25zXG5cdFx0XHRcdDogbmV3IEJhc2Uob3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgZG9udFN0YXJ0OiB0cnVlLCBkb250RmluaXNoOiB0cnVlIH0pO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLmRyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0ZWRJdGVtcykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0aWYgKCFzZWxlY3RlZEl0ZW1zW2NoaWxkLl9pZF0pXG5cdFx0XHRcdGNoaWxkLl9kcmF3U2VsZWN0ZWQoY3R4LCBteC5pc0lkZW50aXR5KCkgPyBtYXRyaXhcblx0XHRcdFx0XHRcdDogbWF0cml4LmNoYWluKG14KSk7XG5cdFx0fVxuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHZhciBmaWVsZHMgPSB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudCA6IG5ldyBQYXRoKCk7XG5cdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKGpvaW4pO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG5cdFx0XHQnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcblx0XHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRmaWVsZHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn0pO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdG9yLCBzdWJ0cmFjdCkge1xuXHRcdGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLmNsb25lKGZhbHNlKS5yZWR1Y2UoKS5yZW9yaWVudCgpLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHR9XG5cblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuXHRcdFx0X3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyKTtcblx0XHRpZiAoIV9wYXRoMS5pc0Nsb2Nrd2lzZSgpKVxuXHRcdFx0X3BhdGgxLnJldmVyc2UoKTtcblx0XHRpZiAoX3BhdGgyICYmICEoc3VidHJhY3QgXiBfcGF0aDIuaXNDbG9ja3dpc2UoKSkpXG5cdFx0XHRfcGF0aDIucmV2ZXJzZSgpO1xuXHRcdHNwbGl0UGF0aChfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIG51bGwsIHRydWUpKTtcblxuXHRcdHZhciBjaGFpbiA9IFtdLFxuXHRcdFx0d2luZGluZ3MgPSBbXSxcblx0XHRcdGxlbmd0aHMgPSBbXSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0KHBhdGhzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHBhdGhzW2ldO1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBwYXRoLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbGxlY3QoX3BhdGgxLl9jaGlsZHJlbiB8fCBbX3BhdGgxXSk7XG5cdFx0aWYgKF9wYXRoMilcblx0XHRcdGNvbGxlY3QoX3BhdGgyLl9jaGlsZHJlbiB8fCBbX3BhdGgyXSk7XG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgX2EgPSBhLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdF9iID0gYi5faW50ZXJzZWN0aW9uO1xuXHRcdFx0cmV0dXJuICFfYSAmJiAhX2IgfHwgX2EgJiYgX2IgPyAwIDogX2EgPyAtMSA6IDE7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fd2luZGluZyAhPSBudWxsKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGNoYWluLmxlbmd0aCA9IHdpbmRpbmdzLmxlbmd0aCA9IGxlbmd0aHMubGVuZ3RoID0gMDtcblx0XHRcdHZhciB0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHRcdHN0YXJ0U2VnID0gc2VnbWVudDtcblx0XHRcdGRvIHtcblx0XHRcdFx0Y2hhaW4ucHVzaChzZWdtZW50KTtcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKHRvdGFsTGVuZ3RoICs9IHNlZ21lbnQuZ2V0Q3VydmUoKS5nZXRMZW5ndGgoKSk7XG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHRcdH0gd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuX2ludGVyc2VjdGlvbiAmJiBzZWdtZW50ICE9PSBzdGFydFNlZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdG90YWxMZW5ndGggKiBNYXRoLnJhbmRvbSgpLFxuXHRcdFx0XHRcdGFtb3VudCA9IGxlbmd0aHMubGVuZ3RoLFxuXHRcdFx0XHRcdGsgPSAwO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aHNba10gPj0gbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoayA+IDApXG5cdFx0XHRcdFx0XHRcdGxlbmd0aCAtPSBsZW5ndGhzW2sgLSAxXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoKytrIDwgYW1vdW50KTtcblx0XHRcdFx0dmFyIGN1cnZlID0gY2hhaW5ba10uZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRwb2ludCA9IGN1cnZlLmdldFBvaW50QXQobGVuZ3RoKSxcblx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0hvcml6b250YWwoKSxcblx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0XHRcdGlmIChwYXRoLl9wYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRcdFx0cGF0aCA9IHBhdGguX3BhcmVudDtcblx0XHRcdFx0d2luZGluZ3Nbal0gPSBzdWJ0cmFjdCAmJiBfcGF0aDJcblx0XHRcdFx0XHRcdCYmIChwYXRoID09PSBfcGF0aDEgJiYgX3BhdGgyLl9nZXRXaW5kaW5nKHBvaW50LCBob3IpXG5cdFx0XHRcdFx0XHR8fCBwYXRoID09PSBfcGF0aDIgJiYgIV9wYXRoMS5fZ2V0V2luZGluZyhwb2ludCwgaG9yKSlcblx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0OiBnZXRXaW5kaW5nKHBvaW50LCBtb25vQ3VydmVzLCBob3IpO1xuXHRcdFx0fVxuXHRcdFx0d2luZGluZ3Muc29ydCgpO1xuXHRcdFx0dmFyIHdpbmRpbmcgPSB3aW5kaW5nc1sxXTtcblx0XHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdFx0Y2hhaW5bal0uX3dpbmRpbmcgPSB3aW5kaW5nO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gbmV3IENvbXBvdW5kUGF0aCgpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbih0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvciksIHRydWUpO1xuXHRcdF9wYXRoMS5yZW1vdmUoKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0X3BhdGgyLnJlbW92ZSgpO1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZWR1Y2UoKTtcblx0XHRyZXN1bHQuc2V0U3R5bGUocGF0aDEuX3N0eWxlKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gc3BsaXRQYXRoKGludGVyc2VjdGlvbnMpIHtcblx0XHR2YXIgVE9MRVJBTkNFID0gMC4wMDAwMSxcblx0XHRcdGxpbmVhclNlZ21lbnRzO1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRMaW5lYXIoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVhclNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IGxpbmVhclNlZ21lbnRzW2ldO1xuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVJbi5zZXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMSwgY3VydmUsIHByZXZMb2M7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gaW50ZXJzZWN0aW9uc1tpXSxcblx0XHRcdFx0dCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0aWYgKHByZXZMb2MgJiYgcHJldkxvYy5fY3VydmUgPT09IGxvYy5fY3VydmVcblx0XHRcdFx0XHQmJiBwcmV2TG9jLl9wYXJhbWV0ZXIgPiAwKSB7XG5cdFx0XHRcdHQgLz0gcHJldkxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGxpbmVhclNlZ21lbnRzKVxuXHRcdFx0XHRcdHJlc2V0TGluZWFyKCk7XG5cdFx0XHRcdGN1cnZlID0gbG9jLl9jdXJ2ZTtcblx0XHRcdFx0bGluZWFyU2VnbWVudHMgPSBjdXJ2ZS5pc0xpbmVhcigpICYmIFtdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5ld0N1cnZlLFxuXHRcdFx0XHRzZWdtZW50O1xuXHRcdFx0aWYgKG5ld0N1cnZlID0gY3VydmUuZGl2aWRlKHQsIHRydWUsIHRydWUpKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBuZXdDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdGN1cnZlID0gbmV3Q3VydmUuZ2V0UHJldmlvdXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQgPSB0IDwgVE9MRVJBTkNFXG5cdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHQ6IHQgPiAxIC0gVE9MRVJBTkNFXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MlxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHQpIDwgY3VydmUuZ2V0UGFydExlbmd0aCh0LCAxKVxuXHRcdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0XHQ6IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH1cblx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGxvYy5nZXRJbnRlcnNlY3Rpb24oKTtcblx0XHRcdGxvYy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0XHRpZiAobGluZWFyU2VnbWVudHMpXG5cdFx0XHRcdGxpbmVhclNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0XHRwcmV2TG9jID0gbG9jO1xuXHRcdH1cblx0XHRpZiAobGluZWFyU2VnbWVudHMpXG5cdFx0XHRyZXNldExpbmVhcigpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHR2YXIgVE9MRVJBTkNFID0gMC4wMDAwMSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHR3aW5kTGVmdCA9IDAsXG5cdFx0XHR3aW5kUmlnaHQgPSAwLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0TUFYID0gMSAtIFRPTEVSQU5DRTtcblx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0dmFyIHlUb3AgPSAtSW5maW5pdHksXG5cdFx0XHRcdHlCb3R0b20gPSBJbmZpbml0eSxcblx0XHRcdFx0eUJlZm9yZSA9IHkgLSBUT0xFUkFOQ0UsXG5cdFx0XHRcdHlBZnRlciA9IHkgKyBUT0xFUkFOQ0U7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG5cdFx0XHRcdGlmIChDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMCwgeCwgcm9vdHMsIDAsIDEpID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSByb290cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdFx0dmFyIHkwID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCByb290c1tqXSwgMCkueTtcblx0XHRcdFx0XHRcdGlmICh5MCA8IHlCZWZvcmUgJiYgeTAgPiB5VG9wKSB7XG5cdFx0XHRcdFx0XHRcdHlUb3AgPSB5MDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeTAgPiB5QWZ0ZXIgJiYgeTAgPCB5Qm90dG9tKSB7XG5cdFx0XHRcdFx0XHRcdHlCb3R0b20gPSB5MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHlUb3AgPSAoeVRvcCArIHkpIC8gMjtcblx0XHRcdHlCb3R0b20gPSAoeUJvdHRvbSArIHkpIC8gMjtcblx0XHRcdGlmICh5VG9wID4gLUluZmluaXR5KVxuXHRcdFx0XHR3aW5kTGVmdCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHgsIHlUb3ApLCBjdXJ2ZXMpO1xuXHRcdFx0aWYgKHlCb3R0b20gPCBJbmZpbml0eSlcblx0XHRcdFx0d2luZFJpZ2h0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQoeCwgeUJvdHRvbSksIGN1cnZlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB4QmVmb3JlID0geCAtIFRPTEVSQU5DRSxcblx0XHRcdFx0eEFmdGVyID0geCArIFRPTEVSQU5DRTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0dmFsdWVzID0gY3VydmUudmFsdWVzLFxuXHRcdFx0XHRcdHdpbmRpbmcgPSBjdXJ2ZS53aW5kaW5nLFxuXHRcdFx0XHRcdG5leHQgPSBjdXJ2ZS5uZXh0O1xuXHRcdFx0XHRpZiAod2luZGluZyAmJiAod2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCB5LCByb290cywgMCxcblx0XHRcdFx0XHRcdCFuZXh0LndpbmRpbmcgJiYgbmV4dC52YWx1ZXNbMV0gPT09IHkgPyAxIDogTUFYKSA9PT0gMSl7XG5cdFx0XHRcdFx0dmFyIHQgPSByb290c1swXSxcblx0XHRcdFx0XHRcdHgwID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAwKS54LFxuXHRcdFx0XHRcdFx0c2xvcGUgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDEpLnk7XG5cdFx0XHRcdFx0aWYgKGFicyhzbG9wZSkgPCBUT0xFUkFOQ0UgJiYgIUN1cnZlLmlzTGluZWFyKHZhbHVlcylcblx0XHRcdFx0XHRcdFx0fHwgdCA8IFRPTEVSQU5DRSAmJiBzbG9wZSAqIEN1cnZlLmV2YWx1YXRlKFxuXHRcdFx0XHRcdFx0XHRcdGN1cnZlLnByZXZpb3VzLnZhbHVlcywgdCwgMSkueSA8IDApIHtcblx0XHRcdFx0XHRcdGlmICh0ZXN0Q29udGFpbnMgJiYgeDAgPj0geEJlZm9yZSAmJiB4MCA8PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0Kyt3aW5kTGVmdDtcblx0XHRcdFx0XHRcdFx0Kyt3aW5kUmlnaHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh4MCA8PSB4QmVmb3JlKSB7XG5cdFx0XHRcdFx0XHR3aW5kTGVmdCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeDAgPj0geEFmdGVyKSB7XG5cdFx0XHRcdFx0XHR3aW5kUmlnaHQgKz0gd2luZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFicyh3aW5kTGVmdCksIGFicyh3aW5kUmlnaHQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yLCBzZWxmT3ApIHtcblx0XHRvcGVyYXRvciA9IG9wZXJhdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdFpFUk8gPSAxZS0zLFxuXHRcdFx0T05FID0gMSAtIDFlLTM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIHNlZywgc3RhcnRTZWcsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZyA9IHN0YXJ0U2VnID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnLl92aXNpdGVkIHx8ICFvcGVyYXRvcihzZWcuX3dpbmRpbmcpKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHZhciBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0XHRpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRzdGFydEludGVyU2VnID0gaW50ZXIgJiYgaW50ZXIuX3NlZ21lbnQsXG5cdFx0XHRcdGFkZGVkID0gZmFsc2UsXG5cdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHZhciBoYW5kbGVJbiA9IGRpciA+IDAgPyBzZWcuX2hhbmRsZUluIDogc2VnLl9oYW5kbGVPdXQsXG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbixcblx0XHRcdFx0XHRpbnRlclNlZztcblx0XHRcdFx0aWYgKGFkZGVkICYmICghb3BlcmF0b3Ioc2VnLl93aW5kaW5nKSB8fCBzZWxmT3ApXG5cdFx0XHRcdFx0XHQmJiAoaW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbilcblx0XHRcdFx0XHRcdCYmIChpbnRlclNlZyA9IGludGVyLl9zZWdtZW50KVxuXHRcdFx0XHRcdFx0JiYgaW50ZXJTZWcgIT09IHN0YXJ0U2VnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGZPcCkge1xuXHRcdFx0XHRcdFx0c2VnLl92aXNpdGVkID0gaW50ZXJTZWcuX3Zpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRzZWcgPSBpbnRlclNlZztcblx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBjMSA9IHNlZy5nZXRDdXJ2ZSgpO1xuXHRcdFx0XHRcdFx0aWYgKGRpciA+IDApXG5cdFx0XHRcdFx0XHRcdGMxID0gYzEuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0XHRcdHZhciB0MSA9IGMxLmdldFRhbmdlbnRBdChkaXIgPCAxID8gWkVSTyA6IE9ORSwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdGM0ID0gaW50ZXJTZWcuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0XHR0MyA9IGMzLmdldFRhbmdlbnRBdChPTkUsIHRydWUpLFxuXHRcdFx0XHRcdFx0XHR0NCA9IGM0LmdldFRhbmdlbnRBdChaRVJPLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0dzMgPSB0MS5jcm9zcyh0MyksXG5cdFx0XHRcdFx0XHRcdHc0ID0gdDEuY3Jvc3ModDQpO1xuXHRcdFx0XHRcdFx0aWYgKHczICogdzQgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnZlID0gdzMgPCB3NCA/IGMzIDogYzQsXG5cdFx0XHRcdFx0XHRcdFx0bmV4dEN1cnZlID0gb3BlcmF0b3IoY3VydmUuX3NlZ21lbnQxLl93aW5kaW5nKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJ2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB3MyA8IHc0ID8gYzQgOiBjMyxcblx0XHRcdFx0XHRcdFx0XHRuZXh0U2VnID0gbmV4dEN1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0XHRcdFx0ZGlyID0gbmV4dEN1cnZlID09PSBjMyA/IC0xIDogMTtcblx0XHRcdFx0XHRcdFx0aWYgKG5leHRTZWcuX3Zpc2l0ZWQgJiYgc2VnLl9wYXRoICE9PSBuZXh0U2VnLl9wYXRoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHx8ICFvcGVyYXRvcihuZXh0U2VnLl93aW5kaW5nKSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VnLl92aXNpdGVkID0gaW50ZXJTZWcuX3Zpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0c2VnID0gaW50ZXJTZWc7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5leHRTZWcuX3Zpc2l0ZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGFkZGVkICYmIGhhbmRsZUluLCBoYW5kbGVPdXQpKTtcblx0XHRcdFx0YWRkZWQgPSB0cnVlO1xuXHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHRzZWcgPSBkaXIgPiAwID8gc2VnLmdldE5leHQoKSA6IHNlZy4gZ2V0UHJldmlvdXMoKTtcblx0XHRcdH0gd2hpbGUgKHNlZyAmJiAhc2VnLl92aXNpdGVkXG5cdFx0XHRcdFx0JiYgc2VnICE9PSBzdGFydFNlZyAmJiBzZWcgIT09IHN0YXJ0SW50ZXJTZWdcblx0XHRcdFx0XHQmJiAoc2VnLl9pbnRlcnNlY3Rpb24gfHwgb3BlcmF0b3Ioc2VnLl93aW5kaW5nKSkpO1xuXHRcdFx0aWYgKHNlZyAmJiAoc2VnID09PSBzdGFydFNlZyB8fCBzZWcgPT09IHN0YXJ0SW50ZXJTZWcpKSB7XG5cdFx0XHRcdHBhdGguZmlyc3RTZWdtZW50LnNldEhhbmRsZUluKChzZWcgPT09IHN0YXJ0SW50ZXJTZWdcblx0XHRcdFx0XHRcdD8gc3RhcnRJbnRlclNlZyA6IHNlZykuX2hhbmRsZUluKTtcblx0XHRcdFx0cGF0aC5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoLmxhc3RTZWdtZW50Ll9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguX3NlZ21lbnRzLmxlbmd0aCA+XG5cdFx0XHRcdFx0KHBhdGguX2Nsb3NlZCA/IHBhdGguaXNQb2x5Z29uKCkgPyAyIDogMCA6IDEpKVxuXHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRcdGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgZnVuY3Rpb24odykge1xuXHRcdFx0XHRyZXR1cm4gdyA9PT0gMSB8fCB3ID09PSAwO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG5cdFx0XHRcdHJldHVybiB3ID09PSAyO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsIGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0XHR9LCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgcGF0aC5zdWJ0cmFjdCh0aGlzKV0pO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBuZXcgR3JvdXAoW3RoaXMuc3VidHJhY3QocGF0aCksIHRoaXMuaW50ZXJzZWN0KHBhdGgpXSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cblBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyxcblx0XHRcdHByZXZDdXJ2ZTtcblxuXHRcdGZ1bmN0aW9uIGluc2VydEN1cnZlKHYpIHtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdls3XSxcblx0XHRcdFx0Y3VydmUgPSB7XG5cdFx0XHRcdFx0dmFsdWVzOiB2LFxuXHRcdFx0XHRcdHdpbmRpbmc6IHkwID09PSB5MVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IHkwID4geTFcblx0XHRcdFx0XHRcdFx0PyAtMVxuXHRcdFx0XHRcdFx0XHQ6IDEsXG5cdFx0XHRcdFx0cHJldmlvdXM6IHByZXZDdXJ2ZSxcblx0XHRcdFx0XHRuZXh0OiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocHJldkN1cnZlKVxuXHRcdFx0XHRwcmV2Q3VydmUubmV4dCA9IGN1cnZlO1xuXHRcdFx0bW9ub0N1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcblx0XHRcdGlmIChDdXJ2ZS5nZXRMZW5ndGgodikgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdlszXSxcblx0XHRcdFx0eTIgPSB2WzVdLFxuXHRcdFx0XHR5MyA9IHZbN107XG5cdFx0XHRpZiAoQ3VydmUuaXNMaW5lYXIodikpIHtcblx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAoeTEgLSB5MikgLSB5MCArIHkzLFxuXHRcdFx0XHRcdGIgPSAyICogKHkwICsgeTIpIC0gNCAqIHkxLFxuXHRcdFx0XHRcdGMgPSB5MSAtIHkwLFxuXHRcdFx0XHRcdFRPTEVSQU5DRSA9IDAuMDAwMDEsXG5cdFx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCBUT0xFUkFOQ0UsXG5cdFx0XHRcdFx0XHQxIC0gVE9MRVJBTkNFKTtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcblx0XHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFtb25vQ3VydmVzKSB7XG5cdFx0XHRtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGhhbmRsZUN1cnZlKGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSk7XG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcblx0XHRcdFx0XHRwMiA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRwMXggPSBwMS5feCwgcDF5ID0gcDEuX3ksXG5cdFx0XHRcdFx0cDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuXHRcdFx0XHRoYW5kbGVDdXJ2ZShbcDF4LCBwMXksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDJ4LCBwMnldKTtcblx0XHRcdH1cblx0XHRcdGlmIChtb25vQ3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gbW9ub0N1cnZlc1swXSxcblx0XHRcdFx0XHRsYXN0ID0gbW9ub0N1cnZlc1ttb25vQ3VydmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRmaXJzdC5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0XHRcdGxhc3QubmV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0eEludGVyY2VwdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRcdFx0XHR4SW50ZXJjZXB0cy5wdXNoKEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgcm9vdHNbal0sIDApLngpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4SW50ZXJjZXB0cy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRDbG9ja3dpc2UodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5Db21wb3VuZFBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIGNoaWxkcmVuW2ldLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYi5nZXRCb3VuZHMoKS5nZXRBcmVhKCkgLSBhLmdldEJvdW5kcygpLmdldEFyZWEoKTtcblx0XHR9KTtcblx0XHR0aGlzLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHR2YXIgY2xvY2t3aXNlID0gY2hpbGRyZW5bMF0uaXNDbG9ja3dpc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBvaW50ID0gY2hpbGRyZW5baV0uZ2V0SW50ZXJpb3JQb2ludCgpLFxuXHRcdFx0XHRjb3VudGVycyA9IDA7XG5cdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltqXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0Y291bnRlcnMrKztcblx0XHRcdH1cblx0XHRcdGNoaWxkcmVuW2ldLnNldENsb2Nrd2lzZShjb3VudGVycyAlIDIgPT09IDAgJiYgY2xvY2t3aXNlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG52YXIgUGF0aEl0ZXJhdG9yID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlcmF0b3InLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIG1heFJlY3Vyc2lvbiwgdG9sZXJhbmNlLCBtYXRyaXgpIHtcblx0XHR2YXIgY3VydmVzID0gW10sXG5cdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0bGVuZ3RoID0gMCxcblx0XHRcdG1pbkRpZmZlcmVuY2UgPSAxIC8gKG1heFJlY3Vyc2lvbiB8fCAzMiksXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50c1swXSxcblx0XHRcdHNlZ21lbnQyO1xuXG5cdFx0ZnVuY3Rpb24gYWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBDdXJ2ZS5nZXRWYWx1ZXMoc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpO1xuXHRcdFx0Y3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0Y29tcHV0ZVBhcnRzKGN1cnZlLCBzZWdtZW50MS5faW5kZXgsIDAsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgaW5kZXgsIG1pblQsIG1heFQpIHtcblx0XHRcdGlmICgobWF4VCAtIG1pblQpID4gbWluRGlmZmVyZW5jZVxuXHRcdFx0XHRcdCYmICFDdXJ2ZS5pc0ZsYXRFbm91Z2goY3VydmUsIHRvbGVyYW5jZSB8fCAwLjI1KSkge1xuXHRcdFx0XHR2YXIgc3BsaXQgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUpLFxuXHRcdFx0XHRcdGhhbGZUID0gKG1pblQgKyBtYXhUKSAvIDI7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhzcGxpdFswXSwgaW5kZXgsIG1pblQsIGhhbGZUKTtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKHNwbGl0WzFdLCBpbmRleCwgaGFsZlQsIG1heFQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHggPSBjdXJ2ZVs2XSAtIGN1cnZlWzBdLFxuXHRcdFx0XHRcdHkgPSBjdXJ2ZVs3XSAtIGN1cnZlWzFdLFxuXHRcdFx0XHRcdGRpc3QgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdGlmIChkaXN0ID4gMC4wMDAwMSkge1xuXHRcdFx0XHRcdGxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0b2Zmc2V0OiBsZW5ndGgsXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF4VCxcblx0XHRcdFx0XHRcdGluZGV4OiBpbmRleFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50Mjtcblx0XHR9XG5cdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQyLCBzZWdtZW50c1swXSk7XG5cblx0XHR0aGlzLmN1cnZlcyA9IGN1cnZlcztcblx0XHR0aGlzLnBhcnRzID0gcGFydHM7XG5cdFx0dGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHZhciBpLCBqID0gdGhpcy5pbmRleDtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpID0gajtcblx0XHRcdGlmIChqID09IDAgfHwgdGhpcy5wYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGZvciAodmFyIGwgPSB0aGlzLnBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuXHRcdFx0aWYgKHBhcnQub2Zmc2V0ID49IG9mZnNldCkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gaTtcblx0XHRcdFx0dmFyIHByZXYgPSB0aGlzLnBhcnRzW2kgLSAxXTtcblx0XHRcdFx0dmFyIHByZXZWYWwgPSBwcmV2ICYmIHByZXYuaW5kZXggPT0gcGFydC5pbmRleCA/IHByZXYudmFsdWUgOiAwLFxuXHRcdFx0XHRcdHByZXZMZW4gPSBwcmV2ID8gcHJldi5vZmZzZXQgOiAwO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZhbHVlOiBwcmV2VmFsICsgKHBhcnQudmFsdWUgLSBwcmV2VmFsKVxuXHRcdFx0XHRcdFx0KiAob2Zmc2V0IC0gcHJldkxlbikgLyAocGFydC5vZmZzZXQgLSBwcmV2TGVuKSxcblx0XHRcdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IDEsXG5cdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdH07XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKG9mZnNldCwgdHlwZSkge1xuXHRcdHZhciBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS52YWx1ZSwgdHlwZSk7XG5cdH0sXG5cblx0ZHJhd1BhcnQ6IGZ1bmN0aW9uKGN0eCwgZnJvbSwgdG8pIHtcblx0XHRmcm9tID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChmcm9tKTtcblx0XHR0byA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQodG8pO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tLmluZGV4OyBpIDw9IHRvLmluZGV4OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aSA9PSBmcm9tLmluZGV4ID8gZnJvbS52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0aSA9PSB0by5pbmRleCA/IHRvLnZhbHVlIDogMSk7XG5cdFx0XHRpZiAoaSA9PSBmcm9tLmluZGV4KVxuXHRcdFx0XHRjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuXHRmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ldmFsdWF0ZShvZmZzZXQsIGluZGV4KTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHRoaXMucG9pbnRzID0gW107XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRwcmV2O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludC5jbG9uZSgpO1xuXHRcdFx0aWYgKCFwcmV2IHx8ICFwcmV2LmVxdWFscyhwb2ludCkpIHtcblx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblx0XHR0aGlzLnNlZ21lbnRzID0gbGVuZ3RoID4gMCA/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXHRcdHJldHVybiB0aGlzLnNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgVjEgPSB0aGlzLnBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0XSksXG5cdFx0XHRWMiA9IHRoaXMucG9pbnRzW3NwbGl0XS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdCArIDFdKSxcblx0XHRcdHRhbkNlbnRlciA9IFYxLmFkZChWMikuZGl2aWRlKDIpLm5vcm1hbGl6ZSgpO1xuXHRcdHRoaXMuZml0Q3ViaWMoZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuXHRcdHRoaXMuZml0Q3ViaWMoc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG5cdH0sXG5cblx0YWRkQ3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLnNlZ21lbnRzW3RoaXMuc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdFx0cHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcblx0XHR0aGlzLnNlZ21lbnRzLnB1c2goXG5cdFx0XHRcdG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcblx0fSxcblxuXHRnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTEsXG5cdFx0XHRwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuXHRcdFx0WCA9IFswLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHUgPSB1UHJpbWVbaV0sXG5cdFx0XHRcdHQgPSAxIC0gdSxcblx0XHRcdFx0YiA9IDMgKiB1ICogdCxcblx0XHRcdFx0YjAgPSB0ICogdCAqIHQsXG5cdFx0XHRcdGIxID0gYiAqIHQsXG5cdFx0XHRcdGIyID0gYiAqIHUsXG5cdFx0XHRcdGIzID0gdSAqIHUgKiB1LFxuXHRcdFx0XHRhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcblx0XHRcdFx0YTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG5cdFx0XHRcdHRtcCA9IHRoaXMucG9pbnRzW2ZpcnN0ICsgaV1cblx0XHRcdFx0XHQuc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuXHRcdFx0Q1swXVswXSArPSBhMS5kb3QoYTEpO1xuXHRcdFx0Q1swXVsxXSArPSBhMS5kb3QoYTIpO1xuXHRcdFx0Q1sxXVswXSA9IENbMF1bMV07XG5cdFx0XHRDWzFdWzFdICs9IGEyLmRvdChhMik7XG5cdFx0XHRYWzBdICs9IGExLmRvdCh0bXApO1xuXHRcdFx0WFsxXSArPSBhMi5kb3QodG1wKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG5cdFx0XHRhbHBoYTEsIGFscGhhMjtcblx0XHRpZiAoTWF0aC5hYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHR2YXIgZGV0QzBYXHQ9IENbMF1bMF0gKiBYWzFdXHQtIENbMV1bMF0gKiBYWzBdLFxuXHRcdFx0XHRkZXRYQzFcdD0gWFswXVx0ICAqIENbMV1bMV0gLSBYWzFdXHQgICogQ1swXVsxXTtcblx0XHRcdGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG5cdFx0XHRhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcblx0XHRcdFx0YzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcblx0XHRcdGlmIChNYXRoLmFicyhjMCkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMF0gLyBjMDtcblx0XHRcdH0gZWxzZSBpZiAoTWF0aC5hYnMoYzEpID4gZXBzaWxvbikge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBYWzFdIC8gYzE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKTtcblx0XHRlcHNpbG9uICo9IHNlZ0xlbmd0aDtcblx0XHRpZiAoYWxwaGExIDwgZXBzaWxvbiB8fCBhbHBoYTIgPCBlcHNpbG9uKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGFscGhhMikpLCBwdDJdO1xuXHR9LFxuXG5cdHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcblx0XHR9XG5cdH0sXG5cblx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuXHRcdHZhciBjdXJ2ZTEgPSBbXSxcblx0XHRcdGN1cnZlMiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuXHRcdFx0Y3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuXHRcdFx0cHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuXHRcdFx0cHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuXHRcdFx0ZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcblx0XHRcdGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcblx0XHRpZiAoTWF0aC5hYnMoZGYpIDwgMC4wMDAwMSlcblx0XHRcdHJldHVybiB1O1xuXHRcdHJldHVybiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJztcblx0XHR0aGlzLl9saW5lcyA9IFtdO1xuXHRcdHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uIF9jbG9uZShjb3B5KSB7XG5cdFx0Y29weS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXHRcdHJldHVybiBfY2xvbmUuYmFzZS5jYWxsKHRoaXMsIGNvcHkpO1xuXHR9LFxuXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuXHRcdHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjY1KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0Z2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cblx0Z2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbn0pO1xuXG52YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG5cdFx0VGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKG5ldyBQb2ludFRleHQoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHBvaW50LngsIHBvaW50LnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy50cmFuc2xhdGUocG9pbnQuc3VidHJhY3QodGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcblx0XHRjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcblx0XHRcdGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0d2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcblx0XHRcdHggPSAwO1xuXHRcdGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpXG5cdFx0XHR4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMjogMSk7XG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoeCxcblx0XHRcdFx0XHRudW1MaW5lcyA/IC0gMC43NSAqIGxlYWRpbmcgOiAwLFxuXHRcdFx0XHRcdHdpZHRoLCBudW1MaW5lcyAqIGxlYWRpbmcpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIGJvdW5kcykgOiBib3VuZHM7XG5cdH1cbn0pO1xuXG52YXIgQ29sb3IgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciB0eXBlcyA9IHtcblx0XHRncmF5OiBbJ2dyYXknXSxcblx0XHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0XHRoc2I6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnYnJpZ2h0bmVzcyddLFxuXHRcdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0XHRncmFkaWVudDogWydncmFkaWVudCcsICdvcmlnaW4nLCAnZGVzdGluYXRpb24nLCAnaGlnaGxpZ2h0J11cblx0fTtcblxuXHR2YXIgY29tcG9uZW50UGFyc2VycyA9IHt9LFxuXHRcdGNvbG9yQ2FjaGUgPSB7fSxcblx0XHRjb2xvckN0eDtcblxuXHRmdW5jdGlvbiBmcm9tQ1NTKHN0cmluZykge1xuXHRcdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiMoXFx3ezEsMn0pKFxcd3sxLDJ9KShcXHd7MSwyfSkkLyksXG5cdFx0XHRjb21wb25lbnRzO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0Y29tcG9uZW50cyA9IFswLCAwLCAwXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBhcnNlSW50KHZhbHVlLmxlbmd0aCA9PSAxXG5cdFx0XHRcdFx0XHQ/IHZhbHVlICsgdmFsdWUgOiB2YWx1ZSwgMTYpIC8gMjU1O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL15yZ2JhP1xcKCguKilcXCkkLykpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSArY29tcG9uZW50c1tpXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IGkgPCAzID8gdmFsdWUgLyAyNTUgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXTtcblx0XHRcdGlmICghY2FjaGVkKSB7XG5cdFx0XHRcdGlmICghY29sb3JDdHgpIHtcblx0XHRcdFx0XHRjb2xvckN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRcdFx0Y29sb3JDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gc3RyaW5nO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb2xvckN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcblx0XHRcdFx0Y2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddID0gW1xuXHRcdFx0XHRcdGRhdGFbMF0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsxXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzJdIC8gMjU1XG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRzID0gY2FjaGVkLnNsaWNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG5cblx0dmFyIGhzYkluZGljZXMgPSBbXG5cdFx0WzAsIDMsIDFdLFxuXHRcdFsyLCAwLCAxXSxcblx0XHRbMSwgMCwgM10sXG5cdFx0WzEsIDIsIDBdLFxuXHRcdFszLCAxLCAwXSxcblx0XHRbMCwgMSwgMl1cblx0XTtcblxuXHR2YXIgY29udmVydGVycyA9IHtcblx0XHQncmdiLWhzYic6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRoID0gZGVsdGEgPT09IDAgPyAwXG5cdFx0XHRcdFx0Olx0KCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDpcdFx0XHQgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDtcblx0XHRcdHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuXHRcdH0sXG5cblx0XHQnaHNiLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGIpIHtcblx0XHRcdGggPSAoKChoIC8gNjApICUgNikgKyA2KSAlIDY7XG5cdFx0XHR2YXIgaSA9IE1hdGguZmxvb3IoaCksXG5cdFx0XHRcdGYgPSBoIC0gaSxcblx0XHRcdFx0aSA9IGhzYkluZGljZXNbaV0sXG5cdFx0XHRcdHYgPSBbXG5cdFx0XHRcdFx0Yixcblx0XHRcdFx0XHRiICogKDEgLSBzKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogZiksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqICgxIC0gZikpXG5cdFx0XHRcdF07XG5cdFx0XHRyZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuXHRcdH0sXG5cblx0XHQncmdiLWhzbCc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG5cdFx0XHRcdGggPSBhY2hyb21hdGljID8gMFxuXHRcdFx0XHRcdDpcdCggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6XHRcdFx0IChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsXG5cdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDIsXG5cdFx0XHRcdHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjVcblx0XHRcdFx0XHRcdD8gZGVsdGEgLyAobWF4ICsgbWluKVxuXHRcdFx0XHRcdFx0OiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0XHRcdHJldHVybiBbaCwgcywgbF07XG5cdFx0fSxcblxuXHRcdCdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuXHRcdFx0aCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG5cdFx0XHRpZiAocyA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtsLCBsLCBsXTtcblx0XHRcdHZhciB0M3MgPSBbIGggKyAxIC8gMywgaCwgaCAtIDEgLyAzIF0sXG5cdFx0XHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcblx0XHRcdFx0dDEgPSAyICogbCAtIHQyLFxuXHRcdFx0XHRjID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdDMgPSB0M3NbaV07XG5cdFx0XHRcdGlmICh0MyA8IDApIHQzICs9IDE7XG5cdFx0XHRcdGlmICh0MyA+IDEpIHQzIC09IDE7XG5cdFx0XHRcdGNbaV0gPSA2ICogdDMgPCAxXG5cdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1xuXHRcdFx0XHRcdDogMiAqIHQzIDwgMVxuXHRcdFx0XHRcdFx0PyB0MlxuXHRcdFx0XHRcdFx0OiAzICogdDMgPCAyXG5cdFx0XHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzKSAqIDZcblx0XHRcdFx0XHRcdFx0OiB0MTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHRyZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1yZ2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gW2csIGcsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdFx0Y29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuXHRcdEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuXHRcdFx0XHRwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IG5hbWUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudCA9IHRoaXMuX2NvbXBvbmVudHNbMF07XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IEdyYWRpZW50LnJlYWQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdDogYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50KVxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuX3JlbW92ZU93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUuX2FkZE93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdD8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE51bGw6IG5hbWUgPT09ICdoaWdobGlnaHQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvbmU6IHRydWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdHx8IGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2NvbnZlcnQodHlwZSlbaW5kZXhdO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09IHR5cGVcblx0XHRcdFx0XHRcdCYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sIHRoaXMpO1xuXHR9LCB7XG5cdFx0X2NsYXNzOiAnQ29sb3InLFxuXHRcdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb2xvcihhcmcpIHtcblx0XHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cmVhZCA9IDAsXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMsXG5cdFx0XHRcdGFscGhhLFxuXHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMF07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmc7XG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgJiYgYXJnIGluIHR5cGVzKSB7XG5cdFx0XHRcdHR5cGUgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnO1xuXHRcdFx0XHRcdGFscGhhID0gYXJnc1syXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdFx0XHRhcmdzID0gc2xpY2UuY2FsbChhcmdzLCAxKTtcblx0XHRcdFx0XHRhcmdUeXBlID0gdHlwZW9mIGFyZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHZhbHVlcyA9IGFyZ1R5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGFyZ3Ncblx0XHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ29iamVjdCcgJiYgYXJnLmxlbmd0aCAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0XHRcdGlmICghdHlwZSlcblx0XHRcdFx0XHRcdHR5cGUgPSB2YWx1ZXMubGVuZ3RoID49IDNcblx0XHRcdFx0XHRcdFx0XHQ/ICdyZ2InXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheSc7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHR5cGVzW3R5cGVdLmxlbmd0aDtcblx0XHRcdFx0XHRhbHBoYSA9IHZhbHVlc1tsZW5ndGhdO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHRcdHJlYWQgKz0gdmFsdWVzID09PSBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0PyBsZW5ndGggKyAoYWxwaGEgIT0gbnVsbCA/IDEgOiAwKVxuXHRcdFx0XHRcdFx0XHQ6IDE7XG5cdFx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiBsZW5ndGgpXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBzbGljZS5jYWxsKHZhbHVlcywgMCwgbGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHR5cGUgPSAncmdiJztcblx0XHRcdFx0XHRjb21wb25lbnRzID0gZnJvbUNTUyhhcmcpO1xuXHRcdFx0XHRcdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0dHlwZSA9IGFyZy5fdHlwZTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmcuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLl9hbHBoYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwb2ludClcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IEdyYWRpZW50KSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGFyZ3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnaHVlJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0PyAnbGlnaHRuZXNzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdoc2wnXG5cdFx0XHRcdFx0XHRcdFx0OiAnaHNiJ1xuXHRcdFx0XHRcdFx0XHQ6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCAncmFkaWFsJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5JyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdD8gJ2dyYXknXG5cdFx0XHRcdFx0XHRcdFx0XHQ6ICdyZ2InO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHRcdFx0cGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV07XG5cdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmIGkgPT09IDAgJiYgdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdFx0JiYgJ3N0b3BzJyBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0b3BzOiBhcmcuc3RvcHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRyYWRpYWw6IGFyZy5yYWRpYWxcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuYWxwaGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZCAmJiB0eXBlKVxuXHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgJ3JnYic7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0dGhpcy5faWQgPSBDb2xvci5faWQgPSAoQ29sb3IuX2lkIHx8IDApICsgMTtcblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHR2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuXHRcdFx0XHRcdC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0OiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLl9hbHBoYSA9PT0gY29sLl9hbHBoYVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdGlmICh0aGlzLl9jYW52YXNTdHlsZSlcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlO1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09ICdncmFkaWVudCcpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IHRoaXMudG9DU1MoKTtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Z3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuXHRcdFx0XHRzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcyxcblx0XHRcdFx0b3JpZ2luID0gY29tcG9uZW50c1sxXSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuXHRcdFx0XHRjYW52YXNHcmFkaWVudDtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pLFxuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdFx0c3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuXHRcdH0sXG5cblx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRfdHlwZXM6IHR5cGVzLFxuXG5cdFx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICsgYjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICogYjtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAvIGI7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbihvcGVyYXRvciwgbmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Y29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuXHRcdFx0XHRcdHRoaXMuX2FscGhhICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcblx0XHRcdFx0XHRcdFx0OiBudWxsKTtcblx0XHR9O1xuXHR9LCB7XG5cdH0pO1xufSk7XG5cbkJhc2UuZWFjaChDb2xvci5fdHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0dmFyIGN0b3IgPSB0aGlzW0Jhc2UuY2FwaXRhbGl6ZSh0eXBlKSArICdDb2xvciddID0gZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmcsXG5cdFx0XHRcdGNvbXBvbmVudHMgPSBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdFx0OiBhcmd1bWVudHM7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50c1xuXHRcdFx0XHRcdD8gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMpXG5cdFx0XHRcdFx0OiBuZXcgQ29sb3IoYXJnKTtcblx0XHR9O1xuXHRpZiAodHlwZS5sZW5ndGggPT0gMykge1xuXHRcdHZhciBhY3JvbnltID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuXHRcdENvbG9yW2Fjcm9ueW1dID0gdGhpc1thY3JvbnltICsgJ0NvbG9yJ10gPSBjdG9yO1xuXHR9XG59LCBCYXNlLmV4cG9ydHMpO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBHcmFkaWVudC5faWQgPSAoR3JhZGllbnQuX2lkIHx8IDApICsgMTtcblx0XHRpZiAoc3RvcHMgJiYgdGhpcy5fc2V0KHN0b3BzKSlcblx0XHRcdHN0b3BzID0gcmFkaWFsID0gbnVsbDtcblx0XHRpZiAoIXRoaXMuX3N0b3BzKVxuXHRcdFx0dGhpcy5zZXRTdG9wcyhzdG9wcyB8fCBbJ3doaXRlJywgJ2JsYWNrJ10pO1xuXHRcdGlmICh0aGlzLl9yYWRpYWwgPT0gbnVsbClcblx0XHRcdHRoaXMuc2V0UmFkaWFsKHR5cGVvZiByYWRpYWwgPT09ICdzdHJpbmcnICYmIHJhZGlhbCA9PT0gJ3JhZGlhbCdcblx0XHRcdFx0XHR8fCByYWRpYWwgfHwgZmFsc2UpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX3N0b3BzLCB0aGlzLl9yYWRpYWxdLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX293bmVycyAmJiB0aGlzLl9vd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fb3duZXJzW2ldLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X2FkZE93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdGlmICghdGhpcy5fb3duZXJzKVxuXHRcdFx0dGhpcy5fb3duZXJzID0gW107XG5cdFx0dGhpcy5fb3duZXJzLnB1c2goY29sb3IpO1xuXHR9LFxuXG5cdF9yZW1vdmVPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9vd25lcnMgPyB0aGlzLl9vd25lcnMuaW5kZXhPZihjb2xvcikgOiAtMTtcblx0XHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHRcdHRoaXMuX293bmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0aWYgKHRoaXMuX293bmVycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdG9wcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c3RvcHNbaV0gPSB0aGlzLl9zdG9wc1tpXS5jbG9uZSgpO1xuXHRcdHJldHVybiBuZXcgR3JhZGllbnQoc3RvcHMpO1xuXHR9LFxuXG5cdGdldFN0b3BzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcHM7XG5cdH0sXG5cblx0c2V0U3RvcHM6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cdFx0aWYgKHRoaXMuc3RvcHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChzdG9wcy5sZW5ndGggPCAyKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0dGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZEFsbChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0b3AgPSB0aGlzLl9zdG9wc1tpXTtcblx0XHRcdHN0b3AuX293bmVyID0gdGhpcztcblx0XHRcdGlmIChzdG9wLl9kZWZhdWx0UmFtcClcblx0XHRcdFx0c3RvcC5zZXRSYW1wUG9pbnQoaSAvIChsIC0gMSkpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9LFxuXG5cdHNldFJhZGlhbDogZnVuY3Rpb24ocmFkaWFsKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0aWYgKGdyYWRpZW50ID09PSB0aGlzKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0b3BzW2ldLmVxdWFscyhncmFkaWVudC5fc3RvcHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKGFyZzApIHtcblx0XHRcdHZhciBjb2xvciwgcmFtcFBvaW50O1xuXHRcdFx0aWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5jb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzAucmFtcFBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jb2xvciwgdGhpcy5fcmFtcFBvaW50XSwgb3B0aW9ucywgdHJ1ZSxcblx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYW1wUG9pbnQ7XG5cdH0sXG5cblx0c2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcblx0XHR0aGlzLl9kZWZhdWx0UmFtcCA9IHJhbXBQb2ludCA9PSBudWxsO1xuXHRcdHRoaXMuX3JhbXBQb2ludCA9IHJhbXBQb2ludCB8fCAwO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9jb2xvciA9PT0gY29sb3IpXG5cdFx0XHR0aGlzLl9jb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9yYW1wUG9pbnQgPT0gc3RvcC5fcmFtcFBvaW50XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZmlsbENvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHdpbmRpbmdSdWxlOiAnbm9uemVybycsXG5cdFx0c2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcblx0XHRzaGFkb3dCbHVyOiAwLFxuXHRcdHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG5cdFx0c2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRmb250V2VpZ2h0OiAnbm9ybWFsJyxcblx0XHRmb250U2l6ZTogMTIsXG5cdFx0Zm9udDogJ3NhbnMtc2VyaWYnLFxuXHRcdGxlYWRpbmc6IG51bGwsXG5cdFx0anVzdGlmaWNhdGlvbjogJ2xlZnQnXG5cdH07XG5cblx0dmFyIGZsYWdzID0ge1xuXHRcdHN0cm9rZVdpZHRoOiA5Nyxcblx0XHRzdHJva2VDYXA6IDk3LFxuXHRcdHN0cm9rZUpvaW46IDk3LFxuXHRcdHN0cm9rZVNjYWxpbmc6IDEwNSxcblx0XHRtaXRlckxpbWl0OiA5Nyxcblx0XHRmb250RmFtaWx5OiA5LFxuXHRcdGZvbnRXZWlnaHQ6IDksXG5cdFx0Zm9udFNpemU6IDksXG5cdFx0Zm9udDogOSxcblx0XHRsZWFkaW5nOiA5LFxuXHRcdGp1c3RpZmljYXRpb246IDlcblx0fTtcblxuXHR2YXIgaXRlbSA9IHsgYmVhbnM6IHRydWUgfSxcblx0XHRmaWVsZHMgPSB7XG5cdFx0XHRfZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRcdFx0X3RleHREZWZhdWx0czogbmV3IEJhc2UoZGVmYXVsdHMsIHtcblx0XHRcdFx0ZmlsbENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0fSksXG5cdFx0XHRiZWFuczogdHJ1ZVxuXHRcdH07XG5cblx0QmFzZS5lYWNoKGRlZmF1bHRzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0dmFyIGlzQ29sb3IgPSAvQ29sb3IkLy50ZXN0KGtleSksXG5cdFx0XHRpc1BvaW50ID0ga2V5ID09PSAnc2hhZG93T2Zmc2V0Jyxcblx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGZsYWcgPSBmbGFnc1trZXldLFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG5cdFx0ZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNDb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKG9sZClcblx0XHRcdFx0XHRcdFx0b2xkLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLl9vd25lcilcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZpZWxkc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IF9kb250TWVyZ2Vcblx0XHRcdFx0XHR8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2RlZmF1bHRzW2tleV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBpc0NvbG9yID8gQ29sb3IgOiBpc1BvaW50ID8gUG9pbnQgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChjdG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IGN0b3IpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gY3Rvci5yZWFkKFt2YWx1ZV0sIDAsXG5cdFx0XHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSwgY2xvbmU6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgaXNDb2xvcilcblx0XHRcdFx0XHRcdFx0dmFsdWUuX293bmVyID0gb3duZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlID0gY2hpbGRyZW5baV0uX3N0eWxlW2dldF0oKTtcblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNoaWxkVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0aXRlbVtnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3N0eWxlW2dldF0oX2RvbnRNZXJnZSk7XG5cdFx0fTtcblxuXHRcdGl0ZW1bc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHR9O1xuXHR9KTtcblxuXHRJdGVtLmluamVjdChpdGVtKTtcblx0cmV0dXJuIGZpZWxkcztcbn0sIHtcblx0X2NsYXNzOiAnU3R5bGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN0eWxlKHN0eWxlLCBfb3duZXIsIF9wcm9qZWN0KSB7XG5cdFx0dGhpcy5fdmFsdWVzID0ge307XG5cdFx0dGhpcy5fb3duZXIgPSBfb3duZXI7XG5cdFx0dGhpcy5fcHJvamVjdCA9IF9vd25lciAmJiBfb3duZXIuX3Byb2plY3QgfHwgX3Byb2plY3QgfHwgcGFwZXIucHJvamVjdDtcblx0XHRpZiAoX293bmVyIGluc3RhbmNlb2YgVGV4dEl0ZW0pXG5cdFx0XHR0aGlzLl9kZWZhdWx0cyA9IHRoaXMuX3RleHREZWZhdWx0cztcblx0XHRpZiAoc3R5bGUpXG5cdFx0XHR0aGlzLnNldChzdHlsZSk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHZhciBpc1N0eWxlID0gc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSxcblx0XHRcdHZhbHVlcyA9IGlzU3R5bGUgPyBzdHlsZS5fdmFsdWVzIDogc3R5bGU7XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuXHRcdFx0XHRpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzW2tleV07XG5cdFx0XHRcdFx0dGhpc1trZXldID0gdmFsdWUgJiYgaXNTdHlsZSAmJiB2YWx1ZS5jbG9uZVxuXHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmNsb25lKCkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0cmV0dXJuIHN0eWxlID09PSB0aGlzIHx8IHN0eWxlICYmIHRoaXMuX2NsYXNzID09PSBzdHlsZS5fY2xhc3Ncblx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fdmFsdWVzLCBzdHlsZS5fdmFsdWVzKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldEZpbGxDb2xvcigpO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRTdHJva2VDb2xvcigpICYmIHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSA+IDA7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFNoYWRvd0NvbG9yKCkgJiYgdGhpcy5nZXRTaGFkb3dCbHVyKCkgPiAwO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRnZXRGb250U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRGb250V2VpZ2h0KClcblx0XHRcdFx0KyAnICcgKyBmb250U2l6ZSArICgvW2Etel0vaS50ZXN0KGZvbnRTaXplICsgJycpID8gJyAnIDogJ3B4ICcpXG5cdFx0XHRcdCsgdGhpcy5nZXRGb250RmFtaWx5KCk7XG5cdH0sXG5cblx0Z2V0Rm9udDogJyNnZXRGb250RmFtaWx5Jyxcblx0c2V0Rm9udDogJyNzZXRGb250RmFtaWx5JyxcblxuXHRnZXRMZWFkaW5nOiBmdW5jdGlvbiBnZXRMZWFkaW5nKCkge1xuXHRcdHZhciBsZWFkaW5nID0gZ2V0TGVhZGluZy5iYXNlLmNhbGwodGhpcyksXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcblx0XHRpZiAoL3B0fGVtfCV8cHgvLnRlc3QoZm9udFNpemUpKVxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldFZpZXcoKS5nZXRQaXhlbFNpemUoZm9udFNpemUpO1xuXHRcdHJldHVybiBsZWFkaW5nICE9IG51bGwgPyBsZWFkaW5nIDogZm9udFNpemUgKiAxLjI7XG5cdH1cblxufSk7XG5cbnZhciBEb21FbGVtZW50ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHNldCwgdmFsdWUpIHtcblx0XHR2YXIgcHJlZml4ZXMgPSBbJycsICd3ZWJraXQnLCAnbW96JywgJ01veicsICdtcycsICdvJ10sXG5cdFx0XHRzdWZmaXggPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuXHRcdFx0dmFyIHByZWZpeCA9IHByZWZpeGVzW2ldLFxuXHRcdFx0XHRrZXkgPSBwcmVmaXggPyBwcmVmaXggKyBzdWZmaXggOiBuYW1lO1xuXHRcdFx0aWYgKGtleSBpbiBlbCkge1xuXHRcdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdFx0ZWxba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Z2V0U3R5bGVzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsICYmIGVsLm5vZGVUeXBlICE9PSA5ID8gZWwub3duZXJEb2N1bWVudCA6IGVsLFxuXHRcdFx0XHR2aWV3ID0gZG9jICYmIGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdHJldHVybiB2aWV3ICYmIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdGJvZHkgPSBkb2MuYm9keSxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRcdHJlY3Q7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlY3QgPSB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSByZWN0LmxlZnQgLSAoaHRtbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcblx0XHRcdFx0eSA9IHJlY3QudG9wIC0gKGh0bWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDApO1xuXHRcdFx0aWYgKCF2aWV3cG9ydCkge1xuXHRcdFx0XHR2YXIgdmlldyA9IGRvYy5kZWZhdWx0Vmlldztcblx0XHRcdFx0eCArPSB2aWV3LnBhZ2VYT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cdFx0XHRcdHkgKz0gdmlldy5wYWdlWU9mZnNldCB8fCBodG1sLnNjcm9sbFRvcCB8fCBib2R5LnNjcm9sbFRvcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHR9LFxuXG5cdFx0Z2V0Vmlld3BvcnRCb3VuZHM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0dmlldyA9IGRvYy5kZWZhdWx0Vmlldyxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLFxuXHRcdFx0XHR2aWV3LmlubmVyV2lkdGggfHwgaHRtbC5jbGllbnRXaWR0aCxcblx0XHRcdFx0dmlldy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdmlld3BvcnQpLmdldFBvaW50KCk7XG5cdFx0fSxcblxuXHRcdGdldFNpemU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpLmdldFNpemUoKTtcblx0XHR9LFxuXG5cdFx0aXNJbnZpc2libGU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRTaXplKGVsKS5lcXVhbHMobmV3IFNpemUoMCwgMCkpO1xuXHRcdH0sXG5cblx0XHRpc0luVmlldzogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiAhRG9tRWxlbWVudC5pc0ludmlzaWJsZShlbClcblx0XHRcdFx0XHQmJiBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsKS5pbnRlcnNlY3RzKFxuXHRcdFx0XHRcdFx0RG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHRydWUpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gaGFuZGxlUHJlZml4KGVsLCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0c2V0UHJlZml4ZWQ6IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbmFtZSlcblx0XHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIGtleSwgdHJ1ZSwgbmFtZVtrZXldKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZVByZWZpeChlbCwgbmFtZSwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHR0aGlzLl9zY29wZSA9IHByb2plY3QuX3Njb3BlO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXHRcdHZhciBzaXplO1xuXHRcdGlmICghdGhpcy5fcGl4ZWxSYXRpbylcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKys7XG5cdFx0c2l6ZSA9IG5ldyBTaXplKGVsZW1lbnQud2lkdGgsIGVsZW1lbnQuaGVpZ2h0KTtcblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHQodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3pvb20gPSAxO1xuXHRcdGlmICghVmlldy5fZm9jdXNlZClcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblx0XHRWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cdFx0ZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QuX3ZpZXcgPT09IHRoaXMpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll92aWV3ID0gbnVsbDtcblx0XHR0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5vZmYoJ2ZyYW1lJyk7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiB7XG5cdFx0b25GcmFtZToge1xuXHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGxheSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvblJlc2l6ZToge31cblx0fSxcblxuXHRfYW5pbWF0ZTogZmFsc2UsXG5cdF90aW1lOiAwLFxuXHRfY291bnQ6IDAsXG5cblx0X3JlcXVlc3RGcmFtZTogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fYmVmb3JlID8gbm93IC0gdGhpcy5fYmVmb3JlIDogMDtcblx0XHR0aGlzLl9iZWZvcmUgPSBub3c7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlRnJhbWUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgMSlcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRkZWx0YTogZGVsdGFcblx0XHR9KTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhcblx0XHRcdFx0XHRuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2Nyb2xsQnkoY2VudGVyLnN1YnRyYWN0KHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5fem9vbSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0XHR0aGlzLl96b29tID0gem9vbTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpKTtcblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH1cblxufSwge1xuXHRzdGF0aWNzOiB7XG5cdFx0X3ZpZXdzOiBbXSxcblx0XHRfdmlld3NCeUlkOiB7fSxcblx0XHRfaWQ6IDAsXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBuZXcgQ2FudmFzVmlldyhwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHR0aGlzLl9ldmVudENvdW50ZXJzID0ge307XG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG5cdFx0Vmlldy5jYWxsKHRoaXMsIHByb2plY3QsIGNhbnZhcyk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0LFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW8sXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRlbGVtZW50LndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0dGhpcy5fY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdHNpemUgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiBzaXplO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKCFwcm9qZWN0IHx8ICFwcm9qZWN0Ll9uZWVkc1VwZGF0ZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBkb3duUG9pbnQsXG5cdFx0bGFzdFBvaW50LFxuXHRcdG92ZXJQb2ludCxcblx0XHRkb3duSXRlbSxcblx0XHRsYXN0SXRlbSxcblx0XHRvdmVySXRlbSxcblx0XHRkcmFnSXRlbSxcblx0XHRkYmxDbGljayxcblx0XHRjbGlja1RpbWU7XG5cblx0ZnVuY3Rpb24gY2FsbEV2ZW50KHZpZXcsIHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBsYXN0UG9pbnQpIHtcblx0XHR2YXIgaXRlbSA9IHRhcmdldCxcblx0XHRcdG1vdXNlRXZlbnQ7XG5cblx0XHRmdW5jdGlvbiBjYWxsKG9iaikge1xuXHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRpZiAoIW1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludCA/IHBvaW50LnN1YnRyYWN0KGxhc3RQb2ludCkgOiBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2JqLmVtaXQodHlwZSwgbW91c2VFdmVudCkgJiYgbW91c2VFdmVudC5pc1N0b3BwZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmIChjYWxsKGl0ZW0pKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGl0ZW0gPSBpdGVtLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRpZiAoY2FsbCh2aWV3KSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcblx0XHRcdGlmICghdGhpcy5fZXZlbnRDb3VudGVyc1t0eXBlXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRoaXQgPSBwcm9qZWN0LmhpdFRlc3QocG9pbnQsIHtcblx0XHRcdFx0XHR0b2xlcmFuY2U6IDAsXG5cdFx0XHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdFx0XHRzdHJva2U6IHRydWVcblx0XHRcdFx0fSksXG5cdFx0XHRcdGl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0sXG5cdFx0XHRcdHN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRkYmxDbGljayA9IGxhc3RJdGVtID09IGl0ZW0gJiYgKERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDApO1xuXHRcdFx0XHRkb3duSXRlbSA9IGxhc3RJdGVtID0gaXRlbTtcblx0XHRcdFx0ZG93blBvaW50ID0gbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGRyYWdJdGVtID0gIXN0b3BwZWQgJiYgaXRlbTtcblx0XHRcdFx0d2hpbGUgKGRyYWdJdGVtICYmICFkcmFnSXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdFx0ZHJhZ0l0ZW0gPSBkcmFnSXRlbS5fcGFyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSwgZG93blBvaW50KTtcblx0XHRcdFx0aWYgKGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RQb2ludCAmJiAhbGFzdFBvaW50LmVxdWFscyhwb2ludCkpXG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCwgZHJhZ0l0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50KTtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdG9wcGVkICYmIGl0ZW0gJiYgaXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCBkYmxDbGljayAmJiBkb3duSXRlbS5yZXNwb25kcygnZG91YmxlY2xpY2snKVxuXHRcdFx0XHRcdFx0XHQ/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgZG93blBvaW50LCBpdGVtKTtcblx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdGlmIChkcmFnSXRlbSlcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsXG5cdFx0XHRcdFx0XHRcdGRyYWdJdGVtLCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRpZiAoIXN0b3BwZWQpIHtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pXG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50LCBvdmVySXRlbSk7XG5cdFx0XHRcdFx0b3Zlckl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RvcHBlZDtcblx0XHR9XG5cdH07XG59KTtcblxudmFyIENhbnZhc1Byb3ZpZGVyID0ge1xuXHRjYW52YXNlczogW10sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4geyBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHt9IH07XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcblx0XHRcdGlmIChjbGVhcilcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCArIDEsIGhlaWdodCArIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fSxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0cmVsZWFzZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGNhbnZhcyA9IG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHR0aGlzLmNhbnZhc2VzLnB1c2goY2FudmFzKTtcblx0fVxufTtcblxudmFyIFNWR1N0eWxlcyA9IEJhc2UuZWFjaCh7XG5cdGZpbGxDb2xvcjogWydmaWxsJywgJ2NvbG9yJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0cmluZyddXG59LCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0bG9va3VwID0gZW50cnlbMl07XG5cdHRoaXNba2V5XSA9IHtcblx0XHR0eXBlOiBlbnRyeVsxXSxcblx0XHRwcm9wZXJ0eToga2V5LFxuXHRcdGF0dHJpYnV0ZTogZW50cnlbMF0sXG5cdFx0dG9TVkc6IGxvb2t1cCxcblx0XHRmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHRoaXNbdmFsdWVdID0gbmFtZTtcblx0XHR9LCB7fSksXG5cdFx0ZXhwb3J0RmlsdGVyOiBlbnRyeVszXSxcblx0XHRnZXQ6ICdnZXQnICsgcGFydCxcblx0XHRzZXQ6ICdzZXQnICsgcGFydFxuXHR9O1xufSwge30pO1xuXG52YXIgU1ZHTmFtZXNwYWNlcyA9IHtcblx0aHJlZjogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnXG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBmb3JtYXR0ZXI7XG5cblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycykge1xuXHRcdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0dmFyIHZhbCA9IGF0dHJzW2tleV0sXG5cdFx0XHRcdG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcblx0XHRcdFx0dmFsID0gZm9ybWF0dGVyLm51bWJlcih2YWwpO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwga2V5LCB2YWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykge1xuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuXHRcdFx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyksIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyYW5zZm9ybShtYXRyaXgsIGNvb3JkaW5hdGVzLCBjZW50ZXIpIHtcblx0XHR2YXIgYXR0cnMgPSBuZXcgQmFzZSgpLFxuXHRcdFx0dHJhbnMgPSBtYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRpZiAoY29vcmRpbmF0ZXMpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zaGlmdGxlc3MoKTtcblx0XHRcdHZhciBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG5cdFx0XHR0cmFucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCAmJiAhZGVjb21wb3NlZC5zaGVhcmluZykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdFx0XHRhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG5cdFx0XHRcdFx0c2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0XHRcdGlmICh0cmFucyAmJiAhdHJhbnMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcblx0XHRcdFx0aWYgKGFuZ2xlKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuXHRcdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueCAtIDEpXG5cdFx0XHRcdFx0XHR8fCAhTnVtZXJpY2FsLmlzWmVybyhzY2FsZS55IC0gMSkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgnc2NhbGUoJyArIGZvcm1hdHRlci5wb2ludChzY2FsZSkgKycpJyk7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9ICdtYXRyaXgoJyArIG1hdHJpeC5nZXRWYWx1ZXMoKS5qb2luKCcsJykgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyb3VwKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KSxcblx0XHRcdGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW47XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCdnJywgYXR0cnMpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBleHBvcnRTVkcoY2hpbGQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKGNoaWxkTm9kZSkge1xuXHRcdFx0XHRpZiAoY2hpbGQuaXNDbGlwTWFzaygpKSB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBjcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpO1xuXHRcdFx0XHRcdGNsaXAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0XHRzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuXHRcdFx0XHRcdHNldEF0dHJpYnV0ZXMobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0pIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gaXRlbS50b0RhdGFVUkwoKTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5tYXRjaFNoYXBlcykge1xuXHRcdFx0dmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcblx0XHRcdGlmIChzaGFwZSlcblx0XHRcdFx0cmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKGl0ZW0uaXNQb2x5Z29uKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcblx0XHRcdFx0YXR0cnMucG9pbnRzID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9ICdsaW5lJztcblx0XHRcdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF0uX3BvaW50LFxuXHRcdFx0XHRcdGxhc3QgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IGZpcnN0LngsXG5cdFx0XHRcdFx0eTE6IGZpcnN0LnksXG5cdFx0XHRcdFx0eDI6IGxhc3QueCxcblx0XHRcdFx0XHR5MjogbGFzdC55XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlID0gJ3BhdGgnO1xuXHRcdFx0YXR0cnMuZCA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG5cdFx0dmFyIHR5cGUgPSBpdGVtLl90eXBlLFxuXHRcdFx0cmFkaXVzID0gaXRlbS5fcmFkaXVzLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlLCB0eXBlICE9PSAncmVjdGFuZ2xlJyk7XG5cdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHR0eXBlID0gJ3JlY3QnO1xuXHRcdFx0dmFyIHNpemUgPSBpdGVtLl9zaXplLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0YXR0cnMueCAtPSB3aWR0aCAvIDI7XG5cdFx0XHRhdHRycy55IC09IGhlaWdodCAvIDI7XG5cdFx0XHRhdHRycy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0YXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0cmFkaXVzID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGF0dHJzLnIgPSByYWRpdXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcblx0XHRcdFx0YXR0cnMucnkgPSByYWRpdXMuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRDb21wb3VuZFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0aWYgKGRhdGEpXG5cdFx0XHRhdHRycy5kID0gZGF0YTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgncGF0aCcsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBsYWNlZFN5bWJvbChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzeW1ib2wgPSBpdGVtLmdldFN5bWJvbCgpLFxuXHRcdFx0c3ltYm9sTm9kZSA9IGdldERlZmluaXRpb24oc3ltYm9sLCAnc3ltYm9sJyksXG5cdFx0XHRkZWZpbml0aW9uID0gc3ltYm9sLmdldERlZmluaXRpb24oKSxcblx0XHRcdGJvdW5kcyA9IGRlZmluaXRpb24uZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFzeW1ib2xOb2RlKSB7XG5cdFx0XHRzeW1ib2xOb2RlID0gY3JlYXRlRWxlbWVudCgnc3ltYm9sJywge1xuXHRcdFx0XHR2aWV3Qm94OiBmb3JtYXR0ZXIucmVjdGFuZ2xlKGJvdW5kcylcblx0XHRcdH0pO1xuXHRcdFx0c3ltYm9sTm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcoZGVmaW5pdGlvbiwgb3B0aW9ucykpO1xuXHRcdFx0c2V0RGVmaW5pdGlvbihzeW1ib2wsIHN5bWJvbE5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIHN5bWJvbE5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMud2lkdGgpO1xuXHRcdGF0dHJzLmhlaWdodCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLmhlaWdodCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3VzZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGhpZ2hsaWdodC50cmFuc2Zvcm0oKTtcblx0XHRcdFx0XHRhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuXHRcdFx0XHRcdGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHgxOiBvcmlnaW4ueCxcblx0XHRcdFx0XHR5MTogb3JpZ2luLnksXG5cdFx0XHRcdFx0eDI6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHRcdFx0eTI6IGRlc3RpbmF0aW9uLnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuXHRcdFx0Z3JhZGllbnROb2RlID0gY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycyk7XG5cdFx0XHR2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuXHRcdFx0XHRcdGFscGhhID0gc3RvcENvbG9yLmdldEFscGhhKCk7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdG9mZnNldDogc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLnRvQ1NTKHRydWUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpKTtcblx0XHRcdH1cblx0XHRcdHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiAndXJsKCMnICsgZ3JhZGllbnROb2RlLmlkICsgJyknO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSkpO1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSBpdGVtLl9jb250ZW50O1xuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0dmFyIGV4cG9ydGVycyA9IHtcblx0XHRHcm91cDogZXhwb3J0R3JvdXAsXG5cdFx0TGF5ZXI6IGV4cG9ydEdyb3VwLFxuXHRcdFJhc3RlcjogZXhwb3J0UmFzdGVyLFxuXHRcdFBhdGg6IGV4cG9ydFBhdGgsXG5cdFx0U2hhcGU6IGV4cG9ydFNoYXBlLFxuXHRcdENvbXBvdW5kUGF0aDogZXhwb3J0Q29tcG91bmRQYXRoLFxuXHRcdFBsYWNlZFN5bWJvbDogZXhwb3J0UGxhY2VkU3ltYm9sLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCk7XG5cblx0XHRpZiAoaXRlbS5fbmFtZSAhPSBudWxsKVxuXHRcdFx0YXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuXG5cdFx0QmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHRcdHZhciBnZXQgPSBlbnRyeS5nZXQsXG5cdFx0XHRcdHR5cGUgPSBlbnRyeS50eXBlLFxuXHRcdFx0XHR2YWx1ZSA9IGl0ZW1bZ2V0XSgpO1xuXHRcdFx0aWYgKGVudHJ5LmV4cG9ydEZpbHRlclxuXHRcdFx0XHRcdD8gZW50cnkuZXhwb3J0RmlsdGVyKGl0ZW0sIHZhbHVlKVxuXHRcdFx0XHRcdDogIXBhcmVudCB8fCAhQmFzZS5lcXVhbHMocGFyZW50W2dldF0oKSwgdmFsdWUpKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgYWxwaGEgPSB2YWx1ZS5nZXRBbHBoYSgpO1xuXHRcdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGUgKyAnLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdFx0PyAnbm9uZSdcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGZvcm1hdHRlci5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmpvaW4oJywnKVxuXHRcdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHRcdD8gZW50cnkudG9TVkdbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG5cdFx0XHRkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuXHRcdGlmICghaXRlbS5fdmlzaWJsZSlcblx0XHRcdGF0dHJzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucztcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGRlZmluaXRpb25zID0geyBpZHM6IHt9LCBzdmdzOiB7fSB9O1xuXHRcdHJldHVybiBpdGVtICYmIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldERlZmluaXRpb24oaXRlbSwgbm9kZSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRnZXREZWZpbml0aW9uKCk7XG5cdFx0dmFyIGlkID0gZGVmaW5pdGlvbnMuaWRzW3R5cGVdID0gKGRlZmluaXRpb25zLmlkc1t0eXBlXSB8fCAwKSArIDE7XG5cdFx0bm9kZS5pZCA9IHR5cGUgKyAnLScgKyBpZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuXHRcdFx0XHRcdFx0c3ZnLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZzID0gc3ZnLmluc2VydEJlZm9yZShjcmVhdGVFbGVtZW50KCdkZWZzJyksXG5cdFx0XHRcdFx0XHRcdHN2Zy5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZzLmFwcGVuZENoaWxkKGRlZmluaXRpb25zLnN2Z3NbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9ucy5hc1N0cmluZ1xuXHRcdFx0XHQ/IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKVxuXHRcdFx0XHQ6IHN2Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNWRyhpdGVtLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgZXhwb3J0ZXIgPSBleHBvcnRlcnNbaXRlbS5fY2xhc3NdLFxuXHRcdFx0bm9kZSA9IGV4cG9ydGVyICYmIGV4cG9ydGVyKGl0ZW0sIG9wdGlvbnMpO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHR2YXIgb25FeHBvcnQgPSBvcHRpb25zLm9uRXhwb3J0O1xuXHRcdFx0aWYgKG9uRXhwb3J0KVxuXHRcdFx0XHRub2RlID0gb25FeHBvcnQoaXRlbSwgbm9kZSwgb3B0aW9ucykgfHwgbm9kZTtcblx0XHRcdHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5fZGF0YSk7XG5cdFx0XHRpZiAoZGF0YSAmJiBkYXRhICAhPT0gJ3t9Jylcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZSAmJiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhleHBvcnRTVkcodGhpcywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0c2l6ZSA9IHZpZXcuZ2V0Vmlld1NpemUoKSxcblx0XHRcdFx0bm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycsIHtcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzaXplLmhlaWdodCxcblx0XHRcdFx0XHR2ZXJzaW9uOiAnMS4xJyxcblx0XHRcdFx0XHR4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0XHQneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcblx0XHRcdFx0fSksXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUsXG5cdFx0XHRcdG1hdHJpeCA9IHZpZXcuX21hdHJpeDtcblx0XHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdFx0cGFyZW50ID0gbm9kZS5hcHBlbmRDaGlsZChcblx0XHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQoJ2cnLCBnZXRUcmFuc2Zvcm0obWF0cml4KSkpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGxheWVyc1tpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBuYW1lc3BhY2Vcblx0XHRcdFx0PyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSlcblx0XHRcdFx0OiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHRpZiAodmFsdWUgPT09ICdudWxsJylcblx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHRcdD8gJydcblx0XHRcdFx0XHRcdDogMFxuXHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0PyB2YWx1ZVxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb2ludChub2RlLCB4LCB5LCBhbGxvd051bGwpIHtcblx0XHR4ID0gZ2V0VmFsdWUobm9kZSwgeCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHksIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNpemUobm9kZSwgdywgaCwgYWxsb3dOdWxsKSB7XG5cdFx0dyA9IGdldFZhbHVlKG5vZGUsIHcsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdGggPSBnZXRWYWx1ZShub2RlLCBoLCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgU2l6ZSh3LCBoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHQ/IHBhcnNlRmxvYXQodmFsdWUpXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHQ/IHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW11cblx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IGdldERlZmluaXRpb24odmFsdWUpIHx8IHZhbHVlXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHQ/IGxvb2t1cFt2YWx1ZV1cblx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0aXNDbGlwID0gdHlwZSA9PT0gJ2NsaXBwYXRoJyxcblx0XHRcdGl0ZW0gPSBuZXcgR3JvdXAoKSxcblx0XHRcdHByb2plY3QgPSBpdGVtLl9wcm9qZWN0LFxuXHRcdFx0Y3VycmVudFN0eWxlID0gcHJvamVjdC5fY3VycmVudFN0eWxlLFxuXHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRpZiAoIWlzQ2xpcCkge1xuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2Rlc1tpXSxcblx0XHRcdFx0Y2hpbGQ7XG5cdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxXG5cdFx0XHRcdFx0JiYgKGNoaWxkID0gaW1wb3J0U1ZHKGNoaWxkTm9kZSwgb3B0aW9ucywgZmFsc2UpKVxuXHRcdFx0XHRcdCYmICEoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2wpKVxuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHR9XG5cdFx0aXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0aWYgKGlzQ2xpcClcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbS5yZWR1Y2UoKSwgbm9kZSwgaXNSb290KTtcblx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGU7XG5cdFx0aWYgKGlzQ2xpcCB8fCB0eXBlID09PSAnZGVmcycpIHtcblx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgY29vcmRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLm1hdGNoKFxuXHRcdFx0XHRcdC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaSArIDFdKSkpO1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcblx0XHRpZiAodHlwZSA9PT0gJ3BvbHlnb24nKVxuXHRcdFx0cGF0aC5jbG9zZVBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuXHRcdHZhciBkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSxcblx0XHRcdHBhcmFtID0geyBwYXRoRGF0YTogZGF0YSB9O1xuXHRcdHJldHVybiAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDEgfHwgL3pcXFMrL2kudGVzdChkYXRhKVxuXHRcdFx0XHQ/IG5ldyBDb21wb3VuZFBhdGgocGFyYW0pXG5cdFx0XHRcdDogbmV3IFBhdGgocGFyYW0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuXHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRpc1JhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG5cdFx0XHRncmFkaWVudDtcblx0XHRpZiAoaWQpIHtcblx0XHRcdGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3RvcHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0c3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdFx0Z3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIGlzUmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodDtcblx0XHRpZiAoaXNSYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKGdldFZhbHVlKG5vZGUsICdyJyksIDApO1xuXHRcdFx0aGlnaGxpZ2h0ID0gZ2V0UG9pbnQobm9kZSwgJ2Z4JywgJ2Z5JywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInKTtcblx0XHR9XG5cdFx0YXBwbHlBdHRyaWJ1dGVzKFxuXHRcdFx0bmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpbXBvcnRlcnMgPSB7XG5cdFx0JyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuXHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRub2RlLmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZzogaW1wb3J0R3JvdXAsXG5cdFx0c3ZnOiBpbXBvcnRHcm91cCxcblx0XHRjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG5cdFx0cG9seWdvbjogaW1wb3J0UG9seSxcblx0XHRwb2x5bGluZTogaW1wb3J0UG9seSxcblx0XHRwYXRoOiBpbXBvcnRQYXRoLFxuXHRcdGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblx0XHRyYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cblx0XHRpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuXHRcdFx0cmFzdGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneCcsICd5JykuYWRkKHNpemUuZGl2aWRlKDIpKSk7XG5cdFx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByYXN0ZXI7XG5cdFx0fSxcblxuXHRcdHN5bWJvbDogZnVuY3Rpb24obm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN5bWJvbChpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpO1xuXHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0XHQ/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xcblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpLFxuXHRcdFx0XHRyYWRpdXMgPSBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpO1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShwb2ludCwgc2l6ZSksIHJhZGl1cyk7XG5cdFx0fSxcblxuXHRcdGxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgUGF0aC5MaW5lKGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUsICd4JywgJ3knKVxuXHRcdFx0XHRcdC5hZGQoZ2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUpIHtcblx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHR2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0bWF0cml4LmNvbmNhdGVuYXRlKFxuXHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIgY29sb3IgPSBpdGVtW25hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcidcblx0XHRcdFx0OiAnZ2V0U3Ryb2tlQ29sb3InXSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0aWYgKGVudHJ5LnR5cGUgPT09ICdjb2xvcicgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRpZiAoY29sb3IpXG5cdFx0XHRcdFx0Y29sb3IudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdGl0ZW0uZ2V0UG9zaXRpb24odHJ1ZSkubmVnYXRlKCkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0ZGlzcGxheTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSB2YWx1ZS5tYXRjaCgvKC4qKSUkLyk7XG5cdFx0XHRpdGVtLnNldFJhbXBQb2ludChwZXJjZW50YWdlXG5cdFx0XHRcdFx0PyBwZXJjZW50YWdlWzFdIC8gMTAwXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcsIHRydWUpO1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSBzaXplID8gcmVjdC5nZXRTaXplKCkuZGl2aWRlKHNpemUpIDogMSxcblx0XHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKSkuc2NhbGUoc2NhbGUpO1xuXHRcdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXguaW52ZXJ0ZWQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2xpcCA9IGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9ICd2aXNpYmxlJyxcblx0XHRcdFx0XHRncm91cCA9IGl0ZW0uX2RlZmluaXRpb247XG5cdFx0XHRcdGlmIChjbGlwICYmICFyZWN0LmNvbnRhaW5zKGdyb3VwLmdldEJvdW5kcygpKSkge1xuXHRcdFx0XHRcdGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpLnRyYW5zZm9ybShncm91cC5fbWF0cml4KTtcblx0XHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRcdGdyb3VwLmFkZENoaWxkKGNsaXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKSB7XG5cdFx0dmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IGF0dHIgJiYgYXR0ci52YWx1ZTtcblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0PyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgc3R5bGVzID0ge1xuXHRcdFx0bm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG5cdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZS5wYXJlbnROb2RlKSB8fCB7fVxuXHRcdH07XG5cdFx0QmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGFwcGx5LCBuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtID0gQmFzZS5waWNrKGFwcGx5KGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpLCBpdGVtKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9O1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1hdGNoID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL1xcKCg/OiN8KShbXiknXSspLyk7XG5cdFx0cmV0dXJuIG1hdGNoICYmIGRlZmluaXRpb25zW21hdGNoWzFdXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdGlmICghc291cmNlKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3B0aW9ucyA9IHsgb25Mb2FkOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIG5vZGUgPSBzb3VyY2UsXG5cdFx0XHRzY29wZSA9IHBhcGVyO1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soc3ZnKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoc3ZnLCBvcHRpb25zLCBpc1Jvb3QpLFxuXHRcdFx0XHRvbkxvYWQgPSBvcHRpb25zLm9uTG9hZCxcblx0XHRcdFx0dmlldyA9IHNjb3BlLnByb2plY3QgJiYgc2NvcGUuZ2V0VmlldygpO1xuXHRcdFx0aWYgKG9uTG9hZClcblx0XHRcdFx0b25Mb2FkLmNhbGwodGhpcywgaXRlbSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRub2RlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzb3VyY2UsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0aWYgKCFub2RlLm5vZGVOYW1lKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuXHRcdFx0aXRlbSxcblx0XHRcdGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyksXG5cdFx0XHRzZXR0aW5ncyA9IHNjb3BlLnNldHRpbmdzLFxuXHRcdFx0cHJldkFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBmYWxzZTtcblx0XHRpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gcHJldkFwcGx5TWF0cml4O1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRpZiAodHlwZSAhPT0gJyNkb2N1bWVudCcgJiYgIShpdGVtIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHR2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0O1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWxcbn0pKSgpO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdGRlZmluZSgncGFwZXInLCBwYXBlcik7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHBhcGVyO1xufVxuXG5yZXR1cm4gcGFwZXI7XG59O1xuIiwidmFyIHBhcGVyID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItd29ya2VyLmpzJyk7XG5cbmZ1bmN0aW9uIENvbnRvdXIoIGFyZ3MgKSB7XG5cdHBhcGVyLlBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIGFyZ3MgKTtcblxuXHR0aGlzLm5vZGVzID0gdGhpcy5zZWdtZW50cztcbn1cblxuQ29udG91ci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcGVyLlBhdGgucHJvdG90eXBlKTtcbkNvbnRvdXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udG91cjtcblxuQ29udG91ci5wcm90b3R5cGUuYWRkTm9kZXMgPSBwYXBlci5QYXRoLnByb3RvdHlwZS5hZGRTZWdtZW50cztcblxuQ29udG91ci5wcm90b3R5cGUucHJlcGFyZU9UID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0dHlwZTogJ00nLFxuXHRcdHg6IE1hdGgucm91bmQoIHRoaXMuZmlyc3RTZWdtZW50LnBvaW50LnggKSB8fCAwLFxuXHRcdHk6IE1hdGgucm91bmQoIHRoaXMuZmlyc3RTZWdtZW50LnBvaW50LnkgKSB8fCAwXG5cdH0pO1xuXG5cdHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24oIGN1cnZlICkge1xuXHRcdGlmICggY3VydmUuaXNMaW5lYXIoKSApIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdMJyxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdDJyxcblx0XHRcdFx0eDE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS54ICsgY3VydmUuaGFuZGxlMS54ICkgfHwgMCxcblx0XHRcdFx0eTE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS55ICsgY3VydmUuaGFuZGxlMS55ICkgfHwgMCxcblx0XHRcdFx0eDI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi54ICsgY3VydmUuaGFuZGxlMi54ICkgfHwgMCxcblx0XHRcdFx0eTI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi55ICsgY3VydmUuaGFuZGxlMi55ICkgfHwgMCxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRvdXI7IiwidmFyIG9wZW50eXBlID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9vcGVudHlwZS5qcycpLFxuXHRHbHlwaCA9IHJlcXVpcmUoJy4vR2x5cGguanMnKTtcblxuZnVuY3Rpb24gRm9udCggYXJncyApIHtcblx0aWYgKCAhYXJncy5zdHlsZU5hbWUgKSB7XG5cdFx0YXJncy5zdHlsZU5hbWUgPSAnUmVndWxhcic7XG5cdH1cblxuXHRpZiAoICFhcmdzLnVuaXRzUGVyRW0gKSB7XG5cdFx0YXJncy51bml0c1BlckVtID0gMTAyNDtcblx0fVxuXG5cdHRoaXMub3QgPSBuZXcgb3BlbnR5cGUuRm9udCggYXJncyApO1xuXG5cdHRoaXMuZ2x5cGhzID0gW107XG5cdHRoaXMuZ2x5cGhNYXAgPSB7fTtcblx0dGhpcy5fc3Vic2V0ID0gZmFsc2U7XG5cblx0dGhpcy5hZGRHbHlwaChuZXcgR2x5cGgoe1xuXHRcdG5hbWU6ICcubm90ZGVmJyxcblx0XHR1bmljb2RlOiAwXG5cdH0pKTtcbn1cblxuRm9udC5wcm90b3R5cGUuYWRkR2x5cGggPSBmdW5jdGlvbiggZ2x5cGggKSB7XG5cdHRoaXMuZ2x5cGhzLnB1c2goIGdseXBoICk7XG5cdHRoaXMuZ2x5cGhNYXBbZ2x5cGgubmFtZV0gPSBnbHlwaDtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkZvbnQucHJvdG90eXBlLmFkZEdseXBocyA9IGZ1bmN0aW9uKCBnbHlwaHMgKSB7XG5cdGdseXBocy5mb3JFYWNoKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHR0aGlzLmFkZEdseXBoKGdseXBoKTtcblxuXHR9LCB0aGlzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRm9udC5wcm90b3R5cGUsICdzdWJzZXQnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YnNldDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggc2V0ICkge1xuXHRcdGlmICggc2V0ID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiAoIHRoaXMuX3N1YnNldCA9IGZhbHNlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICggdGhpcy5fc3Vic2V0ID0gKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnID8gc2V0LnNwbGl0KCcnKSA6IHNldClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oZSwgaSwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiBhcnIubGFzdEluZGV4T2YoZSkgPT09IGk7XG5cdFx0XHR9KVxuXHRcdFx0Lm1hcChmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHJldHVybiBlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHR9KVxuXHRcdFx0LnNvcnQoKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5Gb250LnByb3RvdHlwZS5nZXRHbHlwaFN1YnNldCA9IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdGlmICggc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy5zdWJzZXQgPSBzZXQ7XG5cdH1cblxuXHQvLyByZXVzZSBsYXN0IHN1YnNldCBpZiBwb3NzaWJsZVxuXHRpZiAoIHRoaXMuX2xhc3RTdWJzZXQgJiYgdGhpcy5fbGFzdFN1YnNldFswXSA9PT0gKCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RTdWJzZXRbMV07XG5cdH1cblxuXHQvLyBtZW1vaXplIGxhc3Qgc3Vic2V0XG5cdHRoaXMuX2xhc3RTdWJzZXQgPSBbXG5cdFx0KCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCksXG5cdFx0dGhpcy5nbHlwaHMuZmlsdGVyKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHRcdGlmICggdGhpcy5fc3Vic2V0ID09PSBmYWxzZSAmJiAoIGdseXBoLnVuaWNvZGUgIT09IGZhbHNlIHx8IGdseXBoLnVuaWNvZGVzLmxlbmd0aCApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLl9zdWJzZXQuaW5kZXhPZiggZ2x5cGgudW5pY29kZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IGhhbmRsZSBtdWx0aXBsZSB1bmljb2Rlc1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSwgdGhpcylcblx0XTtcblxuXHRyZXR1cm4gdGhpcy5fbGFzdFN1YnNldFsxXTtcbn07XG5cbkZvbnQucHJvdG90eXBlLnByZXBhcmVPVCA9IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdHRoaXMub3QuZ2x5cGhzID0gdGhpcy5nZXRHbHlwaFN1YnNldCggc2V0ICkubWFwKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHRyZXR1cm4gZ2x5cGgucHJlcGFyZU9UKCk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKCB3aW5kb3cuZG9jdW1lbnQgKSB7XG5cdHZhciBfVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMLFxuXHRcdHJ1bGVJbmRleDtcblx0Rm9udC5wcm90b3R5cGUuYWRkVG9Gb250cyA9IGRvY3VtZW50LmZvbnRzID9cblx0XHQvLyBDU1MgZm9udCBsb2FkaW5nLCBsaWdodG5pbmcgZmFzdFxuXHRcdGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cdFx0XHR2YXIgZm9udGZhY2UgPSBuZXcgRm9udEZhY2UoXG5cdFx0XHRcdHRoaXMub3QuZmFtaWx5TmFtZSxcblx0XHRcdFx0YnVmZmVyIHx8IHRoaXMub3QudG9CdWZmZXIoKVxuXHRcdFx0KTtcblxuXHRcdFx0ZG9jdW1lbnQuZm9udHMuYWRkKCBmb250ZmFjZSApO1xuXG5cdFx0XHRpZiAoIHRoaXMubGFzdEZvbnRGYWNlICkge1xuXHRcdFx0XHRkb2N1bWVudC5mb250cy5kZWxldGUoIHRoaXMubGFzdEZvbnRGYWNlICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubGFzdEZvbnRGYWNlID0gZm9udGZhY2U7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH06XG5cdFx0ZnVuY3Rpb24oIGJ1ZmZlciApIHtcblx0XHRcdHZhciB1cmwgPSBfVVJMLmNyZWF0ZU9iamVjdFVSTChcblx0XHRcdFx0bmV3IEJsb2IoXG5cdFx0XHRcdFx0WyBuZXcgRGF0YVZpZXcoIGJ1ZmZlciB8fMKgdGhpcy5vdC50b0J1ZmZlcigpICkgXSxcblx0XHRcdFx0XHR7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoIHJ1bGVJbmRleCApIHtcblx0XHRcdFx0ZG9jdW1lbnQuc3R5bGVTaGVldHNbMF0uZGVsZXRlUnVsZSggcnVsZUluZGV4ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJ1bGVJbmRleCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzWzBdLmluc2VydFJ1bGUoXG5cdFx0XHRcdCdAZm9udC1mYWNlIHsgZm9udC1mYW1pbHk6IFwiJyArIHRoaXMub3QuZmFtaWx5TmFtZSArICdcIjsgc3JjOiB1cmwoJyArIHVybCArICcpOyB9Jyxcblx0XHRcdFx0cnVsZUluZGV4IHx8wqBkb2N1bWVudC5zdHlsZVNoZWV0c1swXS5jc3NSdWxlcy5sZW5ndGhcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG59XG5cbkZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oIGJ1ZmZlciApIHtcblx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cblx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHdpbmRvdy5sb2NhdGlvbiA9IHJlYWRlci5yZXN1bHQ7XG5cdH07XG5cblx0cmVhZGVyLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoXG5cdFx0WyBuZXcgRGF0YVZpZXcoIGJ1ZmZlciB8fCB0aGlzLm90LnRvQnVmZmVyKCkgKSBdLFxuXHRcdHt0eXBlOiAnZm9udC9vcGVudHlwZSd9XG5cdCkpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb250OyIsInZhciBvcGVudHlwZSA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvb3BlbnR5cGUuanMnKSxcblx0cGFwZXIgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci13b3JrZXIuanMnKTtcblxuZnVuY3Rpb24gR2x5cGgoIGFyZ3MgKSB7XG5cdHBhcGVyLkdyb3VwLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseSggdGhpcyApO1xuXG5cdGlmICggYXJncy51bmljb2RlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0YXJncy51bmljb2RlID0gYXJncy5uYW1lLmNoYXJDb2RlQXQoMCk7XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBhcmdzLnVuaWNvZGUgPT09ICdzdHJpbmcnICkge1xuXHRcdGFyZ3MudW5pY29kZSA9IGFyZ3MudW5pY29kZS5jaGFyQ29kZUF0KDApO1xuXHR9XG5cblx0dGhpcy5vdCA9IG5ldyBvcGVudHlwZS5HbHlwaCggYXJncyApO1xuXHR0aGlzLm90LnBhdGggPSBuZXcgb3BlbnR5cGUuUGF0aCgpO1xuXG5cdHRoaXMuY29udG91cnMgPSBbXTtcblx0dGhpcy5hbmNob3JzID0gW107XG5cdHRoaXMuY29tcG9uZW50cyA9IFtdO1xuXHR0aGlzLnBhcmVudEFuY2hvcnMgPSBbXTtcbn1cblxuR2x5cGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXBlci5Hcm91cC5wcm90b3R5cGUpO1xuR2x5cGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2x5cGg7XG5cbkdseXBoLnByb3RvdHlwZS5hZGRDb250b3VyID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdHRoaXMuYWRkQ2hpbGQoIGl0ZW0gKTtcblx0dGhpcy5jb250b3Vycy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHR0aGlzLmFkZENoaWxkKCBpdGVtICk7XG5cdHRoaXMuY29tcG9uZW50cy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZEFuY2hvciA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHR0aGlzLmFuY2hvcnMucHVzaCggaXRlbSApO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkdseXBoLnByb3RvdHlwZS5hZGRQYXJlbnRBbmNob3IgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0dGhpcy5wYXJlbnRBbmNob3JzLnB1c2goIGl0ZW0gKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUucHJlcGFyZU9UID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdGlmICggIXBhdGggKSB7XG5cdFx0dGhpcy5vdC5wYXRoLmNvbW1hbmRzID0gW107XG5cdFx0cGF0aCA9IHRoaXMub3QucGF0aDtcblx0fVxuXG5cdHRoaXMuY29udG91cnMuZm9yRWFjaChmdW5jdGlvbiggY29udG91ciApIHtcblx0XHRjb250b3VyLnByZXBhcmVPVCggdGhpcy5vdC5wYXRoICk7XG5cdH0sIHRoaXMpO1xuXG5cdHJldHVybiB0aGlzLm90O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaDsiLCJ2YXIgb3BlbnR5cGUgPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL29wZW50eXBlLmpzJyksXG5cdHBhcGVyID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItd29ya2VyLmpzJyksXG5cdEZvbnQgPSByZXF1aXJlKCcuL0ZvbnQuanMnKSxcblx0R2x5cGggPSByZXF1aXJlKCcuL0dseXBoLmpzJyksXG5cdENvbnRvdXIgPSByZXF1aXJlKCcuL0NvbnRvdXIuanMnKSxcblx0dXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG5cbmZ1bmN0aW9uIHBsdW1pbigpIHt9XG5cbnBsdW1pbi5vcGVudHlwZSA9IG9wZW50eXBlO1xucGx1bWluLnBhcGVyID0gcGFwZXI7XG5wbHVtaW4uRm9udCA9IEZvbnQ7XG5wbHVtaW4uR2x5cGggPSBHbHlwaDtcbnBsdW1pbi5Db250b3VyID0gQ29udG91cjtcbnBsdW1pbi5Ob2RlID0gcGFwZXIuU2VnbWVudDtcbnBsdW1pbi5Qb2ludCA9IHBhcGVyLlBvaW50O1xucGx1bWluLk1hdHJpeCA9IHBhcGVyLk1hdHJpeDtcbnBsdW1pbi51dGlscyA9IHV0aWxzO1xucGx1bWluLnNldHVwID0gcGFwZXIuc2V0dXAuYmluZChwYXBlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1bWluOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8vIE9iamVjdC5taXhpbiBwb2x5ZmlsbCBmb3IgSUU5K1xuaWYgKCAhZ2xvYmFsLk9iamVjdC5taXhpbiApIHtcblx0Z2xvYmFsLk9iamVjdC5taXhpbiA9IGZ1bmN0aW9uKCB0YXJnZXQsIHNvdXJjZSApIHtcblx0XHR2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpLFxuXHRcdFx0cCxcblx0XHRcdGRlc2NyaXB0b3IsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKHAgPSAwOyBwIDwgbGVuZ3RoOyBwKyspIHtcblx0XHRcdGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcHNbcF0pO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcHNbcF0sIGRlc2NyaXB0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzLm1peGluID0gZ2xvYmFsLk9iamVjdC5taXhpbjtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSJdfQ==
